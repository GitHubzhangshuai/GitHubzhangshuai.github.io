<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="en">
<head>
  <!-- hexo-inject:begin --><!-- hexo-inject:end --><meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="卷积经典模型论文,翻译," />





  <link rel="alternate" href="/atom.xml" title="张帅的Blog" type="application/atom+xml" />






<meta name="description" content="点击下载原文pdf1http:&#x2F;&#x2F;papers.nips.cc&#x2F;paper&#x2F;4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf">
<meta property="og:type" content="article">
<meta property="og:title" content="论文-卷积经典模型-AlexNet">
<meta property="og:url" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/index.html">
<meta property="og:site_name" content="张帅的Blog">
<meta property="og:description" content="点击下载原文pdf1http:&#x2F;&#x2F;papers.nips.cc&#x2F;paper&#x2F;4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf">
<meta property="og:locale" content="en_US">
<meta property="og:image" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure1.png">
<meta property="og:image" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure2.png">
<meta property="og:image" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure3.png">
<meta property="og:image" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/table1.png">
<meta property="og:image" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/table2.png">
<meta property="og:image" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure4.png">
<meta property="og:image" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure1.png">
<meta property="og:image" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure2.png">
<meta property="og:image" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure3.png">
<meta property="og:image" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/table1.png">
<meta property="og:image" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/table2.png">
<meta property="og:image" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure4.png">
<meta property="article:published_time" content="2020-07-31T03:36:06.000Z">
<meta property="article:modified_time" content="2020-08-03T06:53:32.761Z">
<meta property="article:author" content="Zhangshuai">
<meta property="article:tag" content="卷积经典模型论文">
<meta property="article:tag" content="翻译">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure1.png">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://yoursite.com/2020/07/31/论文-卷积经典模型-AlexNet/"/>





  <title>论文-卷积经典模型-AlexNet | 张帅的Blog</title>
  








<meta name="generator" content="Hexo 4.2.1"><!-- hexo-inject:begin --><!-- hexo-inject:end --></head>

<body itemscope itemtype="http://schema.org/WebPage" lang="en">

  
  
    
  

  <!-- hexo-inject:begin --><!-- hexo-inject:end --><div class="container sidebar-position-left page-post-detail">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">张帅的Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle">用hexo搭建的简易博客</p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            Home
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-user"></i> <br />
            
            About
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-th"></i> <br />
            
            Categories
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            Archives
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-calendar"></i> <br />
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-sitemap"></i> <br />
            
            Sitemap
          </a>
        </li>
      
        
        <li class="menu-item menu-item-commonweal">
          <a href="/404/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-heartbeat"></i> <br />
            
            Commonweal 404
          </a>
        </li>
      

      
        <li class="menu-item menu-item-search">
          
            <a href="javascript:;" class="popup-trigger">
          
            
              <i class="menu-item-icon fa fa-search fa-fw"></i> <br />
            
            Search
          </a>
        </li>
      
    </ul>
  

  
    <div class="site-search">
      
  <div class="popup search-popup local-search-popup">
  <div class="local-search-header clearfix">
    <span class="search-icon">
      <i class="fa fa-search"></i>
    </span>
    <span class="popup-btn-close">
      <i class="fa fa-times-circle"></i>
    </span>
    <div class="local-search-input-wrapper">
      <input autocomplete="off"
             placeholder="Searching..." spellcheck="false"
             type="text" id="local-search-input">
    </div>
  </div>
  <div id="local-search-result"></div>
</div>



    </div>
  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            

  <div id="posts" class="posts-expand">
    

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Zhangshuai">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/uploads/avatar2.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="张帅的Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">论文-卷积经典模型-AlexNet</h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Posted on</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2020-07-31T11:36:06+08:00">
                2020-07-31
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">In</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/%E8%AE%BA%E6%96%87/" itemprop="url" rel="index">
                    <span itemprop="name">论文</span>
                  </a>
                </span>

                
                
              
            </span>
          


          
            
          

          
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        <p><a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">点击下载原文pdf</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;papers.nips.cc&#x2F;paper&#x2F;4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf</span><br></pre></td></tr></table></figure><br><a id="more"></a></p>
<p><a href="#" onclick="window.print()">下载/导出/打印本文</a></p>
<h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><div style="text-align:center;font-size:2rem">ImageNet Classification with Deep Convolutional Neural Networks</div>

<h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>We trained a large, deep convolutional neural network to classify the 1.2 million high-resolution images in the ImageNet LSVRC-2010 contest into the 1000 different classes.On the test data, we achieved top-1 and top-5 error rates of 37.5% and 17.0% which is considerably better than the previous state-of-the-art.The neural network, which has 60 million parameters and 650,000 neurons, consists of five convolutional layers, some of which are followed by max-pooling layers, and three fully-connected layers with a final 1000-way softmax. To make training faster, we used non-saturating neurons and a very efficient GPU implementation of the convolution operation. To reduce overfitting in the fully-connected layers we employed a recently-developed regularization method called “dropout” that proved to be very effective.We also entered a variant of this model in the ILSVRC-2012 competition and achieved a winning top-5 test error rate of 15.3%, compared to 26.2% achieved by the second-best entry.</p>
<h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2><p>Current approaches to object recognition make essential use of machine learning methods. To improve their performance, we can collect larger datasets, learn more powerful models, and use better techniques for preventing overfitting.<br>Until recently, datasets of labeled images were relatively small — on the order of tens of thousands of images (e.g., NORB [16], Caltech-101/256 [8, 9], and CIFAR-10/100 [12]). Simple recognition tasks can be solved quite well with datasets of this size, especially if they are augmented with label-preserving transformations.For example, the currentbest error rate on the MNIST digit-recognition task (&lt;0.3%) approaches human performance [4]. But objects in realistic settings exhibit considerable variability, so to learn to recognize them it is necessary to use much larger training sets.And indeed, the shortcomings of small image datasets have been widely recognized (e.g., Pinto et al. [21]), but it has only recently become possible to collect labeled datasets with millions of images.The new larger datasets include LabelMe [23], which consists of hundreds of thousands of fully-segmented images, and ImageNet [6], which consists of over 15 million labeled high-resolution images in over 22,000 categories.</p>
<p>To learn about thousands of objects from millions of images, we need a model with a large learning capacity.However, the immense complexity of the object recognition task means that this problem cannot be specified even by a dataset as large as ImageNet, so our model should also have lots of prior knowledge to compensate for all the data we don’t have.Convolutional neural networks (CNNs) constitute one such class of models [16, 11, 13, 18, 15, 22, 26]. Their capacity can be controlled by varying their depth and breadth, and they also make strong and mostly correct assumptions about the nature of images (namely, stationarity of statistics and locality of pixel dependencies).Thus, compared to standard feedforward neural networks with similarly-sized layers, CNNs have much fewer connections and parameters and so they are easier to train, while their theoretically-best performance is likely to be only slightly worse.</p>
<p>Despite the attractive qualities of CNNs, and despite the relative efficiency of their local architecture, they have still been prohibitively expensive to apply in large scale to high-resolution images.Luckily, current GPUs, paired with a highly-optimized implementation of 2D convolution, are powerful enough to facilitate the training of interestingly-large CNNs, and recent datasets such as ImageNet contain enough labeled examples to train such models without severe overfitting.</p>
<p>The specific contributions of this paper are as follows: we trained one of the largest convolutional neural networks to date on the subsets of ImageNet used in the ILSVRC-2010 and ILSVRC-2012 competitions [2] and achieved by far the best results ever reported on these datasets.We wrote a highly-optimized GPU implementation of 2D convolution and all the other operations inherent in training convolutional neural networks, which we make available publicly $^1$.Our network contains a number of new and unusual features which improve its performance and reduce its training time, which are detailed in Section 3.The size of our network made overfitting a significant problem, even with 1.2 million labeled training examples, so we used several effective techniques for preventing overfitting, which are described in Section 4.Our final network contains five convolutional and three fully-connected layers, and this depth seems to be important: we found that removing any convolutional layer (each of which contains no more than 1% of the model’s parameters) resulted in inferior performance.</p>
<hr>
<p>$^1$<a href="http://code.google.com/p/cuda-convnet/" target="_blank" rel="noopener">http://code.google.com/p/cuda-convnet/</a></p>
<p>In the end, the network’s size is limited mainly by the amount of memory available on current GPUs and by the amount of training time that we are willing to tolerate.Our network takes between five and six days to train on two GTX 580 3GB GPUs. All of our experiments suggest that our results can be improved simply by waiting for faster GPUs and bigger datasets to become available.</p>
<h2 id="2-The-Dataset"><a href="#2-The-Dataset" class="headerlink" title="2.The Dataset"></a>2.The Dataset</h2><p>ImageNet is a dataset of over 15 million labeled high-resolution images belonging to roughly 22,000 categories.The images were collected from the web and labeled by human labelers using Amazon’s Mechanical Turk crowd-sourcing tool.Starting in 2010, as part of the Pascal Visual Object Challenge, an annual competition called the ImageNet Large-Scale Visual Recognition Challenge (ILSVRC) has been held. ILSVRC uses a subset of ImageNet with roughly 1000 images in each of 1000 categories. In all, there are roughly 1.2 million training images, 50,000 validation images, and 150,000 testing images.</p>
<p>ILSVRC-2010 is the only version of ILSVRC for which the test set labels are available, so this is the version on which we performed most of our experiments.Since we also entered our model in the ILSVRC-2012 competition, in Section 6 we report our results on this version of the dataset as well, for which test set labels are unavailable.On ImageNet, it is customary to report two error rates: top-1 and top-5, where the top-5 error rate is the fraction of test images for which the correct label is not among the five labels considered most probable by the model.</p>
<p>ImageNet consists of variable-resolution images, while our system requires a constant input dimensionality.Therefore, we down-sampled the images to a fixed resolution of 256 × 256. Given a rectangular image, we first rescaled the image such that the shorter side was of length 256, and then cropped out the central 256×256 patch from the resulting image.We did not pre-process the images in any other way, except for subtracting the mean activity over the training set from each pixel. So we trained our network on the (centered) raw RGB values of the pixels.</p>
<h2 id="3-The-Architecture"><a href="#3-The-Architecture" class="headerlink" title="3.The Architecture"></a>3.The Architecture</h2><p>The architecture of our network is summarized in Figure 2. It contains eight learned layers — five convolutional and three fully-connected. Below, we describe some of the novel or unusual features of our network’s architecture. Sections 3.1-3.4 are sorted according to our estimation of their importance, with the most important first.</p>
<h3 id="3-1-ReLU-Nonlinearity"><a href="#3-1-ReLU-Nonlinearity" class="headerlink" title="3.1 ReLU Nonlinearity"></a>3.1 ReLU Nonlinearity</h3><p>The standard way to model a neuron’s output f as a function of its input x is with f(x) = tanh(x) or f(x) = (1 + $e^x$)−1. In terms of training time with gradient descent, these saturating nonlinearities are much slower than the non-saturating nonlinearity f(x) = max(0, x). Following Nair and Hinton [20], we refer to neurons with this nonlinearity as Rectified Linear Units (ReLUs). Deep convolutional neural networks with ReLUs train several times faster than their equivalents with tanh units. This is demonstrated in Figure 1, which shows the number of iterations required to reach 25% training error on the CIFAR-10 dataset for a particular four-layer convolutional network. This plot shows that we would not have been able to experiment with such large neural networks for this work if we had used traditional saturating neuron models.</p>
<p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure1.png" alt></p>
<p>Figure 1: A four-layer convolutional neural network with ReLUs (solid line) reaches a 25% training error rate on CIFAR-10 six times faster than an equivalent network with tanh neurons (dashed line). The learning rates for each network were chosen independently to make training as fast as possible. No regularization of any kind was employed. The magnitude of the effect demonstrated here varies with network architecture, but networks with ReLUs consistently learn several times faster than equivalents with saturating neurons.</p>
<p>We are not the first to consider alternatives to traditional neuron models in CNNs. For example, Jarrett etal.[11] claim that the nonlinearityf(x) = |tanh(x)| works particularly well with their type of contrast normalization followed by local average pooling on the Caltech-101 dataset. However, on this dataset the primary concern is preventing overfitting, so the effect they are observing is different from the accelerated ability to fit the training set which we report when using ReLUs. Faster learning has a great influence on the performance of large models trained on large datasets.</p>
<h3 id="3-2-Training-on-Multiple-GPUs"><a href="#3-2-Training-on-Multiple-GPUs" class="headerlink" title="3.2 Training on Multiple GPUs"></a>3.2 Training on Multiple GPUs</h3><p>A single GTX 580 GPU has only 3GB of memory, which limits the maximum size of the networks that can be trained on it. It turns out that 1.2 million training examples are enough to train networks which are too big to fit on one GPU. Therefore we spread the net across two GPUs. Current GPUs are particularly well-suited to cross-GPU parallelization, as they are able to read from and write to one another’s memory directly, without going through host machine memory. The parallelization scheme that we employ essentially puts half of the kernels (or neurons) on each GPU, with one additional trick: the GPUs communicate only in certain layers. This means that, for example, the kernels of layer 3 take input from all kernel maps in layer 2. However, kernels in layer 4 take input only from those kernel maps in layer 3 which reside on the same GPU. Choosing the pattern of connectivity is a problem for cross-validation, but this allows us to precisely tune the amount of communication until it is an acceptable fraction of the amount of computation.</p>
<p>The resultant architecture is somewhat similar to that of the “columnar” CNN employed by Cire¸ san et al. [5], except that our columns are not independent (see Figure 2). This scheme reduces our top-1 and top-5 error rates by 1.7% and 1.2%, respectively, as compared with a net with half as many kernels in each convolutional layer trained on one GPU. The two-GPU net takes slightly less time to train than the one-GPU  ${net}^2$。</p>
<hr>
<p>$^2$The one-GPU net actually has the same number of kernels as the two-GPU net in the final convolutional layer. This is because most of the net’s parameters are in the first fully-connected layer, which takes the last convolutional layer as input. So to make the two nets have approximately the same number of parameters, we did not halve the size of the final convolutional layer (nor the fully-conneced layers which follow). Therefore this comparison is biased in favor of the one-GPU net, since it is bigger than “half the size” of the two-GPU net.</p>
<h3 id="3-3-Local-Response-Normalization"><a href="#3-3-Local-Response-Normalization" class="headerlink" title="3.3 Local Response Normalization"></a>3.3 Local Response Normalization</h3><p>ReLUs have the desirable property that they do not require input normalization to prevent them from saturating. If at least some training examples produce a positive input to a ReLU, learning will happen in that neuron. However, we still find that the following local normalization scheme aids generalization. Denoting by $a^i_{x, y}$ the activity of a neuron computed by applying kernel i at position (x, y) and then applying the ReLU nonlinearity, the response-normalized activity $b^i_{x, y}$ given by the expression</p>
<script type="math/tex; mode=display">b^i_{x,y} = a^i_{x,y}/ (k+a\sum^{min(N-1,i+n/2)}_{j=max(0,i-n/2)} {a^i_{x,y}}^2)^\beta</script><p>where the sum runs over n “adjacent” kernel maps at the same spatial position, and N is the total number of kernels in the layer. The ordering of the kernel maps is of course arbitrary and determined before training begins. This sort of response normalization implements a form of lateral inhibition inspired by the type found in real neurons, creating competition for big activities amongst neuron outputs computed using different kernels. The constants k, n, α, and β are hyper-parameters whose values are determined using a validation set; we used k = 2, n = 5, α = $10^{-4}$, and β = 0.75. We applied this normalization after applying the ReLU nonlinearity in certain layers (see Section 3.5).</p>
<p>This scheme bears some resemblance to the local contrast normalization scheme of Jarrett et al. [11], but ours would be more correctly termed “brightness normalization”, since we do not subtract the mean activity. Response normalization reduces our top-1 and top-5 error rates by 1.4% and 1.2%, respectively. We also verified the effectiveness of this scheme on the CIFAR-10 dataset: a four-layer CNN achieved a 13% test error rate without normalization and 11% with normalization $^3$.</p>
<hr>
<p>$^3$We cannot describe this network in detail due to space constraints, but it is specified precisely by the code and parameter files provided here: <a href="http://code.google.com/p/cuda-convnet/" target="_blank" rel="noopener">http://code.google.com/p/cuda-convnet/</a></p>
<h3 id="3-4Overlapping-Pooling"><a href="#3-4Overlapping-Pooling" class="headerlink" title="3.4Overlapping Pooling"></a>3.4Overlapping Pooling</h3><p>Pooling layers in CNNs summarize the outputs of neighboring groups of neurons in the same kernel map.  Traditionally, the neighborhoods summarized by adjacent pooling units do not overlap (e.g.,[17, 11, 4]). To be more precise, a pooling layer can be thought of as consisting of a grid of pooling units spaced s pixels apart, each summarizing a neighborhood of size z × z centered at the location of the pooling unit. If we set s = z, we obtain traditional local pooling as commonly employed in CNNs. If we set s &lt; z, we obtain overlapping pooling. This is what we use throughout our network, with s = 2 and z = 3. This scheme reduces the top-1 and top-5 error rates by 0.4% and 0.3%, respectively, as compared with the non-overlapping scheme s = 2, z = 2, which produces output of equivalent dimensions. We generally observe during training that models with overlapping pooling find it slightly more difficult to overfit.</p>
<h3 id="3-5-Overall-Architecture"><a href="#3-5-Overall-Architecture" class="headerlink" title="3.5 Overall Architecture"></a>3.5 Overall Architecture</h3><p>Now we are ready to describe the overall architecture of our CNN. As depicted in Figure 2, the net contains eight layers with weights; the first five are convolutional and the remaining three are fullyconnected. The output of the last fully-connected layer is fed to a 1000-way softmax which produces a distribution over the 1000 class labels. Our network maximizes the multinomial logistic regression objective, which is equivalent to maximizing the average across training cases of the log-probability of the correct label under the prediction distribution. The kernels of the second, fourth, and fifth convolutional layers are connected only to those kernel maps in the previous layer which reside on the same GPU (see Figure 2). The kernels of the third convolutional layer are connected to all kernel maps in the second layer. The neurons in the fully-connected layers are connected to all neurons in the previous layer.Response-normalization layers follow the first and second convolutional layers. Max-poolinglayers, ofthekinddescribedinSection 3.4, follow both response-normalization layers as well as the fifth convolutional layer. The ReLU non-linearity is applied to the output of every convolutional and fully-connected layer. The first convolutional layer filters the 224×224×3 input image with 96 kernels of size 11×11×3 with a stride of 4 pixels (this is the distance between the receptive field centers of neighboring neurons in a kernel map). The second convolutional layer takes as input the (response-normalized and pooled) output of the first convolutional layer and filters it with 256 kernels of size 5 × 5 × 48. The third, fourth, and fifth convolutional layers are connected to one another without any intervening pooling or normalization layers. The third convolutional layer has 384 kernels of size 3 × 3 × 256 connected to the (normalized, pooled) outputs of the second convolutional layer. The fourth convolutional layer has 384 kernels of size 3 × 3 × 192 , and the fifth convolutional layer has 256 kernels of size 3 × 3 × 192. The fully-connected layers have 4096 neurons each.</p>
<p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure2.png" alt></p>
<p>Figure 2: An illustration of the architecture of our CNN, explicitly showing the delineation of responsibilities between the two GPUs. One GPU runs the layer-parts at the top of the figure while the other runs the layer-parts at the bottom. The GPUs communicate only at certain layers. The network’s input is 150,528-dimensional, and the number of neurons in the network’s remaining layers is given by 253,440–186,624–64,896–64,896–43,264– 4096–4096–1000.</p>
<h2 id="4-Reducing-Overfitting"><a href="#4-Reducing-Overfitting" class="headerlink" title="4 Reducing Overfitting"></a>4 Reducing Overfitting</h2><p>Our neural network architecture has 60 million parameters. Although the 1000 classes of ILSVRC make each training example impose 10 bits of constraint on the mapping from image to label, this turns out to be insufficient to learn so many parameters without considerable overfitting. Below, we describe the two primary ways in which we combat overfitting.</p>
<h3 id="4-1-Data-Augmentation"><a href="#4-1-Data-Augmentation" class="headerlink" title="4.1 Data Augmentation"></a>4.1 Data Augmentation</h3><p>The easiest and most common method to reduce overfitting on image data is to artificially enlarge the dataset using label-preserving transformations (e.g., [25, 4, 5]). We employ two distinct forms of data augmentation, both of which allow transformed images to be produced from the original images with very little computation, so the transformed images do not need to be stored on disk. In our implementation, the transformed images are generated in Python code on the CPU while the GPU is training on the previous batch of images. So these data augmentation schemes are, in effect, computationally free.</p>
<p>The first form of data augmentation consists of generating image translations and horizontal reflections. We do this by extracting random 224×224 patches (and their horizontal reflections) from the 256×256 images and training our network on these extracted patches $^4$. This increases the size of our training set by a factor of 2048, though the resulting training examples are, of course, highly interdependent. Without this scheme, our network suffers from substantial overfitting, which would have forced us to use much smaller networks. At test time, the network makes a prediction by extracting five 224 × 224 patches (the four corner patches and the center patch) as well as their horizontal reflections (hence ten patches in all), and averaging the predictions made by the network’s softmax layer on the ten patches.</p>
<hr>
<p>$^4$This is the reason why the input images in Figure 2 are 224 × 224 × 3-dimensional.</p>
<p>The second form of data augmentation consists of altering the intensities of the RGB channels in training images. Specifically, we perform PCA on the set of RGB pixel values throughout the ImageNet training set. To each training image, we add multiples of the found principal components,with magnitudes proportional to the corresponding eigenvalues times a random variable drawn from a Gaussian with mean zero and standard deviation 0.1. Therefore to each RGB image pixel $I_{xy}=[I_{xy}^R,I_{xy}^G,I_{xy}^B]$ we add the following quantity:</p>
<script type="math/tex; mode=display">[P1,P2,P3][\alpha1 \lambda1,\alpha2 \lambda2,\alpha3 \lambda3]^T</script><p>where pi and λi are ith eigenvector and eigenvalue of the 3 × 3 covariance matrix of RGB pixel values, respectively, and αiis the aforementioned random variable. Each αiis drawn only once for all the pixels of a particular training image until that image is used for training again, at which point it is re-drawn. This scheme approximately captures an important property of natural images, namely, that object identity is invariant to changes in the intensity and color of the illumination. This scheme reduces the top-1 error rate by over 1%.</p>
<h3 id="4-2-Dropout"><a href="#4-2-Dropout" class="headerlink" title="4.2 Dropout"></a>4.2 Dropout</h3><p>Combining the predictions of many different models is a very successful way to reduce test errors [1, 3], but it appears to be too expensive for big neural networks that already take several days to train. There is, however, a very efficient version of model combination that only costs about a factor of two during training. The recently-introduced technique, called “dropout” [10], consists of setting to zero the output of each hidden neuron with probability 0.5. The neurons which are “dropped out” in this way do not contribute to the forward pass and do not participate in backpropagation. So every time an input is presented, the neural network samples a different architecture, but all these architectures share weights. This technique reduces complex co-adaptations of neurons, since a neuron cannot rely on the presence of particular other neurons. It is, therefore, forced to learn more robust features that are useful in conjunction with many different random subsets of the other neurons. At test time, we use all the neurons but multiply their outputs by 0.5, which is a reasonable approximation to taking the geometric mean of the predictive distributions produced by the exponentially-many dropout networks. We use dropout in the first two fully-connected layers of Figure 2. Without dropout, our network exhibits substantial overfitting. Dropout roughly doubles the number of iterations required to converge.</p>
<h2 id="5-Details-of-learning"><a href="#5-Details-of-learning" class="headerlink" title="5 Details of learning"></a>5 Details of learning</h2><p>We trained our models using stochastic gradient descent with a batch size of 128 examples, momentum of 0.9, and weight decay of 0.0005. We found that this small amount of weight decay was important for the model to learn. In other words, weight decay here is not merely a regularizer: it reduces the model’s training error. The update rule for weight w was</p>
<script type="math/tex; mode=display">v_{i+1}:=0.9v_{i}-0.0005\epsilon w_i-\epsilon \langle \frac{\delta L}{\delta W }|_{w_i}\rangle _{D_i}</script><script type="math/tex; mode=display">w_{i+1}:=w_i+v_{i+1}</script><p>where i is the iteration index,v is the momentum variable,$\epsilon $is the learning rate,$\langle \frac{\delta L}{\delta W }|_{w_i}\rangle _{D_i}$is the average over the ith batch Diof the derivative of the objective with respect to w, evaluated at wi.<br><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure3.png" alt></p>
<p>Figure 3: 96 convolutional kernels of size 11×11×3learned by the first convolutional layer on the 224×224×3 input images. The top 48 kernels were learned on GPU 1 while the bottom 48 kernels were learned on GPU 2. See Section 6.1 for details.</p>
<p>We initialized the weights in each layer from a zero-mean Gaussian distribution with standard deviation 0.01. We initialized the neuron biases in the second, fourth, and fifth convolutional layers, as well as in the fully-connected hidden layers, with the constant 1. This initialization accelerates the early stages of learning by providing the ReLUs with positive inputs. We initialized the neuron biases in the remaining layers with the constant 0.</p>
<p>We used an equal learning rate for all layers, which we adjusted manually throughout training.<br>The heuristic which we followed was to divide the learning rate by 10 when the validation error rate stopped improving with the current learning rate. The learning rate was initialized at 0.01 and reduced three times prior to termination. We trained the network for roughly 90 cycles through the training set of 1.2 million images, which took five to six days on two NVIDIA GTX 580 3GB GPUs.</p>
<h2 id="6-Results"><a href="#6-Results" class="headerlink" title="6 Results"></a>6 Results</h2><p>Our results on ILSVRC-2010 are summarized in Table 1. Our network achieves top-1 and top-5 test set error rates of 37.5% and 17.0% $^5$.</p>
<hr>
<p>$^5 $ The error rates without averaging predictions over ten patches as described in Section 4.1 are 39.0% and 18.3%. The best performance achieved during the ILSVRC2010 competition was 47.1% and 28.2% with an approach that averages the predictions produced from six sparse-coding models trained on different features [2], and since then the best published results are 45.7% and 25.7% with an approach that averages the predictions of two classifiers trained on Fisher Vectors (FVs) computed from two types of densely-sampled features [24].</p>
<p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/table1.png" alt><br>Table 1: Comparison of results on ILSVRC2010 test set. In italics are best results achieved by others.</p>
<p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/table2.png" alt><br>Table 2: Comparison of error rates on ILSVRC-2012 validation and test sets. In italics are best results achieved by others. Models with an asterisk* were “pre-trained” to classify the entire ImageNet 2011 Fall release. See Section 6 for details.</p>
<p>We also entered our model in the ILSVRC-2012 competition and report our results in Table 2. Since the ILSVRC-2012 test set labels are not publicly available, we cannot report test error rates for all the models that we tried. In the remainder of this paragraph, we use validation and test error rates interchangeably because in our experience they do not differ by more than 0.1% (see Table 2). The CNN described in this paper achieves a top-5 error rate of 18.2%. Averaging the predictions of five similar CNNs gives an error rate of 16.4%. Training one CNN, with an extra sixth convolutional layer over the last pooling layer, to classify the entire ImageNet Fall 2011 release (15M images, 22K categories), and then “fine-tuning” it on ILSVRC-2012 gives an error rate of 16.6%. Averaging the predictions of two CNNs that were pre-trained on the entire Fall 2011 release with the aforementioned five CNNs gives an error rate of 15.3%. The second-best contest entry achieved an error rate of 26.2% with an approach that averages the predictions of several classifiers trained on FVs computed from different types of densely-sampled features [7]. </p>
<p>Finally, we also report our error rates on the Fall 2009 version of ImageNet with 10,184 categories and 8.9 million images. On this dataset we follow the convention in the literature of using half of the images for training and half for testing. Since there is no established test set, our split necessarily differs from the splits used by previous authors, but this does not affect the results appreciably. Our top-1 and top-5 error rates on this dataset are 67.4% and 40.9%, attained by the net described above but with an additional, sixth convolutional layer over the last pooling layer. The best published results on this dataset are 78.1% and 60.9% [19].</p>
<h3 id="6-1-Qualitative-Evaluations"><a href="#6-1-Qualitative-Evaluations" class="headerlink" title="6.1 Qualitative Evaluations"></a>6.1 Qualitative Evaluations</h3><p>Figure 3 shows the convolutional kernels learned by the network’s two data-connected layers. The network has learned a variety of frequency- and orientation-selective kernels, as well as various colored blobs. Notice the specialization exhibited by the two GPUs, a result of the restricted connectivity described in Section 3.5. The kernels on GPU 1 are largely color-agnostic, while the kernels on on GPU 2 are largely color-specific. This kind of specialization occurs during every run and is independent of any particular random weight initialization (modulo a renumbering of the GPUs).</p>
<p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure4.png" alt></p>
<p>Figure 4: (Left) Eight ILSVRC-2010 test images and the five labels considered most probable by our model. The correct label is written under each image, and the probability assigned to the correct label is also shown with a red bar (if it happens to be in the top 5). (Right) Five ILSVRC-2010 test images in the first column. The remaining columns show the six training images that produce feature vectors in the last hidden layer with the smallest Euclidean distance from the feature vector for the test image.</p>
<p>In the left panel of Figure 4 we qualitatively assess what the network has learned by computing its top-5 predictions on eight test images. Notice that even off-center objects, such as the mite in the top-left, can be recognized by the net. Most of the top-5 labels appear reasonable. For example, only other types of cat are considered plausible labels for the leopard. In some cases (grille, cherry) there is genuine ambiguity about the intended focus of the photograph.</p>
<p>Another way to probe the network’s visual knowledge is to consider the feature activations induced by an image at the last, 4096-dimensional hidden layer. If two images produce feature activation vectors with a small Euclidean separation, we can say that the higher levels of the neural network consider them to be similar. Figure 4 shows five images from the test set and the six images from the training set that are most similar to each of them according to this measure. Notice that at the pixel level, the retrieved training images are generally not close in L2 to the query images in the first column. For example, the retrieved dogs and elephants appear in a variety of poses. We present the results for many more test images in the supplementary material.</p>
<p>Computing similarity by using Euclidean distance between two 4096-dimensional, real-valued vec-torsisinefficient, but it could be made efficient by training an auto-encoder to compress these vectors to short binary codes. This should produce a much better image retrieval method than applying auto-encoders to the raw pixels [14], which does not make use of image labels and hence has a tendency to retrieve images with similar patterns of edges, whether or not they are semantically similar.</p>
<h2 id="7-Discussion"><a href="#7-Discussion" class="headerlink" title="7 Discussion"></a>7 Discussion</h2><p>Our results show that a large, deep convolutional neural network is capable of achieving recordbreaking results on a highly challenging dataset using purely supervised learning. It is notable that our network’s performance degrades if a single convolutional layer is removed. For example, removing any of the middle layers results in a loss of about 2% for the top-1 performance of the network. So the depth really is important for achieving our results.</p>
<p>To simplify our experiments, we did not use any unsupervised pre-training even though we expect that it will help, especially if we obtain enough computational power to significantly increase the size of the network without obtaining a corresponding increase in the amount of labeled data. Thus far, our results have improved as we have made our network larger and trained it longer but we still have many orders of magnitude to go in order to match the infero-temporal pathway of the human visual system. Ultimately we would like to use very large and deep convolutional nets on video sequences where the temporal structure provides very helpful information that is missing or far less obvious in static images.</p>
<h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] R.M. Bell and Y . Koren. Lessons from the netflixprizechallenge. ACM SIGKDD Explorations Newsletter,<br>9(2):75–79, 2007.<br>[2] A. Berg, J. Deng, and L. Fei-Fei.  Large scale visual recognition challenge 2010. www.image-<br>net.org/challenges. 2010.<br>[3] L. Breiman. Random forests. Machine learning, 45(1):5–32, 2001.<br>[4] D. Cire¸ san, U. Meier, and J. Schmidhuber. Multi-column deep neural networks for image classification.<br>Arxiv preprint arXiv:1202.2745, 2012.<br>[5] D.C. Cire¸ san, U. Meier, J. Masci, L.M. Gambardella, and J. Schmidhuber. High-performance neural<br>networks for visual object classification. Arxiv preprint arXiv:1102.0183, 2011.<br>[6] J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei-Fei. ImageNet: A Large-Scale Hierarchical<br>Image Database. In CVPR09, 2009.<br>[7] J. Deng, A. Berg, S. Satheesh, H. Su, A. Khosla, and L. Fei-Fei. ILSVRC-2012, 2012.  URL<br><a href="http://www.image-net.org/challenges/LSVRC/2012/" target="_blank" rel="noopener">http://www.image-net.org/challenges/LSVRC/2012/</a>.<br>[8] L. Fei-Fei, R. Fergus, and P . Perona. Learning generative visual models from few training examples: An<br>incremental bayesian approach tested on 101 object categories. Computer Vision and Image Understand-<br>ing, 106(1):59–70, 2007.<br>[9] G. Griffin, A. Holub, and P. Perona. Caltech-256 object category dataset. Technical Report 7694, Cali-<br>fornia Institute of Technology, 2007. URL <a href="http://authors.library.caltech.edu/7694" target="_blank" rel="noopener">http://authors.library.caltech.edu/7694</a>.<br>[10] G.E. Hinton, N. Srivastava, A. Krizhevsky, I. Sutskever, and R.R. Salakhutdinov. Improving neural net-<br>works by preventing co-adaptation of feature detectors. arXiv preprint arXiv:1207.0580, 2012.<br>[11] K. Jarrett, K. Kavukcuoglu, M. A. Ranzato, and Y . LeCun. What is the best multi-stage architecture for<br>object recognition? In International Conference on Computer Vision, pages 2146–2153. IEEE, 2009.<br>[12] A. Krizhevsky. Learning multiple layers of features from tiny images. Master’s thesis, Department of<br>Computer Science, University of Toronto, 2009.<br>[13] A. Krizhevsky. Convolutional deep belief networks on cifar-10. Unpublished manuscript, 2010.<br>[14] A. Krizhevsky and G.E. Hinton. Using very deep autoencoders for content-based image retrieval. In<br>ESANN, 2011.<br>[15] Y . Le Cun, B. Boser, J.S. Denker, D. Henderson, R.E. Howard, W. Hubbard, L.D. Jackel, et al. Hand-<br>written digit recognition with a back-propagation network. In Advances in neural information processing<br>systems, 1990.<br>[16] Y . LeCun, F.J. Huang, and L. Bottou. Learning methods for generic object recognition with invariance to<br>pose and lighting. In Computer Vision and Pattern Recognition, 2004. CVPR 2004. Proceedings of the<br>2004 IEEE Computer Society Conference on, volume 2, pages II–97. IEEE, 2004.<br>[17] Y . LeCun, K. Kavukcuoglu, and C. Farabet. Convolutional networks and applications in vision. In<br>Circuits and Systems (ISCAS), Proceedings of 2010 IEEE International Symposium on, pages 253–256.<br>IEEE, 2010.<br>[18] H. Lee, R. Grosse, R. Ranganath, and A.Y . Ng. Convolutional deep belief networks for scalable unsuper-<br>vised learning of hierarchical representations. InProceedings of the 26th Annual International Conference<br>on Machine Learning, pages 609–616. ACM, 2009.<br>[19] T. Mensink, J. V erbeek, F. Perronnin, and G. Csurka. Metric Learning for Large Scale Image Classifi-<br>cation: Generalizing to New Classes at Near-Zero Cost. In ECCV - European Conference on Computer<br>Vision, Florence, Italy, October 2012.<br>[20] V . Nair and G. E. Hinton. Rectified linear units improve restricted boltzmann machines. In Proc. 27th<br>International Conference on Machine Learning, 2010.<br>[21] N. Pinto, D.D. Cox, and J.J. DiCarlo. Why is real-world visual object recognition hard? PLoS computa-<br>tional biology, 4(1):e27, 2008.<br>[22] N. Pinto, D. Doukhan, J.J. DiCarlo, and D.D. Cox. A high-throughput screening approach to discovering<br>good forms of biologically inspired visual representation. PLoS computational biology, 5(11):e1000579,<br>2009.<br>[23] B.C. Russell, A. Torralba, K.P . Murphy, and W.T. Freeman. Labelme: a database and web-based tool for<br>image annotation. International journal of computer vision, 77(1):157–173, 2008.<br>[24] J. Sánchez and F. Perronnin. High-dimensional signature compression for large-scale image classification.<br>InComputer Vision and Pattern Recognition (CVPR), 2011 IEEE Conference on, pages 1665–1672. IEEE,<br>2011.<br>[25] P .Y . Simard, D. Steinkraus, and J.C. Platt. Best practices for convolutional neural networks applied to<br>visual document analysis. In Proceedings of the Seventh International Conference on Document Analysis<br>and Recognition, volume 2, pages 958–962, 2003.<br>[26] S.C. Turaga, J.F. Murray, V . Jain, F. Roth, M. Helmstaedter, K. Briggman, W. Denk, and H.S. Seung. Con-<br>volutional networks can learn to generate affinity graphs for image segmentation. Neural Computation,<br>22(2):511–538, 2010.</p>
<h1 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h1><div style="text-align:center;font-size:2rem">基于深卷积神经网络的图像网络分类</div>

<h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>我们训练了一个大型的深卷积神经网络，将ImageNetLSVRC-2010竞赛中的120万张高分辨率图像分成1000个不同的类别。在测试数据上，我们获得了前1名和前5名的错误率分别为37.5%和17.0%，这比以前的最新技术要好得多。这个神经网络有6000万个参数和65万个神经元，由5个卷积层组成，其中一些是最大池化层，还有3个完全连接的层，最后是1000-way的softmax。为了加快训练速度，我们使用非饱和神经元和一个非常有效的GPU实现卷积运算。为了减少完全连接层中的过拟合，我们采用了一种最近发展起来的正则化方法，称为“dropout”，这被证明是非常有效的。我们还在ILSVRC-2012竞赛中输入了该模型的一个变体，并获得了15.3%的前5名测试错误率，而第二名的测试错误率为26.2%。</p>
<h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>当前的目标识别方法主要利用机器学习方法。为了提高它们的性能，我们可以收集更大的数据集，学习更强大的模型，并使用更好的技术来防止过度拟合。直到最近，标记图像的数据集相对较小，只有数万张图像（例如，NORB[16]、Caltech-101/256[8,9]和CIFAR-10/100[12]）。使用这种大小的数据集可以很好地解决简单的识别任务，特别是如果使用保留标签的转换对它们进行扩充的话。例如，MNIST数字识别任务的当前最佳错误率（&lt;0.3%）接近人因绩效[4]。但是现实环境中的物体表现出相当大的可变性，所以要学会识别它们就必须使用更大的训练集。事实上，小图像数据集的缺点已经被广泛地认识到（例如，Pinto等人。[21]），但直到最近才有可能收集带有数百万图像的标记数据集。新的更大的数据集包括LabelMe[23]和ImageNet[6]，前者由数十万张全分割图像组成，后者由超过22000个类别的1500万张高分辨率图像组成。</p>
<p>要从数百万幅图像中了解成千上万的物体，我们需要一个具有很大学习能力的模型。然而，对象识别任务的巨大复杂性意味着即使像ImageNet这样大的数据集也不能指定这个问题，因此我们的模型还应该有大量的先验知识来弥补我们没有的所有数据。卷积神经网络(CNNs)就是这样一类模型[16,11,13,18,15,22,26]。它们的容量可以通过改变深度和宽度来控制，而且它们还可以对图像的性质(即统计的平稳性和像素依赖的局部性)做出强有力的、基本正确的假设。因此，与具有相似层大小的标准前馈神经网络相比，cnn具有更少的连接和参数，因此更容易训练，而理论上最好的性能可能只会稍微差一点。</p>
<p>尽管cnn具有吸引人的品质，尽管其本地架构相对高效，但大规模应用于高分辨率图像的成本仍令人望而却步。幸运的是，目前的gpu，加上一个高度优化的2D卷积实现，已经足够强大来方便训练大的cnn，而最近的数据集，比如ImageNet包含了足够多的带标记的例子来训练这样的模型，而不会出现严重的过拟合。</p>
<p>本文的具体贡献如下:我们在ILSVRC-2010和ILSVRC-2012竞赛[2]中使用的ImageNet子集训练了迄今为止最大的卷积神经网络之一，并在这些数据集上取得了迄今为止最好的结果。我们编写了一个高度优化的二维卷积GPU实现，以及训练卷积神经网络所固有的所有其他操作，这些操作我们已经公开提供了 $^1$。我们的网络包含了许多新的和不寻常的特性，这些特性提高了它的性能，减少了它的训练时间，这在第3节中详细介绍。我们的网络的规模使得过拟合成为一个严重的问题，即使有120万个标记的训练样本，所以我们使用了几种有效的技术来防止过拟合，这些技术将在第4节中描述。我们最终的网络包含5个卷积层和3个全连接层，而这种深度似乎很重要:我们发现，删除任何卷积层(每个卷积层包含的参数不超过模型的1%)都会导致性能下降。</p>
<hr>
<p>$^1$<a href="http://code.google.com/p/cuda-convnet/" target="_blank" rel="noopener">http://code.google.com/p/cuda-convnet/</a></p>
<p>最后，网络的大小主要受到当前gpu上可用的内存数量和我们愿意容忍的训练时间的限制。我们的网络在两个GTX 580 3GB gpu上需要5到6天的训练。我们所有的实验都表明，我们的结果可以通过等待更快的gpu和更大的数据集得到改善。</p>
<h2 id="2-数据集"><a href="#2-数据集" class="headerlink" title="2.数据集"></a>2.数据集</h2><p>ImageNet是一个包含超过1500万张高分辨率图像的数据集，大约属于22,000个类别。这些图片是从网上收集的，并由人使用Amazon’s Mechanical Turk crowd-sourcing tool进行手工标记。从2010年开始，作为Pascal视觉物体挑战赛的一部分，一年一度的ImageNet大型视觉识别挑战赛(ILSVRC)已经举行。从2010年开始，作为Pascal视觉物体挑战赛的一部分，一年一度的ImageNet大型视觉识别挑战赛(ILSVRC)已经举行。</p>
<p>ILSVRC-2010是唯一一个有测试集标签的ILSVRC版本，所以我们在这个版本上执行了大部分实验。由于我们也在ILSVRC-2012竞赛中输入了我们的模型，所以在第6节中，我们也报告了这个版本的数据集的结果，因为测试集标签是不可用的。在ImageNet上，通常会报告两个错误率:top-1和top-5，其中top-5错误率是测试图像中正确的标签不在模型认为最可能出现的5个标签中所占的比例。</p>
<p>ImageNet由不同分辨率的图像组成，而我们的系统需要一个恒定的输入维数。因此，我们将图像下采样到固定分辨率为256×256。对于一个矩形图像，我们首先对图像进行重新标定，使较短的边的长度为256，然后从得到的图像中裁剪出中间的256×256的patch。除了从每个像素中减去训练集上的平均活跃度之外，我们没有采用任何其他方法对图像进行预处理。因此，我们根据像素(居中)的原始RGB值训练我们的网络。</p>
<h2 id="3-体系结构"><a href="#3-体系结构" class="headerlink" title="3.体系结构"></a>3.体系结构</h2><p>图2总结了我们的网络架构。它包含8个学习层——5个卷积层和3个完全连接层。下面，我们将描述我们网络架构的一些新奇或不寻常的特征。3.1-3.4部分根据我们对其重要性的估计进行排序，最重要的放在前面。</p>
<h3 id="3-1-非线性的ReLU"><a href="#3-1-非线性的ReLU" class="headerlink" title="3.1 非线性的ReLU"></a>3.1 非线性的ReLU</h3><p>将神经元的输出f建模为其输入x的函数的标准方法是:f(x) = tanh(x)或f(x) = (1 + $e^x$)−1。在梯度下降的训练时间方面，这些饱和非线性比非饱和非线性f(x) = max(0, x)要慢得多。根据Nair和Hinton[20]，我们将具有这种非线性的神经元称为改良的直线单元(Rectified Linear Units简称ReLUs)。使用ReLUs的深度卷积神经网络的训练速度比使用tanh单元的神经网络快好几倍。如图1所示，它显示了对于一个特定的四层卷积网络，在CIFAR-10数据集上达到25%的训练误差所需的迭代次数。这张图表明，如果我们使用传统的饱和神经元模型，我们就无法用这么大的神经网络进行实验。</p>
<p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure1.png" alt></p>
<p>图1:带ReLUs(实线)的四层卷积神经网络在CIFAR-10上的训练错误率达到25%，比等效的带tanh神经元网络(虚线)快6倍。每个网络的学习率都是独立选择的，以便尽可能快地进行训练。没有采用任何形式的正规化。这里显示的影响的大小随着网络结构的不同而不同，但是有ReLUs的网络始终比有饱和神经元的网络学习速度快几倍。</p>
<p>我们不是第一个考虑替代传统神经元模型的cnn。例如，Jarrett etal.[11]声称非线性函数f(x) = |tanh(x)|与Caltech-101数据集上的对比归一化和本地平均池化层的类型一起工作得特别好。然而，在这个数据集上，主要的关注点是防止过拟合，因此他们观察到的效果与我们在使用ReLUs时报告的快速拟合训练集的能力不同。快速学习对在大数据集上训练的大模型的性能有很大的影响。这意味着，例如，第3层的内核从第2层的所有内核映射中获取输入。然而，层4中的内核只从层3中驻留在同一GPU上的内核映射中获取输入。</p>
<h3 id="3-2-在多GPU上的训练"><a href="#3-2-在多GPU上的训练" class="headerlink" title="3.2 在多GPU上的训练"></a>3.2 在多GPU上的训练</h3><p>一个GTX 580 GPU只有3GB的内存，这限制了它能训练的最大网络大小。事实证明，120万个训练例子足以训练那些大到无法在一个GPU上运行的网络。因此，我们将网络分散到两个gpu上。当前的gpu特别适合交叉gpu并行，因为它们能够直接读写彼此的内存，而不需要通过主机内存。我们采用的并行化方案本质上是将一半的内核(或神经元)放在每个GPU上，还有一个额外的技巧:GPU只在特定的层上通信。 选择连接模式是交叉验证的一个问题，但这允许我们精确地调整通信量，直到它成为计算量的一个可接受的部分。</p>
<p>这种架构与Cire¸ san et al. [5]所使用的“柱状”CNN有些相似，只是我们的专栏不是独立的(见图2)。 与在一个GPU上训练每个卷积层内核数量减半的网络相比，该方案将我们的top-1和top-5错误率分别降低了1.7%和1.2%。双gpu网络的训练时间略少于单gpu $网络^2$。</p>
<hr>
<p>$^2$在最终的卷积层中，单gpu网络实际上拥有与双gpu网络相同数量的内核。这是因为网络的大多数参数都在第一个完全连接层中，它将最后一个卷积层作为输入。 因此，为了使这两个网络具有大致相同数量的参数，我们没有将最后的卷积层(也没有将后面的完全连接层)的大小减半。因此这种比较偏向于单gpu网络，因为它大于双gpu网络的“一半大小”。</p>
<h3 id="3-3局部响应归一化"><a href="#3-3局部响应归一化" class="headerlink" title="3.3局部响应归一化"></a>3.3局部响应归一化</h3><p>ReLUs具有理想的特性，它们不需要输入归一化来防止饱和。如果至少有一些训练例子对一个ReLU产生了积极的输入，学习就会在那个神经元中发生。然而，我们仍然发现下面的局部归一化方案有助于推广。用$a^i_{x, y}$表示在位置(x, y)处应用核i计算的神经元的活性，再应用ReLU非线性，响应归一化的活性$b^i_{x, y}$由表达式给出</p>
<script type="math/tex; mode=display">b^i_{x,y} = a^i_{x,y}/ (k+a\sum^{min(N-1,i+n/2)}_{j=max(0,i-n/2)} {a^i_{x,y}}^2)^\beta</script><p>其中，和在同一空间位置的n个“相邻”核映射上运行，n是这一层的核总数。内核映射的顺序当然是任意的，在训练开始之前就确定了。这种响应归一化实现了一种形式的侧向抑制，这种抑制是由在真实神经元中发现的类型激发的，在使用不同内核计算的神经元输出之间产生对大型活动的竞争。常数k, n，以及，和，都是超参数，它们的值是通过验证集确定的;我们使用k = 2, n = 5，$\alpha$= $10^{-4}$，和$\beta$ = 0.75。我们在某些层中应用ReLU非线性后应用了这种归一化(见3.5节)。</p>
<p>这种方案与Jarrett等人[11]的局部对比度归一化方案有一些相似之处，但我们的方案更准确地称为“亮度归一化”，因为我们没有减去平均活动。 响应归一化使前1和前5的错误率分别降低了1.4%和1.2%。我们还验证了该方案在CIFAR-10数据集上的有效性:一个四层CNN在不进行归一化的情况下测试错误率为13%，在进行归一化的情况下测试错误率为11% $^3$。</p>
<hr>
<p>$^3$由于空间的限制，我们无法详细描述这个网络，但在这里提供的代码和参数文件中有精确的说明:<a href="http://code.google.com/p/cuda-convnet/" target="_blank" rel="noopener">http://code.google.com/p/cuda-convnet/</a></p>
<h3 id="3-4-重叠池化层"><a href="#3-4-重叠池化层" class="headerlink" title="3.4 重叠池化层"></a>3.4 重叠池化层</h3><p>网络神经网络的池化层总结同一核图中相邻神经元的输出。传统上，由相邻的共用单元汇总的社区并不重叠(如[17,11,4])。更精确地说，一个池化层可以被认为是由一个间隔s像素的池化单元网格组成，每个池化单元汇总一个大小为z×z的以池化单元位置为中心的邻域。设s = z，得到CNNs中常用的传统局部池。如果我们设置s &lt; z，我们得到重叠池。这是我们在整个网络中使用的，s = 2和z = 3。与不重叠的方案s = 2、z = 2相比，该方案的top-1和top-5错误率分别降低了0.4%和0.3%，产生了等效维数的输出。 我们通常在训练过程中观察到，使用重叠池的模型很难过度适应。</p>
<h3 id="3-5总体架构"><a href="#3-5总体架构" class="headerlink" title="3.5总体架构"></a>3.5总体架构</h3><p>现在我们准备描述CNN的整体架构。如图2所示，该网包含8个带有权重的层;前5个是卷积的，其余3个是完全连通的。最后的全连接层的输出被馈给一个1000-way的softmax，它产生超过1000类标签的分布。我们的网络最大化了多项logistic回归的目标，它等价于在预测分布下最大化正确标签的对数概率的训练案例的平均值。 第二、四、五卷积层的内核只与上一层位于同一GPU上的内核映射相连(见图2)。第三卷积层的内核与第二层的所有内核映射相连。完全连接层中的神经元与前一层的所有神经元相连。响应归一化层紧随第一个第二个卷积层。 3.4节提到的最大池化层遵循两个响应规范化层和第五个卷积层。每个卷积层和全连通层的输出均采用ReLU非线性。第一卷积层用96个11×11×3的核对224×224×3输入图像进行滤波，步长为4个像素（这是相邻的感受野中心之间的距离）。 第二个卷积层将第一个卷积层的（响应规范化和池化）输出作为输入，并用大小为5×5×48的256个核对其进行滤波。第三、第四和第五卷积层彼此连接而没有任何中间的池或规范化层。第三卷积层有384个大小为3×3×256的核，连接到第二个卷积层的（标准化的、混合的）输出端。第四卷积层有384个3×3×192的核，第五个卷积层有256个3×3×192的核。完全连接的层每层有4096个神经元。</p>
<p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure2.png" alt></p>
<p>图2：我们的CNN架构图，明确显示了两个GPU之间的职责划分。一个GPU运行图形顶部的层部件，而另一个GPU运行底部的层部件。gpu只在某些层进行通信。网络的输入为150528维，网络剩余层中的神经元数量为253440–186624–64896–64896–43264–4096–4096–1000。</p>
<h2 id="4-减少过拟合"><a href="#4-减少过拟合" class="headerlink" title="4.减少过拟合"></a>4.减少过拟合</h2><p>我们的神经网络架构有6000万个参数。虽然ILSVRC的1000个类使得每个训练示例对从图像到标签的映射施加10个位的约束，但这并不足以在不过度拟合的情况下学习这么多参数。下面，我们将介绍我们对抗过度拟合的两种主要方法。</p>
<p>减少图像数据过度拟合的最简单和最常见的方法是使用保留标签的变换（例如[25,4,5]）人为地放大数据集。我们采用了两种不同的数据增强形式，这两种方式都允许从原始图像生成经过变换的图像，而无需将转换后的图像存储在磁盘上。在我们的实现中，转换后的图像是在CPU上用Python代码生成的，而GPU正在对前一批图像进行训练。因此，这些数据扩充方案实际上是无需计算的。</p>
<p>数据增强的第一种形式包括生成图像平移和水平反射。我们通过从256×256幅图像中随机提取224×224个面片（及其水平反射），并在这些提取的斑块上训练我们的网络$^4$。这使我们的培训规模增加了2048倍，尽管最终的培训示例当然是高度相互依赖的。如果没有这个方案，我们的网络将遭受严重的过度拟合，这将迫使我们使用更小的网络。在测试时，网络通过提取五个224×224个面片（四角面片和中心面片）及其水平反射（因此总共十个面片）进行预测，并将网络的softmax层在这十个面片上所做的预测取平均值。</p>
<hr>
<p>$^4$ 这就是为什么图2中的输入图像是224×224×3维的。</p>
<p>第二种形式的数据增强包括改变训练图像中RGB通道的强度。具体地说，我们在ImageNet训练集中对RGB像素值集执行PCA。在每个训练图像中，我们添加找到的主成分的倍数，量值与相应的特征值乘以从平均值为零，标准偏差为0.1的高斯随机变量。因此，对每个RGB图像像素$I_{xy}=[I_{xy}^R,I_{xy}^G,I_{xy}^B]$加上以下数量：</p>
<script type="math/tex; mode=display">[P1,P2,P3][\alpha1 \lambda1,\alpha2 \lambda2,\alpha3 \lambda3]^T</script><p>其中，pi和λi分别为RGB像素值的3×3协方差矩阵的特征向量和特征值，α为上述随机变量。每个αi只为一个特定训练图像的所有像素绘制一次，直到该图像再次用于训练，此时重新绘制该图像。该方案近似地捕捉到了自然图像的一个重要特性，即物体的同一性随光照强度和颜色的变化而变化。该方案使前1个错误率降低了1%以上。</p>
<h3 id="4-2-Dropout-1"><a href="#4-2-Dropout-1" class="headerlink" title="4.2 Dropout"></a>4.2 Dropout</h3><p>将许多不同模型的预测结合起来是减少测试误差的一种非常成功的方法[1,3]，但对于已经花费数天时间进行训练的大型神经网络来说，这似乎太贵了。然而，有一个非常有效的模型组合版本，在培训期间只需花费大约两倍的成本。最近引入的技术称为“dropout”[10]，包括将每个隐藏神经元的输出设为0，概率为0.5。 以这种方式“退出”的神经元不参与前向传递，也不参与反向传播。 所以每次输入被提出时，神经网络都会对不同的结构进行采样，但所有这些结构都共享权重。 这种技术减少了神经元复杂的共适应，因为一个神经元不能依赖于其他特定神经元的存在。 因此，它被迫学习更健壮的特征，这些特征与其他神经元的许多不同的随机子集结合起来是有用的。在测试时，我们使用所有的神经元，但将它们的输出乘以0.5，这是一个合理的近似值，取指数型多个丢失网络产生的预测分布的几何平均值。我们在图2中的前两个完全连接的层中使用dropout。在没有dropout的情况下，我们的网络表现出严重的过度适应。Dropout大约是收敛所需迭代次数的两倍。</p>
<h2 id="5-学习细节"><a href="#5-学习细节" class="headerlink" title="5.学习细节"></a>5.学习细节</h2><p>我们使用随机梯度下降训练我们的模型，批量大小为128个例子，动量为0.9，权重衰减为0.0005。我们发现这个小的重量衰减对模型的学习很重要。换句话说，这里的权重衰减不仅仅是一个正则化器：它减少了模型的训练误差。权重w的更新规则是</p>
<script type="math/tex; mode=display">v_{i+1}:=0.9v_{i}-0.0005\epsilon w_i-\epsilon \langle \frac{\delta L}{\delta W }|_{w_i}\rangle _{D_i}</script><script type="math/tex; mode=display">w_{i+1}:=w_i+v_{i+1}</script><p>其中i是迭代索引,v是动量变量，$\epsilon$ 是学习率，$\langle \frac{\delta L}{\delta W }|_{w_i}\rangle _{D_i}$是第i批中目标相对于w的导数的平均值，在wi处计算。</p>
<p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure3.png" alt><br>图3:224×224×3输入图像第一卷积层学习的96个卷积核，大小为11×11×3。前48个内核在gpu1上学习，而后48个内核在gpu2上学习。详见第6.1节。</p>
<p>我们用标准差为0.01的零均值高斯分布初始化每个层的权重。我们用常数1初始化第二、第四和第五卷积层以及完全连接的隐藏层中的神经元偏差。这种初始化通过向ReLUs提供积极的输入加快了学习的早期阶段。我们用常数0初始化剩余层中的神经元偏差。</p>
<p>我们对所有层使用相同的学习率，在整个培训过程中我们手动调整。我们遵循的启发式方法是，当验证错误率不再随当前学习率提高时，将学习率除以10。学习率初始化为0.01，终止前降低3倍。我们通过120万张图像的训练集训练了网络大约90个周期，在两个 NVIDIA GTX 5803 gb gpu上花了5到6天的时间。</p>
<h2 id="6-Results-1"><a href="#6-Results-1" class="headerlink" title="6 Results"></a>6 Results</h2><p>表1总结了我们在ILSVRC-2010上的结果。我们的网络实现了前1名和前5名测试集错误率分别为37.5%和17.0% $^5$。</p>
<hr>
<p>$^5$ 如第4.1节所述，未对10个补丁进行平均预测的错误率分别为39.0%和18.3%。在ILSVRC2010竞赛中取得的最佳性能分别为47.1%和28.2%，采用的方法是平均六个针对不同特征训练的稀疏编码模型生成的预测值[2]，从那时起，最好的发布结果分别为45.7%和25.7%，使用一种方法，即使用两种密集采样特征计算出的Fisher向量（fv）训练的两个分类器的预测值的平均值[24]。</p>
<p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/table1.png" alt><br>表1:ILSVRC2010测试集结果比较。斜体字是别人取得的最好成绩。</p>
<p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/table2.png" alt><br>表2:ILSVRC-2012验证集和测试集的错误率比较。斜体字是别人取得的最好成绩。带有星号*的模型经过“预先训练”，对ImageNet 2011秋季发布的整个版本进行分类。详见第6节。</p>
<p>我们还在ILSVRC-2012竞赛中输入了我们的模型，并在表2中报告了我们的结果。由于ILSVRC-2012测试集标签不公开，我们无法报告我们尝试的所有模型的测试错误率。在本段的其余部分中，我们交替使用验证和测试错误率，因为根据我们的经验，它们之间的差异不超过0.1%（见表2）。本文描述的CNN的前5位错误率为18.2%。对5个相似的cnn进行平均预测，误差率为16.4%。训练一个CNN，在最后一个池层上增加一个第六个卷积层，对整个ImageNet Fall 2011发布版（15M图像，22K类别）进行分类，然后在ILSVRC-2012上对其进行“微调”，错误率为16.6%。对2011年秋季发布的两个CNN的预测值进行平均，这两个CNN在上述五个CNN中进行了预训练，其预测误差率为15.3%。第二名最佳竞赛条目的错误率为26.2%，其方法是将训练在基于不同类型密集采样特征的FVs上的几个分类器的预测平均化[7]。</p>
<p>最后，我们还报告了2009年秋季版本的ImageNet的错误率，该版本包含10184个类别和890万个图像。在这个数据集上，我们遵循文献中的惯例，使用一半的图像进行训练，另一半用于测试。由于没有已建立的测试集，我们的分割必然不同于先前作者使用的分割，但这不会对结果产生明显的影响。我们在这个数据集上的前1名和前5名的错误率分别为67.4%和40.9%，通过上述网络实现，但是在最后一个池层上有一个额外的第六个卷积层。在这个数据集上发表的最佳结果分别是78.1%和60.9%[19]。</p>
<h3 id="6-1定性评价"><a href="#6-1定性评价" class="headerlink" title="6.1定性评价"></a>6.1定性评价</h3><p>图3显示了由网络的两个数据连接层学习的卷积核。网络已经学习了各种频率和方向选择性核，以及各种颜色的斑点。 请注意这两个gpu所显示的专门化，这是第3.5节中描述的受限连接的结果。gpu1上的内核基本上是颜色不可知的，而gpu2上的内核主要是颜色特定的。这种专门化发生在每次运行期间，并且独立于任何特定的随机权重初始化（对gpu进行模化重新编号）。</p>
<p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure4.png" alt></p>
<p>图4：（左）8个ILSVRC-2010测试图像和我们模型认为最有可能的五个标签。正确的标签写在每个图像下面，并且分配给正确标签的概率也用红色条显示（如果它正好在前5位）。（右）第一列中的五幅ILSVRC-2010测试图像。剩下的列显示了六个训练图像，它们在最后一个隐藏层中生成特征向量，与测试图像的特征向量的欧几里德距离最小。</p>
<p>在图4的左侧面板中，我们通过计算8张测试图像的前5位预测，定性地评估了网络所学的知识。请注意，即使是偏离中心的对象，如左上角的斜接体，也可以被网络识别。前五名中的大多数似乎都是合理的。例如，只有其他种类的猫才被认为是豹的合理标签。在某些情况下（格栅，樱桃），有真正的含糊不清的预定焦点的照片。</p>
<p>探索网络视觉知识的另一种方法是考虑图像在最后4096维隐藏层引起的特征激活。如果两幅图像产生的特征激活向量具有很小的欧几里德分离，我们可以说，较高层次的神经网络认为他们是相似的。图4显示了来自测试集的五个图像和来自训练集的六个图像，这些图像与此度量中的每一个最相似。注意，在像素级别，检索到的训练图像在L2中通常与第一列中的查询图像不太接近。例如，被找回的狗和大象以各种姿势出现。我们在补充材料中展示了更多测试图像的结果。</p>
<p>利用两个4096维实值向量之间的欧几里德距离来计算相似性是低效的，但是通过训练nauto编码器将这些向量压缩成短的二进制代码，可以提高效率。这将产生比对原始像素应用自动编码器更好的图像检索方法[14]，后者不使用图像标签，因此倾向于检索具有相似边缘模式的图像，无论它们在语义上是否相似。</p>
<h2 id="7讨论"><a href="#7讨论" class="headerlink" title="7讨论"></a>7讨论</h2><p>我们的结果表明，一个大的，深卷积神经网络能够在一个高挑战性的数据集上使用纯监督学习获得破纪录的结果。值得注意的是，如果去掉单个卷积层，我们的网络性能会下降。例如，删除任何中间层都会导致网络的前1性能损失约2%。所以深度对我们的结果很重要。</p>
<p>为了简化我们的实验，我们没有使用任何无监督的预训练，即使我们期望它会有所帮助，特别是如果我们获得足够的计算能力来显著地增加网络的规模，而不获得相应增加的标记数据量。到目前为止，我们的结果已经有所改善，因为我们已经扩大了我们的网络并训练了它更长的时间，但我们仍然有许多数量级的工作要去匹配人类视觉系统的时间-时间路径。最后，我们希望在视频序列上使用非常大和很深的卷积网络，其中时间结构提供了非常有用的信息，而这些信息在静态图像中是缺失的或不太明显的。</p>
<h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] R.M. Bell and Y . Koren. Lessons from the netflixprizechallenge. ACM SIGKDD Explorations Newsletter,<br>9(2):75–79, 2007.<br>[2] A. Berg, J. Deng, and L. Fei-Fei.  Large scale visual recognition challenge 2010. www.image-<br>net.org/challenges. 2010.<br>[3] L. Breiman. Random forests. Machine learning, 45(1):5–32, 2001.<br>[4] D. Cire¸ san, U. Meier, and J. Schmidhuber. Multi-column deep neural networks for image classification.<br>Arxiv preprint arXiv:1202.2745, 2012.<br>[5] D.C. Cire¸ san, U. Meier, J. Masci, L.M. Gambardella, and J. Schmidhuber. High-performance neural<br>networks for visual object classification. Arxiv preprint arXiv:1102.0183, 2011.<br>[6] J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei-Fei. ImageNet: A Large-Scale Hierarchical<br>Image Database. In CVPR09, 2009.<br>[7] J. Deng, A. Berg, S. Satheesh, H. Su, A. Khosla, and L. Fei-Fei. ILSVRC-2012, 2012.  URL<br><a href="http://www.image-net.org/challenges/LSVRC/2012/" target="_blank" rel="noopener">http://www.image-net.org/challenges/LSVRC/2012/</a>.<br>[8] L. Fei-Fei, R. Fergus, and P . Perona. Learning generative visual models from few training examples: An<br>incremental bayesian approach tested on 101 object categories. Computer Vision and Image Understand-<br>ing, 106(1):59–70, 2007.<br>[9] G. Griffin, A. Holub, and P. Perona. Caltech-256 object category dataset. Technical Report 7694, Cali-<br>fornia Institute of Technology, 2007. URL <a href="http://authors.library.caltech.edu/7694" target="_blank" rel="noopener">http://authors.library.caltech.edu/7694</a>.<br>[10] G.E. Hinton, N. Srivastava, A. Krizhevsky, I. Sutskever, and R.R. Salakhutdinov. Improving neural net-<br>works by preventing co-adaptation of feature detectors. arXiv preprint arXiv:1207.0580, 2012.<br>[11] K. Jarrett, K. Kavukcuoglu, M. A. Ranzato, and Y . LeCun. What is the best multi-stage architecture for<br>object recognition? In International Conference on Computer Vision, pages 2146–2153. IEEE, 2009.<br>[12] A. Krizhevsky. Learning multiple layers of features from tiny images. Master’s thesis, Department of<br>Computer Science, University of Toronto, 2009.<br>[13] A. Krizhevsky. Convolutional deep belief networks on cifar-10. Unpublished manuscript, 2010.<br>[14] A. Krizhevsky and G.E. Hinton. Using very deep autoencoders for content-based image retrieval. In<br>ESANN, 2011.<br>[15] Y . Le Cun, B. Boser, J.S. Denker, D. Henderson, R.E. Howard, W. Hubbard, L.D. Jackel, et al. Hand-<br>written digit recognition with a back-propagation network. In Advances in neural information processing<br>systems, 1990.<br>[16] Y . LeCun, F.J. Huang, and L. Bottou. Learning methods for generic object recognition with invariance to<br>pose and lighting. In Computer Vision and Pattern Recognition, 2004. CVPR 2004. Proceedings of the<br>2004 IEEE Computer Society Conference on, volume 2, pages II–97. IEEE, 2004.<br>[17] Y . LeCun, K. Kavukcuoglu, and C. Farabet. Convolutional networks and applications in vision. In<br>Circuits and Systems (ISCAS), Proceedings of 2010 IEEE International Symposium on, pages 253–256.<br>IEEE, 2010.<br>[18] H. Lee, R. Grosse, R. Ranganath, and A.Y . Ng. Convolutional deep belief networks for scalable unsuper-<br>vised learning of hierarchical representations. InProceedings of the 26th Annual International Conference<br>on Machine Learning, pages 609–616. ACM, 2009.<br>[19] T. Mensink, J. V erbeek, F. Perronnin, and G. Csurka. Metric Learning for Large Scale Image Classifi-<br>cation: Generalizing to New Classes at Near-Zero Cost. In ECCV - European Conference on Computer<br>Vision, Florence, Italy, October 2012.<br>[20] V . Nair and G. E. Hinton. Rectified linear units improve restricted boltzmann machines. In Proc. 27th<br>International Conference on Machine Learning, 2010.<br>[21] N. Pinto, D.D. Cox, and J.J. DiCarlo. Why is real-world visual object recognition hard? PLoS computa-<br>tional biology, 4(1):e27, 2008.<br>[22] N. Pinto, D. Doukhan, J.J. DiCarlo, and D.D. Cox. A high-throughput screening approach to discovering<br>good forms of biologically inspired visual representation. PLoS computational biology, 5(11):e1000579,<br>2009.<br>[23] B.C. Russell, A. Torralba, K.P . Murphy, and W.T. Freeman. Labelme: a database and web-based tool for<br>image annotation. International journal of computer vision, 77(1):157–173, 2008.<br>[24] J. Sánchez and F. Perronnin. High-dimensional signature compression for large-scale image classification.<br>InComputer Vision and Pattern Recognition (CVPR), 2011 IEEE Conference on, pages 1665–1672. IEEE,<br>2011.<br>[25] P .Y . Simard, D. Steinkraus, and J.C. Platt. Best practices for convolutional neural networks applied to<br>visual document analysis. In Proceedings of the Seventh International Conference on Document Analysis<br>and Recognition, volume 2, pages 958–962, 2003.<br>[26] S.C. Turaga, J.F. Murray, V . Jain, F. Roth, M. Helmstaedter, K. Briggman, W. Denk, and H.S. Seung. Con-<br>volutional networks can learn to generate affinity graphs for image segmentation. Neural Computation,<br>22(2):511–538, 2010.</p>
<h1 id="我的总结"><a href="#我的总结" class="headerlink" title="我的总结"></a>我的总结</h1><ul>
<li>1.现实环境中的物体表现出相当大的可变性，需要大的数据集</li>
<li>2.需要大的数据集，为此需要学习能力很强的模型。</li>
<li>3.事实上数据集没法提供的无穷大，需要先验知识来弥补所没有的数据集</li>
<li>4.先验知识:卷积神经网络的容量可以通过改变深度和宽度来控制,还可以对图像的性质(即统计的平稳性和像素依赖的局部性)做出强有力的、基本正确的假设。</li>
<li>5.与具有相似层大小的标准前馈神经网络相比，cnn具有更少的连接和参数，因此更容易训练，而理论上最好的性能可能只会稍微差一点。</li>
<li>6.ImageNet的数据集里的图片分辨率不一样，需要将图像下采样到固定分辨率为256×256,因为系统需要一个恒定的输入维数</li>
<li>7.Rectified Linear Units简称ReLUs比sigmoid快好几倍</li>
<li>8.因为一个GTX 580 GPU只有3GB的内存,所以用两个GPU来并行计算,用两个GPU直接读写彼此的内存，而不需要通过主机内存。</li>
<li>9.双gpu网络的训练时间略少于单gpu网络(在一个GPU上训练每个卷积层内核数量减半的网络),因为使这两个网络具有大致相同数量的参数，我们没有将最后的卷积层(也没有将后面的完全连接层)的大小减半。</li>
<li>10.局部相应归一化</li>
<li>11.重叠池化层</li>
<li>12.数据增强(1图像平移水平翻转,2通道增强)</li>
</ul>

      
    </div>
    
    
    

    

    
      <div>
        <div style="padding: 10px 0; margin: 20px auto; width: 90%; text-align: center;">
  <div>坚持原创技术分享，您的支持将鼓励我继续创作！</div>
  <button id="rewardButton" disable="enable" onclick="var qr = document.getElementById('QR'); if (qr.style.display === 'none') {qr.style.display='block';} else {qr.style.display='none'}">
    <span>Donate</span>
  </button>
  <div id="QR" style="display: none;">

    
      <div id="wechat" style="display: inline-block">
        <img id="wechat_qr" src="/uploads/weixin.png" alt="Zhangshuai WeChat Pay"/>
        <p>WeChat Pay</p>
      </div>
    

    
      <div id="alipay" style="display: inline-block">
        <img id="alipay_qr" src="/uploads/zhifubao.jpg" alt="Zhangshuai Alipay"/>
        <p>Alipay</p>
      </div>
    

    

  </div>
</div>

      </div>
    

    

    <footer class="post-footer">
      
        <div class="post-tags">
          
            <a href="/tags/%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B%E8%AE%BA%E6%96%87/" rel="tag"># 卷积经典模型论文</a>
          
            <a href="/tags/%E7%BF%BB%E8%AF%91/" rel="tag"># 翻译</a>
          
        </div>
      

      
      
      

      
        <div class="post-nav">
          <div class="post-nav-next post-nav-item">
            
              <a href="/2020/07/29/CS231N/" rel="next" title="CS231N">
                <i class="fa fa-chevron-left"></i> CS231N
              </a>
            
          </div>

          <span class="post-nav-divider"></span>

          <div class="post-nav-prev post-nav-item">
            
              <a href="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/" rel="prev" title="CS231N翻译版">
                CS231N翻译版 <i class="fa fa-chevron-right"></i>
              </a>
            
          </div>
        </div>
      

      
      
    </footer>
  </div>
  
  
  
  </article>



    <div class="post-spread">
      
    </div>
  </div>


          </div>
          


          

  



        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      
        <ul class="sidebar-nav motion-element">
          <li class="sidebar-nav-toc sidebar-nav-active" data-target="post-toc-wrap">
            Table of Contents
          </li>
          <li class="sidebar-nav-overview" data-target="site-overview-wrap">
            Overview
          </li>
        </ul>
      

      <section class="site-overview-wrap sidebar-panel">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/uploads/avatar2.jpg"
                alt="Zhangshuai" />
            
              <p class="site-author-name" itemprop="name">Zhangshuai</p>
              <p class="site-description motion-element" itemprop="description">你刚才说了JOJO对吧</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives/%7C%7Carchive">
              
                  <span class="site-state-item-count">71</span>
                  <span class="site-state-item-name">posts</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                <a href="/categories/index.html">
                  <span class="site-state-item-count">8</span>
                  <span class="site-state-item-name">categories</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                <a href="/tags/index.html">
                  <span class="site-state-item-count">35</span>
                  <span class="site-state-item-name">tags</span>
                </a>
              </div>
            

          </nav>
<iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=86 src="//music.163.com/outchain/player?type=2&id=486194129&auto=1&height=66"></iframe>
          
            <div class="feed-link motion-element">
              <a href="/atom.xml" rel="alternate">
                <i class="fa fa-rss"></i>
                RSS
              </a>
            </div>
          

          
            <div class="links-of-author motion-element">
                
                  <span class="links-of-author-item">
                    <a href="https://github.com/GitHubzhangshuai" target="_blank" title="GitHub">
                      
                        <i class="fa fa-fw fa-github"></i>GitHub</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="1802528291@qq.com" target="_blank" title="E-Mail">
                      
                        <i class="fa fa-fw fa-envelope"></i>E-Mail</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://www.zhihu.com/people/ying-ying-ying-vue" target="_blank" title="知乎">
                      
                        <i class="fa fa-fw fa-globe"></i>知乎</a>
                  </span>
                
                  <span class="links-of-author-item">
                    <a href="https://music.163.com/#/user/home?id=377737250" target="_blank" title="网易云音乐">
                      
                        <i class="fa fa-fw fa-globe"></i>网易云音乐</a>
                  </span>
                
            </div>
          

          
          
            <div class="cc-license motion-element" itemprop="license">
              <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" class="cc-opacity" target="_blank">
                <img src="/images/cc-by-nc-sa.svg" alt="Creative Commons" />
              </a>
            </div>
          

          
          

          

        </div>
      </section>


      
      <!--noindex-->
        <section class="post-toc-wrap motion-element sidebar-panel sidebar-panel-active">
          <div class="post-toc">

            
              
            

            
              <div class="post-toc-content"><ol class="nav"><li class="nav-item nav-level-1"><a class="nav-link" href="#原文"><span class="nav-number">1.</span> <span class="nav-text">原文</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#Abstract"><span class="nav-number">1.1.</span> <span class="nav-text">Abstract</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-Introduction"><span class="nav-number">1.2.</span> <span class="nav-text">1.Introduction</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-The-Dataset"><span class="nav-number">1.3.</span> <span class="nav-text">2.The Dataset</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-The-Architecture"><span class="nav-number">1.4.</span> <span class="nav-text">3.The Architecture</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-ReLU-Nonlinearity"><span class="nav-number">1.4.1.</span> <span class="nav-text">3.1 ReLU Nonlinearity</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-Training-on-Multiple-GPUs"><span class="nav-number">1.4.2.</span> <span class="nav-text">3.2 Training on Multiple GPUs</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3-Local-Response-Normalization"><span class="nav-number">1.4.3.</span> <span class="nav-text">3.3 Local Response Normalization</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4Overlapping-Pooling"><span class="nav-number">1.4.4.</span> <span class="nav-text">3.4Overlapping Pooling</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5-Overall-Architecture"><span class="nav-number">1.4.5.</span> <span class="nav-text">3.5 Overall Architecture</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-Reducing-Overfitting"><span class="nav-number">1.5.</span> <span class="nav-text">4 Reducing Overfitting</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-1-Data-Augmentation"><span class="nav-number">1.5.1.</span> <span class="nav-text">4.1 Data Augmentation</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Dropout"><span class="nav-number">1.5.2.</span> <span class="nav-text">4.2 Dropout</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-Details-of-learning"><span class="nav-number">1.6.</span> <span class="nav-text">5 Details of learning</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Results"><span class="nav-number">1.7.</span> <span class="nav-text">6 Results</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1-Qualitative-Evaluations"><span class="nav-number">1.7.1.</span> <span class="nav-text">6.1 Qualitative Evaluations</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7-Discussion"><span class="nav-number">1.8.</span> <span class="nav-text">7 Discussion</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#References"><span class="nav-number">1.9.</span> <span class="nav-text">References</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#翻译"><span class="nav-number">2.</span> <span class="nav-text">翻译</span></a><ol class="nav-child"><li class="nav-item nav-level-2"><a class="nav-link" href="#摘要"><span class="nav-number">2.1.</span> <span class="nav-text">摘要</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#1-介绍"><span class="nav-number">2.2.</span> <span class="nav-text">1.介绍</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#2-数据集"><span class="nav-number">2.3.</span> <span class="nav-text">2.数据集</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#3-体系结构"><span class="nav-number">2.4.</span> <span class="nav-text">3.体系结构</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#3-1-非线性的ReLU"><span class="nav-number">2.4.1.</span> <span class="nav-text">3.1 非线性的ReLU</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-2-在多GPU上的训练"><span class="nav-number">2.4.2.</span> <span class="nav-text">3.2 在多GPU上的训练</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-3局部响应归一化"><span class="nav-number">2.4.3.</span> <span class="nav-text">3.3局部响应归一化</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-4-重叠池化层"><span class="nav-number">2.4.4.</span> <span class="nav-text">3.4 重叠池化层</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#3-5总体架构"><span class="nav-number">2.4.5.</span> <span class="nav-text">3.5总体架构</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#4-减少过拟合"><span class="nav-number">2.5.</span> <span class="nav-text">4.减少过拟合</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#4-2-Dropout-1"><span class="nav-number">2.5.1.</span> <span class="nav-text">4.2 Dropout</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#5-学习细节"><span class="nav-number">2.6.</span> <span class="nav-text">5.学习细节</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#6-Results-1"><span class="nav-number">2.7.</span> <span class="nav-text">6 Results</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#6-1定性评价"><span class="nav-number">2.7.1.</span> <span class="nav-text">6.1定性评价</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#7讨论"><span class="nav-number">2.8.</span> <span class="nav-text">7讨论</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#引用"><span class="nav-number">2.9.</span> <span class="nav-text">引用</span></a></li></ol></li><li class="nav-item nav-level-1"><a class="nav-link" href="#我的总结"><span class="nav-number">3.</span> <span class="nav-text">我的总结</span></a></li></ol></div>
            

          </div>
        </section>
      <!--/noindex-->
      
      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <script type="text/javascript" src="/js/src/busuanzi.js"></script>


<div class="copyright">&copy; <span itemprop="copyrightYear">2020</span>
  <span class="with-love">
    <i class="fa fa-[object Object]"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">张帅</span>

  
</div>


  <div class="powered-by">Powered by <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>









  <span id="busuanzi_container_site_pv">总访问量<span id="busuanzi_value_site_pv"></span>次</span>
  <span class="post-meta-divider">|</span>
  <span id="busuanzi_container_site_uv">总访客数<span id="busuanzi_value_site_uv"></span>人</span>


<script>
setTimeout(function(){
document.getElementById('busuanzi_container_site_pv').style.display='inline-block'
document.getElementById('busuanzi_container_site_uv').style.display='inline-block'
},1000)
</script>
        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  


  











  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  

  
  
    <script type="text/javascript" src="/lib/canvas-nest/canvas-nest.min.js"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  
  <script type="text/javascript" src="/js/src/scrollspy.js?v=5.1.4"></script>
<script type="text/javascript" src="/js/src/post-details.js?v=5.1.4"></script>



  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  




	





  





  












  

  <script type="text/javascript">
    // Popup Window;
    var isfetched = false;
    var isXml = true;
    // Search DB path;
    var search_path = "search.xml";
    if (search_path.length === 0) {
      search_path = "search.xml";
    } else if (/json$/i.test(search_path)) {
      isXml = false;
    }
    var path = "/" + search_path;
    // monitor main search box;

    var onPopupClose = function (e) {
      $('.popup').hide();
      $('#local-search-input').val('');
      $('.search-result-list').remove();
      $('#no-result').remove();
      $(".local-search-pop-overlay").remove();
      $('body').css('overflow', '');
    }

    function proceedsearch() {
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay"></div>')
        .css('overflow', 'hidden');
      $('.search-popup-overlay').click(onPopupClose);
      $('.popup').toggle();
      var $localSearchInput = $('#local-search-input');
      $localSearchInput.attr("autocapitalize", "none");
      $localSearchInput.attr("autocorrect", "off");
      $localSearchInput.focus();
    }

    // search function;
    var searchFunc = function(path, search_id, content_id) {
      'use strict';

      // start loading animation
      $("body")
        .append('<div class="search-popup-overlay local-search-pop-overlay">' +
          '<div id="search-loading-icon">' +
          '<i class="fa fa-spinner fa-pulse fa-5x fa-fw"></i>' +
          '</div>' +
          '</div>')
        .css('overflow', 'hidden');
      $("#search-loading-icon").css('margin', '20% auto 0 auto').css('text-align', 'center');

      $.ajax({
        url: path,
        dataType: isXml ? "xml" : "json",
        async: true,
        success: function(res) {
          // get the contents from search data
          isfetched = true;
          $('.popup').detach().appendTo('.header-inner');
          var datas = isXml ? $("entry", res).map(function() {
            return {
              title: $("title", this).text(),
              content: $("content",this).text(),
              url: $("url" , this).text()
            };
          }).get() : res;
          var input = document.getElementById(search_id);
          var resultContent = document.getElementById(content_id);
          var inputEventFunction = function() {
            var searchText = input.value.trim().toLowerCase();
            var keywords = searchText.split(/[\s\-]+/);
            if (keywords.length > 1) {
              keywords.push(searchText);
            }
            var resultItems = [];
            if (searchText.length > 0) {
              // perform local searching
              datas.forEach(function(data) {
                var isMatch = false;
                var hitCount = 0;
                var searchTextCount = 0;
                var title = data.title.trim();
                var titleInLowerCase = title.toLowerCase();
                var content = data.content.trim().replace(/<[^>]+>/g,"");
                var contentInLowerCase = content.toLowerCase();
                var articleUrl = decodeURIComponent(data.url);
                var indexOfTitle = [];
                var indexOfContent = [];
                // only match articles with not empty titles
                if(title != '') {
                  keywords.forEach(function(keyword) {
                    function getIndexByWord(word, text, caseSensitive) {
                      var wordLen = word.length;
                      if (wordLen === 0) {
                        return [];
                      }
                      var startPosition = 0, position = [], index = [];
                      if (!caseSensitive) {
                        text = text.toLowerCase();
                        word = word.toLowerCase();
                      }
                      while ((position = text.indexOf(word, startPosition)) > -1) {
                        index.push({position: position, word: word});
                        startPosition = position + wordLen;
                      }
                      return index;
                    }

                    indexOfTitle = indexOfTitle.concat(getIndexByWord(keyword, titleInLowerCase, false));
                    indexOfContent = indexOfContent.concat(getIndexByWord(keyword, contentInLowerCase, false));
                  });
                  if (indexOfTitle.length > 0 || indexOfContent.length > 0) {
                    isMatch = true;
                    hitCount = indexOfTitle.length + indexOfContent.length;
                  }
                }

                // show search results

                if (isMatch) {
                  // sort index by position of keyword

                  [indexOfTitle, indexOfContent].forEach(function (index) {
                    index.sort(function (itemLeft, itemRight) {
                      if (itemRight.position !== itemLeft.position) {
                        return itemRight.position - itemLeft.position;
                      } else {
                        return itemLeft.word.length - itemRight.word.length;
                      }
                    });
                  });

                  // merge hits into slices

                  function mergeIntoSlice(text, start, end, index) {
                    var item = index[index.length - 1];
                    var position = item.position;
                    var word = item.word;
                    var hits = [];
                    var searchTextCountInSlice = 0;
                    while (position + word.length <= end && index.length != 0) {
                      if (word === searchText) {
                        searchTextCountInSlice++;
                      }
                      hits.push({position: position, length: word.length});
                      var wordEnd = position + word.length;

                      // move to next position of hit

                      index.pop();
                      while (index.length != 0) {
                        item = index[index.length - 1];
                        position = item.position;
                        word = item.word;
                        if (wordEnd > position) {
                          index.pop();
                        } else {
                          break;
                        }
                      }
                    }
                    searchTextCount += searchTextCountInSlice;
                    return {
                      hits: hits,
                      start: start,
                      end: end,
                      searchTextCount: searchTextCountInSlice
                    };
                  }

                  var slicesOfTitle = [];
                  if (indexOfTitle.length != 0) {
                    slicesOfTitle.push(mergeIntoSlice(title, 0, title.length, indexOfTitle));
                  }

                  var slicesOfContent = [];
                  while (indexOfContent.length != 0) {
                    var item = indexOfContent[indexOfContent.length - 1];
                    var position = item.position;
                    var word = item.word;
                    // cut out 100 characters
                    var start = position - 20;
                    var end = position + 80;
                    if(start < 0){
                      start = 0;
                    }
                    if (end < position + word.length) {
                      end = position + word.length;
                    }
                    if(end > content.length){
                      end = content.length;
                    }
                    slicesOfContent.push(mergeIntoSlice(content, start, end, indexOfContent));
                  }

                  // sort slices in content by search text's count and hits' count

                  slicesOfContent.sort(function (sliceLeft, sliceRight) {
                    if (sliceLeft.searchTextCount !== sliceRight.searchTextCount) {
                      return sliceRight.searchTextCount - sliceLeft.searchTextCount;
                    } else if (sliceLeft.hits.length !== sliceRight.hits.length) {
                      return sliceRight.hits.length - sliceLeft.hits.length;
                    } else {
                      return sliceLeft.start - sliceRight.start;
                    }
                  });

                  // select top N slices in content

                  var upperBound = parseInt('1');
                  if (upperBound >= 0) {
                    slicesOfContent = slicesOfContent.slice(0, upperBound);
                  }

                  // highlight title and content

                  function highlightKeyword(text, slice) {
                    var result = '';
                    var prevEnd = slice.start;
                    slice.hits.forEach(function (hit) {
                      result += text.substring(prevEnd, hit.position);
                      var end = hit.position + hit.length;
                      result += '<b class="search-keyword">' + text.substring(hit.position, end) + '</b>';
                      prevEnd = end;
                    });
                    result += text.substring(prevEnd, slice.end);
                    return result;
                  }

                  var resultItem = '';

                  if (slicesOfTitle.length != 0) {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + highlightKeyword(title, slicesOfTitle[0]) + "</a>";
                  } else {
                    resultItem += "<li><a href='" + articleUrl + "' class='search-result-title'>" + title + "</a>";
                  }

                  slicesOfContent.forEach(function (slice) {
                    resultItem += "<a href='" + articleUrl + "'>" +
                      "<p class=\"search-result\">" + highlightKeyword(content, slice) +
                      "...</p>" + "</a>";
                  });

                  resultItem += "</li>";
                  resultItems.push({
                    item: resultItem,
                    searchTextCount: searchTextCount,
                    hitCount: hitCount,
                    id: resultItems.length
                  });
                }
              })
            };
            if (keywords.length === 1 && keywords[0] === "") {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-search fa-5x" /></div>'
            } else if (resultItems.length === 0) {
              resultContent.innerHTML = '<div id="no-result"><i class="fa fa-frown-o fa-5x" /></div>'
            } else {
              resultItems.sort(function (resultLeft, resultRight) {
                if (resultLeft.searchTextCount !== resultRight.searchTextCount) {
                  return resultRight.searchTextCount - resultLeft.searchTextCount;
                } else if (resultLeft.hitCount !== resultRight.hitCount) {
                  return resultRight.hitCount - resultLeft.hitCount;
                } else {
                  return resultRight.id - resultLeft.id;
                }
              });
              var searchResultList = '<ul class=\"search-result-list\">';
              resultItems.forEach(function (result) {
                searchResultList += result.item;
              })
              searchResultList += "</ul>";
              resultContent.innerHTML = searchResultList;
            }
          }

          if ('auto' === 'auto') {
            input.addEventListener('input', inputEventFunction);
          } else {
            $('.search-icon').click(inputEventFunction);
            input.addEventListener('keypress', function (event) {
              if (event.keyCode === 13) {
                inputEventFunction();
              }
            });
          }

          // remove loading animation
          $(".local-search-pop-overlay").remove();
          $('body').css('overflow', '');

          proceedsearch();
        }
      });
    }

    // handle and trigger popup window;
    $('.popup-trigger').click(function(e) {
      e.stopPropagation();
      if (isfetched === false) {
        searchFunc(path, 'local-search-input', 'local-search-result');
      } else {
        proceedsearch();
      };
    });

    $('.popup-btn-close').click(onPopupClose);
    $('.popup').click(function(e){
      e.stopPropagation();
    });
    $(document).on('keyup', function (event) {
      var shouldDismissSearchPopup = event.which === 27 &&
        $('.search-popup').is(':visible');
      if (shouldDismissSearchPopup) {
        onPopupClose();
      }
    });
  </script>





  

  

  

  
  

  
  
    <script type="text/x-mathjax-config">
      MathJax.Hub.Config({
        tex2jax: {
          inlineMath: [ ['$','$'], ["\\(","\\)"]  ],
          processEscapes: true,
          skipTags: ['script', 'noscript', 'style', 'textarea', 'pre', 'code']
        }
      });
    </script>

    <script type="text/x-mathjax-config">
      MathJax.Hub.Queue(function() {
        var all = MathJax.Hub.getAllJax(), i;
        for (i=0; i < all.length; i += 1) {
          all[i].SourceElement().parentNode.className += ' has-jax';
        }
      });
    </script>
    <script type="text/javascript" src="//cdn.bootcss.com/mathjax/2.7.1/latest.js?config=TeX-AMS-MML_HTMLorMML"></script>
  


  

  


  <!-- 页面点击小红心 -->


   <canvas class="fireworks" style="position: fixed;left: 0;top: 0;z-index: 1; pointer-events: none;" ></canvas> 
   <script type="text/javascript" src="//cdn.bootcss.com/animejs/2.2.0/anime.min.js"></script> 
   <script type="text/javascript" src="/js/src/fireworks.js"></script>


<script src="/live2dw/lib/L2Dwidget.min.js?094cbace49a39548bed64abff5988b05"></script><script>L2Dwidget.init({"pluginRootPath":"live2dw/","pluginJsPath":"lib/","pluginModelPath":"assets/","tagMode":false,"model":{"jsonPath":"/live2dw/assets/wanko.model.json"},"display":{"position":"right","width":150,"height":300},"mobile":{"show":false},"log":false});</script><!-- hexo-inject:begin --><!-- hexo-inject:end --></body>
</html>
