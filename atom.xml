<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>张帅的Blog</title>
  
  <subtitle>用hexo搭建的简易博客</subtitle>
  <link href="/atom.xml" rel="self"/>
  
  <link href="http://yoursite.com/"/>
  <updated>2020-08-05T16:34:15.231Z</updated>
  <id>http://yoursite.com/</id>
  
  <author>
    <name>Zhangshuai</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>CS231N翻译版</title>
    <link href="http://yoursite.com/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/"/>
    <id>http://yoursite.com/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/</id>
    <published>2020-08-03T06:52:06.000Z</published>
    <updated>2020-08-05T16:34:15.231Z</updated>
    
    <content type="html"><![CDATA[<p>斯坦福大学深度学习课程笔记翻译版<br><a id="more"></a><br><a href="https://githubzhangshuai.github.io/2020/07/29/CS231N/#more" target="_blank" rel="noopener">英文版</a></p><h1 id="Standford-CS231n-2017-Summary"><a href="#Standford-CS231n-2017-Summary" class="headerlink" title="Standford CS231n 2017 Summary"></a>Standford CS231n 2017 Summary</h1><p>在观看了2017年著名的斯坦福<a href="http://cs231n.stanford.edu/" target="_blank" rel="noopener">CS231n</a>课程的所有视频后，我决定对整个课程进行总结，以帮助我记住并向任何想知道它的人。有些课我跳过了一些内容，因为这对我来说并不重要。</p><h2 id="目录"><a href="#目录" class="headerlink" title="目录"></a>目录</h2><ul><li><a href="#standford-cs231n-2017-summary">Standford CS231n 2017 Summary</a><ul><li><a href="#目录">目录</a></li><li><a href="#课程信息">课程信息</a></li><li><a href="#01-introduction-to-cnn-for-visual-recognition">01. CNN视觉识别简介</a></li><li><a href="#02-image-classification">02. 图像分类</a></li><li><a href="#03-loss-function-and-optimization">03. 损失函数与最优化</a></li><li><a href="#04-introduction-to-neural-network">04. 神经网络概论</a></li><li><a href="#05-convolutional-neural-networks-cnns">05. 卷积神经网络</a></li><li><a href="#06-training-neural-networks-i">06. 神经网络训练I</a></li><li><a href="#07-training-neural-networks-ii">07. 训练神经网络2</a></li><li><a href="#08-deep-learning-software">08. 深度学习软件</a></li><li><a href="#09-cnn-architectures">09. CNN架构</a></li><li><a href="#10-recurrent-neural-networks">10. 循环神经网络</a></li><li><a href="#11-detection-and-segmentation">11. 检测与分割</a></li><li><a href="#12-visualizing-and-understanding">12. 形象化和理解</a></li><li><a href="#13-generative-models">13. 生成模型</a></li><li><a href="#14-deep-reinforcement-learning">14. 深度强化学习</a></li><li><a href="#15-efficient-methods-and-hardware-for-deep-learning">15. 有效的深度学习方法和硬件</a></li><li><a href="#16-adversarial-examples-and-adversarial-training">16. 对抗性范例与对抗性训练</a></li></ul></li></ul><h2 id="课程信息"><a href="#课程信息" class="headerlink" title="课程信息"></a>课程信息</h2><ul><li><p>网站: <a href="http://cs231n.stanford.edu/" target="_blank" rel="noopener">http://cs231n.stanford.edu/</a></p></li><li><p>讲座链接: <a href="https://www.youtube.com/playlist?list=PLC1qU-LWwrF64f4QKQT-Vg5Wr4qEE1Zxk" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLC1qU-LWwrF64f4QKQT-Vg5Wr4qEE1Zxk</a></p></li><li><p>完整教学大纲链接: <a href="http://cs231n.stanford.edu/syllabus.html" target="_blank" rel="noopener">http://cs231n.stanford.edu/syllabus.html</a></p></li><li><p>作业解决方案: <a href="https://github.com/Burton2000/CS231n-2017" target="_blank" rel="noopener">https://github.com/Burton2000/CS231n-2017</a></p></li><li><p>讲座次数: <strong>16</strong></p></li><li><p>课程描述:</p><ul><li><blockquote><p>计算机视觉在我们的社会中已经变得无处不在，在搜索、图像理解、应用程序、地图、医学、无人机和自动驾驶汽车等领域都有应用。这些应用的核心是视觉识别任务，如图像分类、定位和检测。神经网络（又名“深度学习”）方法的最新发展极大地提高了这些最先进的视觉识别系统的性能。本课程深入研究深度学习架构的细节，重点学习这些任务的端到端模型，特别是图像分类。在为期10周的课程中，学生们将学习如何实现、训练和调试自己的神经网络，并详细了解计算机视觉领域的前沿研究。最后的任务是训练一个数百万参数的卷积神经网络，并将其应用于最大的图像分类数据集（ImageNet）。我们将重点教授如何设置图像识别问题、学习算法（如反向传播）、训练和微调网络的实用工程技巧，并指导学生通过实际作业和最终课程项目。本课程的大部分背景和材料都将来自<a href="http://image-net.org/challenges/LSVRC/2014/index" target="_blank" rel="noopener">ImageNet挑战赛</a>。</p></blockquote></li></ul></li></ul><h2 id="01-Introduction-to-CNN-for-visual-recognition"><a href="#01-Introduction-to-CNN-for-visual-recognition" class="headerlink" title="01. Introduction to CNN for visual recognition"></a>01. Introduction to CNN for visual recognition</h2><ul><li>20世纪60年代末至2017年计算机视觉发展简史</li><li>计算机视觉问题包括图像分类、目标定位、目标检测和场景理解。</li><li><a href="http://www.image-net.org/" target="_blank" rel="noopener">Imagenet</a> 是目前可用的最大的图像分类数据集之一</li><li>从2012年的Imagenet竞赛开始，CNN（卷积神经网络）总是胜出</li><li>CNN实际上是由<a href="http://ieeexplore.ieee.org/document/726791/" target="_blank" rel="noopener">Yann Lecun</a>在1997年发明的 .</li></ul><h2 id="02-Image-classification"><a href="#02-Image-classification" class="headerlink" title="02. Image classification"></a>02. Image classification</h2><ul><li>图像分类问题有很多挑战，比如光照和视角<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/39.jpeg" alt></li></ul></li><li>一种图像分类算法可以用<strong>K近邻</strong>(KNN)来解决，但它不能很好地解决这个问题。KNN的性质是:<ul><li>KNN的超参数是：k和距离测度</li><li>K是我们正在比较的邻居结点的数目。</li><li>距离测量包括:<ul><li>L2距离（欧几里得距离）<ul><li>最适合非坐标点</li></ul></li><li>L1距离（曼哈顿距离）<ul><li>最适合坐标点</li></ul></li></ul></li></ul></li><li>超参数可以使用交叉验证进行优化，如下所示（在我们的例子中，我们尝试tp predict K）:<ol><li>把数据集分成k份</li><li>给定预测超参数：<ul><li>先找出f-1份训练你的算法，用剩余的1份来测试它。对每份都要重复这个动作。</li></ul></li><li>选择提供最佳训练值的超参数（所有份数的平均值）</li></ol></li><li><strong>线性支持向量机</strong>分类器是解决图像分类问题的一种选择，但维数灾难使其在某些情况下停止了改进</li><li><strong>逻辑回归</strong>也是解决图像分类问题的一种方法，但图像分类问题是非线性的</li><li>线性分类器必须遵从以下等式: <code>Y = wX + b</code> <ul><li>w的形状与x相同，b的形状为1。</li></ul></li><li>我们可以在X向量上加1，去掉偏差，像这样: <code>Y = wX</code><ul><li>x的形状是旧的x+1的形状，w与x相同</li></ul></li><li>我们需要知道如何得到w和b，使分类器运行得最好。</li></ul><h2 id="03-Loss-function-and-optimization"><a href="#03-Loss-function-and-optimization" class="headerlink" title="03. Loss function and optimization"></a>03. Loss function and optimization</h2><ul><li><p>在最后一节中，我们讨论了线性分类器，但是我们没有讨论如何训练模型的参数以获得最佳的w和b。</p></li><li><p>我们需要一个损失函数来衡量我们当前参数的好坏。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loss = L[i] =(f(X[i],W),Y[i])</span><br><span class="line">Loss_for_all = <span class="number">1</span>/N * Sum(Li(f(X[i],W),Y[i]))      <span class="comment">#表示平均值</span></span><br></pre></td></tr></table></figure></li><li><p>然后在给定参数的情况下，找到了一种最小化损失函数的方法。这叫做<strong>优化</strong>.</p></li><li><p>线性支持<strong>向量机</strong>分类器的损失函数:</p><ul><li><code>L[i] = 除预测类外的所有类的和 (max(0, s[j] - s[y[i]] + 1))</code></li><li>我们叫它 <strong><em>the hinge loss</em></strong>.</li><li>损失函数意味着，如果最佳预测值与真实值相同，则我们很高兴；反之，我们给出的误差为1。</li><li>例子:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/40.jpg" alt></li><li>在这个例子中，我们要计算这个图像的损失。</li><li><code>L = max (0, 437.9 - (-96.8) + 1) + max(0, 61.95 - (-96.8) + 1) = max(0, 535.7) + max(0, 159.75) = 695.45</code></li><li>最后的损失是695.45分，这是一个很大的数字，反映出猫的分数需要是最好的所有类别，作为它的最低值现在。 我们需要把损失降到最低。</li></ul></li><li>边距为1是可以的。但它也是一个超参数。</li></ul></li><li><p>如果你的损失函数为零，这个值和你的参数值一样吗？不，有很多参数可以给你最好的分数。</p></li><li><p>你有时会听到人们用<strong>the squared hinge loss SVM</strong>(or <strong>L2-SVM</strong>)来代替. 这对违规利润的惩罚力度更大（二次方而不是线性）。 无平方的版本更为标准，但在某些数据集中，<strong>the squared hinge loss</strong>可以更好地工作。</p></li><li><p>我们对损失函数进行了<strong>正则化</strong>处理，这样发现的模型不会过度拟合数据。</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Loss = L = <span class="number">1</span>/N * Sum(Li(f(X[i],W),Y[i])) + <span class="keyword">lambda</span> * R(W)</span><br></pre></td></tr></table></figure><ul><li>其中<code>R</code>是正则化子，<code>lambda</code>是正则化项</li></ul></li><li><p>有不同的正则化技术:</p></li></ul><div class="table-container"><table><thead><tr><th>正则化矩阵</th><th>等式</th><th>注释</th></tr></thead><tbody><tr><td>L2</td><td><code>R(W) = Sum(W^2)</code></td><td>所有W的平方和</td></tr><tr><td>L1</td><td><code>R(W) = Sum(lWl)</code></td><td>所有W的绝对值之和</td></tr><tr><td>Elastic net (L1 + L2)</td><td><code>R(W) = beta * Sum(W^2) + Sum(lWl)</code></td><td></td></tr><tr><td>Dropout</td><td></td><td>没有等式</td></tr></tbody></table></div><ul><li><p>正则化倾向于较小的<code>W</code> s而不是大的<code>W</code> s。</p></li><li><p>正则化称为权重衰减。偏置不应包括在正规化中。</p></li><li><p>Softmax损失（类似线性回归，但适用于2个以上类别）：</p><ul><li><p>Softmax function:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[L] = e^(score[L]) / sum(e^(score[L]), NoOfClasses)</span><br></pre></td></tr></table></figure></li><li><p>矢量和应为1</p></li><li><p>Softmax loss:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Loss = -logP(Y = y[i]|X = x[i])</span><br></pre></td></tr></table></figure><ul><li><p>好类比的概率的log值。我们希望它接近1，所以我们加了个负数。</p></li><li><p>Softmax损失称为交叉熵损失。</p></li></ul></li><li><p>在计算Softmax时，请考虑这个数值问题:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 3个分类的示例，每个分类都有很高的分数</span></span><br><span class="line">f = np.array([<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]) </span><br><span class="line"><span class="comment"># 坏：数字问题，潜在爆炸</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># instead: 首先将f的值移位，以使最大数为0：</span></span><br><span class="line">f -= np.max(f) <span class="comment"># f becomes [-666, -333, 0]</span></span><br><span class="line"><span class="comment"># safe to do, gives the correct answer</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f))</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>最优化</strong>:</p><ul><li>如何优化我们讨论过的损失函数?</li><li>策略一:<ul><li>给定一个随机参数，并尝试所有的损失，得到最佳的损失。但这是个坏主意。</li></ul></li><li><p>策略二:</p><ul><li><p>沿着斜坡走。</p><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/41.png" alt></li><li>Image <a href="https://rasbt.github.io/mlxtend/user_guide/general_concepts/gradient-optimization_files/ball.png" target="_blank" rel="noopener">source</a>.</li></ul></li><li><p>我们的目标是计算每个参数的梯度。</p><ul><li><strong>数值梯度</strong>: 近似，缓慢，易于书写。（但它在调试中很有用。）</li><li><strong>解析梯度</strong>: 准确、快速、容易出错。（实践中经常使用）</li></ul></li><li><p>计算参数梯度后，计算梯度下降:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W = W - learning_rate * W_grad</span><br></pre></td></tr></table></figure></li><li><p>学习速率是一个非常重要的超参数，在所有的超参数中，首先要得到它的最佳值。</p></li><li><p>随机梯度下降:</p><ul><li>不要使用所有的数据，而是使用小批量的示例（通常使用32/64/128）来获得更快的结果。</li></ul></li></ul></li></ul></li></ul><h2 id="04-Introduction-to-Neural-network"><a href="#04-Introduction-to-Neural-network" class="headerlink" title="04. Introduction to Neural network"></a>04. Introduction to Neural network</h2><ul><li><p>计算任意复函数的解析梯度:</p><ul><li><p>什么是计算图?</p><ul><li>用节点来表示任何函数</li><li>使用计算图可以很容易地引导我们使用一种称为反向传播的技术。即使是像CNN和RNN这样的复杂模型。</li></ul></li><li><p>反向传播简单示例:</p><ul><li><p>假设我们有 <code>f(x,y,z) = (x+y)z</code></p></li><li><p>然后计算图可以被这种方式表示:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X         </span><br><span class="line">  \</span><br><span class="line">   (+)--&gt; q ---(*)--&gt; f</span><br><span class="line">  &#x2F;           &#x2F;</span><br><span class="line">Y            &#x2F;</span><br><span class="line">            &#x2F;</span><br><span class="line">           &#x2F;</span><br><span class="line">Z---------&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>我们制作了一个中间变量<code>q</code>来保存<code>x+y</code>的值</p></li><li><p>然后我们有:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q = (x+y)              <span class="comment"># dq/dx = 1 , dq/dy = 1</span></span><br><span class="line">f = qz                 <span class="comment"># df/dq = z , df/dz = q</span></span><br></pre></td></tr></table></figure></li><li><p>然后:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df/dq = z</span><br><span class="line">df/dz = q</span><br><span class="line">df/dx = df/dq * dq/dx = z * <span class="number">1</span> = z       <span class="comment"># Chain rule</span></span><br><span class="line">df/dy = df/dq * dq/dy = z * <span class="number">1</span> = z       <span class="comment"># Chain rule</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>所以在计算图中，我们称每个运算为 <code>f</code>。 对于每一个<code>f</code>，我们在进行反向传播之前计算局部梯度，然后使用链式法则计算关于损失函数的梯度。</p></li><li><p>在计算图中，你可以将每个操作拆分为你想要的那样简单，但是节点会很多。如果希望节点更小到可以计算该节点的梯度。</p></li><li><p>一个更大的例子:</p><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/01.png" alt></li><li>提示：两个节点从后面到一个节点的反向传播是通过添加两个导数来实现的。</li></ul></li><li><p>模块化实现：正向/反向API（示例乘法代码）:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultuplyGate</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  x,y are scalars</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    z = x*y</span><br><span class="line">    self.x = x  <span class="comment"># Cache</span></span><br><span class="line">    self.y = y<span class="comment"># Cache</span></span><br><span class="line">    <span class="comment"># We cache x and y because we know that the derivatives contains them.</span></span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(dz)</span>:</span></span><br><span class="line">    dx = self.y * dz         <span class="comment">#self.y is dx</span></span><br><span class="line">    dy = self.x * dz</span><br><span class="line">    <span class="keyword">return</span> [dx, dy]</span><br></pre></td></tr></table></figure></li><li><p>如果你看一个深度学习框架，你会发现它遵循模块化的实现，每个类都有正向传播和反向传播的定义。例如：</p><ul><li>Multiplication</li><li>Max</li><li>Plus</li><li>Minus</li><li>Sigmoid</li><li>Convolution</li></ul></li></ul></li><li><p>把神经网络定义为一个函数:</p><ul><li>（之前）线性评分函数: <code>f = Wx</code></li><li>（现在）2层神经网络:    <code>f = W2*max(0,W1*x)</code> <ul><li>其中max是RELU非线性函数</li></ul></li><li>（现在）三层神经网络:    <code>f = W3*max(0,W2*max(0,W1*x)</code></li><li>等等..</li></ul></li><li><p>神经网络是一些简单操作的堆栈，形成复杂的操作。</p></li></ul><h2 id="05-Convolutional-neural-networks-CNNs"><a href="#05-Convolutional-neural-networks-CNNs" class="headerlink" title="05. Convolutional neural networks (CNNs)"></a>05. Convolutional neural networks (CNNs)</h2><ul><li>神经网络历史:<ul><li>第一台感知器机器是弗兰克罗森布拉特在1957年开发的。它被用来识别字母表中的字母。反向传播还没有发展。</li><li>多层感知器是由Adaline/Madaline于1960年开发的。反向传播还没有发展。</li><li>反向传播是Rumeelhart在1986年发明的。</li><li>有一段时间，NN没有什么新的事情发生。由于计算资源和数据有限。</li><li><a href="www.cs.toronto.edu/~fritz/absps/netflix.pdf">2006</a>年，Hinton发表了一篇论文，表明我们可以使用受限的Boltzmann机器来训练一个深度神经网络来初始化权值，然后再进行反向传播。</li><li>2012年，Hinton在<a href="http://ieeexplore.ieee.org/document/6296526/" target="_blank" rel="noopener">语音识别</a>领域取得了第一个强劲的成果。而<a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">Alexnet</a> 的“卷积神经网络”在2012年赢得了图像网络，也是由Hinton的团队完成的</li><li>之后，神经网络被广泛应用于各种应用中。</li></ul></li><li>卷积神经网络历史：<ul><li>Hubel和Wisel在1959年至1968年对猫大脑皮层的实验发现，大脑皮层有一个地形图，神经元具有从简单到复杂的特殊组织。</li><li>1998年，Yann-Lecun提出了一篇<a href="http://ieeexplore.ieee.org/document/726791/" target="_blank" rel="noopener">基于梯度的学习应用于文档识别的论文</a>，引入了卷积神经网络。它很好地识别邮政编码，但不能运行在更复杂的例子</li><li>2012年，<a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">AlexNet</a> 使用了同样的Yan Lecun架构，并赢得了图像网络挑战赛。 与1998年不同的是，现在我们有了一个可以使用的大数据集，gpu的强大功能解决了很多性能问题。</li><li>从2012年开始，CNN将用于各种任务（以下是一些应用程序）:<ul><li>图像分类.</li><li>图像检索.<ul><li>利用神经网络提取特征，然后进行相似性匹配.</li></ul></li><li>目标检测.</li><li>分割.<ul><li>图像中的每个像素都有一个标签.</li></ul></li><li>人脸识别.</li><li>姿势识别.</li><li>医学图像.</li><li>用强化学习玩阿塔里游戏.</li><li>星系分类.</li><li>路标识别.</li><li>图片字幕.</li><li>风格迁移.</li></ul></li></ul></li><li>ConvNet体系结构明确假设输入是图像，这允许我们将某些属性编码到体系结构中</li><li>ConvNet中有几种不同类型的层（例如CONV/FC/RELU/POOL是目前最流行的）</li><li>每个层可能有参数，也可能没有参数（例如CONV/FC 会，RELU/POOL 不会）</li><li>每一层可能有也可能没有额外的超参数（例如CONV/FC/POOL 有，RELU没有）</li><li>卷积神经网络的工作原理?<ul><li>完全连接层是所有神经元都连接在一起的层. 有时我们称之为稠密层<ul><li>If input shape is <code>(X, M)</code> the weighs shape for this will be <code>(NoOfHiddenNeurons, X)</code></li></ul></li><li>卷积层是一层，在这个层中，我们将通过一个滤波器来保持输入的结构，该滤波器将穿过所有图像。<ul><li>我们用点积：W.T*X+b。这个等式使用广播技术。</li><li>所以我们需要得到W和b的值</li><li>我们通常把滤波器（W）当作向量而不是矩阵来处理。</li></ul></li><li>我们称之为卷积激活图的输出。我们需要多个激活图。<ul><li>例如，如果我们有6个过滤器，下面是形状：<ul><li>输入图像                        <code>(32,32,3)</code></li><li>滤波器尺寸                              <code>(5,5,3)</code><ul><li>我们使用6个过滤器。深度必须为3，因为输入图的深度为3。</li></ul></li><li>卷积的输出.                 <code>(28,28,6)</code> <ul><li>如果是一个滤波器会是   <code>(28,28,1)</code></li></ul></li><li>RELU之后                          <code>(28,28,6)</code> </li><li>另一个滤波器                     <code>(5,5,6)</code></li><li>卷积的输出.                 <code>(24,24,10)</code></li></ul></li></ul></li><li>事实证明，卷积神经网络在第一层学习低级特性，然后学习中级特性，然后学习高级特性。</li><li>在卷积层之后，我们可以为分类任务提供一个线性分类器。</li><li>在卷积神经网络中，我们通常有一些（Conv==&gt;Relu），然后我们应用池操作来降低激活的大小。</li></ul></li><li><p>我们做卷积的时候步幅是什么:</p><ul><li>在做一个转换层时，我们有很多选择要做，关于我们将采取的步骤。我将用例子来解释这一点。</li><li>步幅是在滑行时跳跃。默认为1。</li><li>给定形状为<code>（7,7）</code>的矩阵和形状为<code>（3,3）</code>的滤波器：<ul><li>If stride is <code>1</code> then the output shape will be <code>(5,5)</code>              <code># 2 are dropped</code></li><li>If stride is <code>2</code> then the output shape will be <code>(3,3)</code>             <code># 4 are dropped</code></li><li>If stride is <code>3</code> it doesn’t work.</li></ul></li><li>一般的公式是 <code>((N-F)/stride +1)</code><ul><li>If stride is <code>1</code> then <code>O = ((7-3)/1)+1 = 4 + 1 = 5</code></li><li>If stride is <code>2</code> then <code>O = ((7-3)/2)+1 = 2 + 1 = 3</code></li><li>If stride is <code>3</code> then <code>O = ((7-3)/3)+1 = 1.33 + 1 = 2.33</code>        <code># doesn&#39;t work</code></li></ul></li></ul></li><li><p>在实践中，零填充边界是很常见的。   <code># 从两侧填充.</code></p><ul><li>将步幅设为1是这个等式的共同点：（F-1）/2，其中F是滤波器的尺寸<ul><li>Example <code>F = 3</code> ==&gt; Zero pad with <code>1</code></li><li>Example <code>F = 5</code> ==&gt; Zero pad with <code>2</code></li></ul></li><li>如果我们这样做，我们称之为相同的卷积。</li><li>添加0给边缘提供了另一个功能，这就是为什么有不同的填充技术，如填充角不是零，但在实践中，零是有效的！</li><li>我们这样做是为了保持输入的完整大小。如果我们不这样做的话，输入将收缩得太快，我们将丢失大量数据。</li></ul></li><li>例子:<ul><li>如果我们输入了<code>shape（32,32,3）</code>和10个形状是<code>（5,5）</code>的过滤器，步长为1和填充为2<ul><li>输出尺寸为 <code>(32,32,10)</code>                       <code># 我们保留了尺寸不变</code></li></ul></li><li>每个滤波器参数个数为 <code>= 5*5*3 + 1 = 76</code></li><li>所有的参数个数为 <code>= 76 * 10 = 76</code></li></ul></li><li>滤波器的数量通常是2的幂次方.           <code># 为了更好矢量化</code></li><li>这里是Conv层的参数:<ul><li>滤波器数量 K.<ul><li>通常是2的幂次方.</li></ul></li><li>空间内容大小F.<ul><li>3,5,7 ….</li></ul></li><li>步幅 S. <ul><li>通常是1或者2        (如果步幅较大，则会有一个下采样，但不同于池化) </li></ul></li><li>填充量<ul><li>如果我们希望输入形状作为输出形状，如果F是3则是1，如果F是5则是2，依此类推</li></ul></li></ul></li><li>池化使表示更小，更易于管理。</li><li>池化在每个激活映射上独立运行。</li><li>最大池化层的例子.<ul><li>最大池的参数是滤波器的大小和步长<ul><li>示例2x2，步幅为2 <code>#通常这两个参数是相同的2，2</code></li></ul></li></ul></li><li>平均池化层的例子.<ul><li>在这种情况下，这可能是可以学习的。</li></ul></li></ul><h2 id="06-Training-neural-networks-I"><a href="#06-Training-neural-networks-I" class="headerlink" title="06. Training neural networks I"></a>06. Training neural networks I</h2><ul><li><p>作为修订，这里是小批量随机梯度下降算法步骤：</p><ul><li>循环:<ol><li>抽样一批数据。</li><li>通过图（网络）向前推进并获得损失。</li><li>反向传播计算梯度.</li><li>用梯度更新参数</li></ol></li></ul></li><li><p>激活函数:</p><ul><li><p>激活函数的不同选择包括 Sigmoid, tanh, RELU, Leaky RELU, Maxout, and ELU.</p></li><li><p><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/42.png" alt></p></li><li><p>Sigmoid:</p><ul><li>压缩[0,1]之间的数字</li><li>像人脑一样用作发射率.</li><li><code>Sigmoid(x) = 1 / (1 + e^-x)</code></li><li>sigmoid的问题:<ul><li>大值神经元会破坏梯度。<ul><li>在大多数情况下，渐变接近0（大值/小值），如果图形/网络很大，则会终止更新。</li></ul></li><li>不是以零为中心。<ul><li>不会产生零均值数据</li></ul></li><li><code>exp()</code> 的计算开销有点大.<ul><li>只是想提一下。我们在深度学习中有更复杂的运算，比如卷积。</li></ul></li></ul></li></ul></li><li><p>Tanh:</p><ul><li>压缩[-1,1]之间的数字</li><li>以0的中心.</li><li>大值神经元仍然会破坏梯度。</li><li><code>Tanh(x)</code> 是个方程.</li><li>1991年由Yann Lecun提出</li></ul></li><li><p>RELU (<code>Rectified</code>改正的 <code>linear</code>线性 <code>unit</code>单元):</p><ul><li><code>RELU(x) = max(0,x)</code></li><li>不会破坏梯度<ul><li>只有小值被杀死。在一半结束了梯度</li></ul></li><li>计算效率高。</li><li>比Sigmoid和Tanh快得多 <code>(6x)</code></li><li>在生物学上比sigmoid更可信。</li><li>由Alex Krizhevsky在2012年多伦多大学提出 (AlexNet)</li><li>问题:<ul><li>不以0为中心.</li></ul></li><li>如果权重初始化不好，可能75%的神经元会死亡，这是浪费计算。但它仍然有效。这是一个积极的研究领域，以优化这一点。</li><li>为了解决上述问题，人们可以将所有偏差初始化为0.01</li></ul></li><li><p>Leaky RELU:</p><ul><li><code>leaky_RELU(x) = max(0.01x,x)</code></li><li>不会破坏两边的梯度。</li><li>计算效率高</li><li>比Sigmoid和Tanh快得多 (6x)</li><li>不会挂掉</li><li>PRELU通过变量alpha来放置0.01，alpha作为参数学习</li></ul></li><li><p>ELU(<code>Exponential</code>指数 <code>linear</code>线性 <code>units</code>单元):</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ELU(x) &#x3D; &#123; x if x &gt; 0</span><br><span class="line">   alpah *(exp(x) -1)if x &lt;&#x3D; 0</span><br><span class="line">       # alpah are a learning parameter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>有RELU的所有优点</p></li><li><p>更接近于零的平均输出，并增加了一些噪声的鲁棒性。</p></li><li><p>问题</p><ul><li><code>exp()</code> 的计算开销有点大.</li></ul></li></ul></li><li><p>最大输出激活(Maxout activations):</p><ul><li><code>maxout(x) = max(w1.T*x + b1, w2.T*x + b2)</code></li><li>推广了RELU和Leaky RELU</li><li>不会挂掉</li><li>问题:<ul><li>每个神经元的参数数量加倍</li></ul></li></ul></li><li><p>在实践中:</p><ul><li>使用RELU。注意你的学习率。</li><li>尝试Leaky RELU/Maxout/ELU</li><li>尝试 tanh 但是不要过高的期望</li><li>不要用 sigmoid!</li></ul></li></ul></li><li><p><strong>数据预处理</strong>:</p><ul><li><p>正则化数据:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 零中心数据。（计算每个输入的平均值）</span></span><br><span class="line"><span class="comment"># 之所以这样做，是因为我们需要数据介于正数和负数之间</span></span><br><span class="line"><span class="comment"># 而不是全部都是负数或正数。</span></span><br><span class="line">X -= np.mean(X, axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 然后应用标准差。提示：在图像中我们不会这样做</span></span><br><span class="line">X /= np.std(X, axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>正则化图片:</p><ul><li>减去平均图像（例如Alexnet）<ul><li>平均图像形状与输入图像相同。</li></ul></li><li>或减去每个通道的平均值<ul><li>平均值计算所有图像的每个通道的平均值。形状为3（3通道）</li></ul></li></ul></li></ul></li><li><p><strong>权重初始化</strong>:</p><ul><li><p>用零初始化所有W时发生了什么?</p><ul><li>所有的神经元都会做同样的事情。他们将有相同的梯度，他们将有相同的更新</li><li>所以如果某个特定层的W相等，那么所描述的事情就发生了</li></ul></li><li><p>第一个想法是用小随机数初始化w:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">W = <span class="number">0.01</span> * np.random.rand(D, H)</span><br><span class="line"><span class="comment"># 适用于小型网络，但对于较深的网络会产生问题</span></span><br></pre></td></tr></table></figure><ul><li><p>在更深的网络中，标准差将为零。而在深层网络中，这种梯度会很快消失。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">W = <span class="number">1</span> * np.random.rand(D, H) </span><br><span class="line"><span class="comment"># 适用于小型网络，但对于较深的网络会产生问题</span></span><br></pre></td></tr></table></figure></li><li><p>网络会因为大值数据而没法计算</p></li></ul></li><li><p><strong><em>Xavier 初始化</em></strong>:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W = np.random.rand(<span class="keyword">in</span>, out) / np.sqrt(<span class="keyword">in</span>)</span><br></pre></td></tr></table></figure><ul><li><p>它之所以有效，是因为我们希望输入的方差和输出的方差一样。</p></li><li><p>但它有一个问题，当你使用RELU时，它会崩溃</p></li></ul></li><li><p><strong><em>He 初始化</em></strong> (RELU问题的解决方案):</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W = np.random.rand(<span class="keyword">in</span>, out) / np.sqrt(<span class="keyword">in</span>/<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>解决了RELU的问题。建议在使用RELU时使用</li></ul></li><li><p>适当的初始化是一个活跃的研究领域。</p></li></ul></li><li><p><strong>批次正则化(Batch normalization)</strong>:</p><ul><li>是一种为神经网络的任何层提供零均值/单位方差输入的技术.</li><li>它加快了训练的速度。你很想这么做。<ul><li>2015年由Sergey Ioffe和Christian Szegedy制作。</li></ul></li><li>我们在每一层进行高斯激活。通过计算均值和方差。</li><li>通常插入在（完全连接或卷积层）和（非线性之前）。</li><li>步骤（对于层的每个输出）<ol><li>首先，我们计算每一个特征批次的平均值和方差^2</li><li>我们通过减去平均值并除以（方差^2+epsilon）的平方根进行归一化<ul><li>加上epsilon为了不被零除</li></ul></li><li>然后我们制作一个尺寸和移位变量: <code>Result = gamma * normalizedX + beta</code>  <ul><li>gamma和beta是可学习的参数</li><li>基本上可以说“嘿！！我不想要零均值/单位方差输入，请把原始输入还给我，这样对我更好。”</li><li>嘿，根据你想要的改变和比例，而不仅仅是均值和方差！</li></ul></li></ol></li><li>该算法使每一层变得灵活（它选择它想要的分布）</li><li>我们初始化批处理范数参数以将输入转换为零均值/单位方差分布，但在训练过程中，他们可以了解到任何其他分布都可能更好。</li><li>在训练过程中，我们需要用加权平均法计算出每一层的总体均值和总体方差。</li><li><u>批次正则化的好处</u>:<ul><li>网络训练更快.</li><li>允许更高的学习率。</li><li>有助于降低对初始起始重量的敏感性</li><li>使更多的激活功能可行。</li><li>提供一些正则化。<ul><li>因为我们计算的是每个批次的均值和方差，这会产生轻微的正则化效果。</li></ul></li></ul></li><li>在conv层中，每个激活图有一个方差和一个平均值。</li><li>批次正则化在CONV和正则深层神经网络中效果最好，但对于递归神经网络和强化学习仍然是一个活跃的研究领域。<ul><li>它的挑战在于强化学习，因为它的批量很小。</li></ul></li></ul></li><li><p><strong>浅显易懂的学习过程(Baby sitting the learning process)</strong></p><ol><li>数据预处理。</li><li>选择架构。</li><li>正向传播并检查损失（禁用正则化）。检查损失是否合理</li><li>加上正规化，损失应该上去了！</li><li>再次禁用正则化，取少量数据，尝试训练损失并达到零损失。<ul><li>你应该在小数据集上过拟合</li></ul></li><li>把你的全部训练数据，和小正则化，然后尝试一些学习率的值。<ul><li>如果损失几乎没有变化，那么学习率设置的太小了。</li><li>如果你得到了NAN，那么你的NN爆炸了，你的学习率太高了。</li><li>通过尝试最小值（可以更改）和最大值（不会使网络爆炸）来获取学习速率范围。</li></ul></li><li>对超参数进行优化，得到最佳的超参数值。</li></ol></li><li><p>超参数优化</p><ul><li>尝试交叉验证策略。<ul><li>用几个Ephoc跑，试着优化范围。</li></ul></li><li>最好在log空间中进行优化。</li><li>请调整范围，然后再试一次</li><li>最好尝试随机搜索而不是网格搜索（在log空间中）</li></ul></li></ul><h2 id="07-Training-neural-networks-II"><a href="#07-Training-neural-networks-II" class="headerlink" title="07. Training neural networks II"></a>07. Training neural networks II</h2><ul><li><p><strong>优化算法</strong>:</p><ul><li><p>随机梯度下降问题:</p><ul><li>如果在一个方向上损失很快，而在另一个方向上损失缓慢（仅针对两个变量），那么沿着浅维度的进展将非常缓慢，在陡峭的方向上会出现抖动。我们的神经网络会有很多参数，然后问题会更多。</li><li>局部最小值或鞍点<ul><li>如果SGD进入局部极小值，我们将在这一点上卡住，因为梯度是零。</li><li>同样在鞍点，梯度为零，所以我们会卡住。</li><li>鞍点在某一点上说:<ul><li>一些梯度会增加损失。</li><li>一些梯度会降低损失。</li><li>而在高维（例如1亿维）中发生的更多</li></ul></li><li>深度神经网络的问题更多的是关于鞍点而不是局部最小值，因为深度神经网络具有高维（参数）</li><li>小批量是有噪音的，因为没有对整个批次采取梯度。</li></ul></li></ul></li><li><p><strong>SGD + momentum</strong>:</p><ul><li><p>建立速度作为梯度的运行平均值</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 计算加权平均数。 rho best 在 [0.9 - 0.99]</span></span><br><span class="line">V[t+<span class="number">1</span>] = rho * v[t] + dx</span><br><span class="line">x[t+<span class="number">1</span>] = x[t] - learningRate * V[t+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>V[0]</code> 是0.</p></li><li><p>解决了鞍点和局部极小问题。</p></li><li><p>它越过极值点，然后仔回到了原来的状态。</p></li></ul></li><li><p><strong>Nestrov momentum</strong>:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dx = compute_gradient(x)</span><br><span class="line">old_v = v</span><br><span class="line">v = rho * v - learning_rate * dx</span><br><span class="line">x+= -rho * old_v + (<span class="number">1</span>+rho) * v</span><br></pre></td></tr></table></figure><ul><li>不会越过极值点，但比SGD + momentum慢</li></ul></li><li><p><strong>AdaGrad</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grad_squared = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">  dx = compute_gradient(x)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># 这里有一个问题，梯度平方没有衰减（变的特别大）</span></span><br><span class="line">  grad_squared += dx * dx</span><br><span class="line">  </span><br><span class="line">  x -= (learning_rate*dx) / (np.sqrt(grad_squared) + <span class="number">1e-7</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>RMSProp</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grad_squared = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">  dx = compute_gradient(x)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#Solved ADAgra</span></span><br><span class="line">  grad_squared = decay_rate * grad_squared + (<span class="number">1</span>-grad_squared) * dx * dx  </span><br><span class="line">  </span><br><span class="line">  x -= (learning_rate*dx) / (np.sqrt(grad_squared) + <span class="number">1e-7</span>)</span><br></pre></td></tr></table></figure><ul><li>人们用这个来代替AdaGrad</li></ul></li><li><p><strong>Adam</strong></p><ul><li>结合了momentum和RMSProp来计算梯度。</li><li>它需要一个固定偏差来确定梯度的起始点</li><li>是目前为止最好的技术在很多问题上都是最好的。</li><li>赋值 <code>beta1 = 0.9</code> 并且 <code>beta2 = 0.999</code> 并且 <code>learning_rate = 1e-3</code> 或者 <code>5e-4</code> 是许多模型的一个很好的选择！</li></ul></li><li><p><strong>学习衰退(Learning decay)</strong></p><ul><li>每隔几个时代学习率下降一半。</li><li>帮助学习率不反弹。</li><li>学习衰退在SGD+动量中很常见，但在Adam中不常见。</li><li>不要从一开始就用学习衰退来选择超参数。先试试，看看你是否需要衰退学习率</li></ul></li><li><p>以上算法都是一阶优化问题。</p></li><li><p><strong>二阶优化</strong></p><ul><li>使用梯度和Hessian到二次逼近</li><li>逼近的最小值</li><li>这次更新有什么好处?<ul><li>有些版本没有学习率。</li></ul></li><li>但对于深度学习是不现实的<ul><li>有 O(N^2) 个元素.</li><li>反转复杂度 O(N^3).</li></ul></li><li><strong>L-BFGS</strong> 是二阶优化的一个版本<ul><li>适用于批量优化，但不适用于小批量。</li></ul></li></ul></li><li><p>在实践中，首先使用ADAM，如果不起作用，再试试L-BFGS</p></li><li><p>有人说所有著名的深层架构都使用 <strong>SGS + Nestrov momentum</strong></p></li></ul></li><li><p><strong>正则化</strong></p><ul><li>到目前为止，我们已经讨论过减少训练误差，但我们最关心的是我们的模型将如何处理看不见的数据！</li><li>如果训练数据和验证数据之间的误差太大怎么办？</li><li>这种误差称为高方差</li><li><strong>模型集合</strong>:<ul><li>算法:<ul><li>训练具有不同初始化的同一体系结构的多个独立模型。</li><li>在测试时平均他们的结果。</li></ul></li><li>它可以给你额外的2%的性能</li><li>减少了泛化误差。</li><li>你可以在训练中使用你的神经网络的一些快照，把它们集合起来，然后获取结果。</li></ul></li><li>正则化解决了高方差问题。我们已经讨论过L1，L2正则化。</li><li>一些正则化技术只针对神经网络设计，可以做得更好。</li><li><strong>Drop out</strong>:<ul><li>在每一次正向传播中，随机将一些神经元设为零。drop概率是一个超参数，在大多数情况下为0.5。</li><li>所以你会选择一些激活，使它们为零。</li><li>它起作用是因为:<ul><li>它迫使网络具有冗余表示；防止特征的协同适应!</li><li>如果你想一想，它将一些模型集成在同一个模型中!</li></ul></li><li>在测试时，我们可以用每一个drop层乘以drop的概率</li><li>有时在测试时，我们不乘法任何东西，并保持原样。</li><li>带有drop需要更多的时间来训练。</li></ul></li><li><strong>数据增强</strong>:<ul><li>另一种使正则化的技术。</li><li>更改数据!</li><li>例如，翻转图像或旋转图像。</li><li>ResNet中的示例:<ul><li>训练时: 随机采样进行裁剪和缩放:<ol><li>在[256,480]范围内选择随机数L</li><li>调整训练图像大小，短边=L</li><li>随机抽样224x244补丁.</li></ol></li><li>测试时: 对一套固定裁剪取平均值<ol><li>按5个比例调整图像大小 {224, 256, 384, 480, 640}</li><li>对于每个尺寸，使用10(<code>(4+1)*2</code>)个224x224裁剪：4个角+中心+翻转</li></ol></li><li>应用颜色抖动或PCA</li><li>平移，旋转，伸展。</li></ul></li></ul></li><li>断开连接(Drop connect)<ul><li>就像辍学的想法一样，它达到了规则化的效果</li><li>我们没有将激活drop，而是随机地将权重归零</li></ul></li><li>部分最大池化(Fractional Max Pooling)<ul><li>很酷的正则化思想。不常用</li><li>随机化我们聚集的区域</li></ul></li><li>随机深度<ul><li>新想法.</li><li>直接消除层数而不是，而不是神经元</li><li>有类似drop的效果，但这是一个新的想法。</li></ul></li></ul></li><li><p><strong>迁移学习</strong>:</p><ul><li><p>有时，模型会过度拟合数据，因为数据很小，而不是因为正则化。</p></li><li><p>如果你想训练/使用CNNs，你需要大量的数据。</p></li><li><p>迁移学习的步骤</p><ol><li>在一个与你的数据集有共同特征的大数据集上训练。叫做预训练。</li><li>冻结除最后一层以外的所有层，并输入您的小数据集，以便只了解最后一层。</li><li>不仅最后一层可能会再次训练，您还可以根据您拥有的数据数量微调任意数量的层</li></ol></li><li><p>迁移学习使用指南:</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th></th><th>非常相似的数据集</th><th>非常不同的数据集</th></tr></thead><tbody><tr><td><strong>很少的数据集</strong></td><td>在顶层使用线性分类器</td><td>你有麻烦了。。尝试不同阶段的线性分类器</td></tr><tr><td><strong>相当多的数据</strong></td><td>微调几层</td><td>精细调整一大层</td></tr></tbody></table></div><ul><li>迁移学习是正常现象，也不例外</li></ul><h2 id="08-Deep-learning-software"><a href="#08-Deep-learning-software" class="headerlink" title="08. Deep learning software"></a>08. Deep learning software</h2><ul><li>由于深度学习软件的急剧变化，CS231n的这一部分每年都会发生很大的变化。</li><li>CPU vs GPU<ul><li>图形卡的开发是为了渲染图形来玩游戏或制作3D媒体，。等。<ul><li>NVIDIA vs AMD<ul><li>深度学习选择NVIDIA而不是AMD GPU，因为NVIDIA正在推动研究的发展，深度学习也使它的架构更适合深度学习</li></ul></li></ul></li><li>CPU有更少的内核，但每个内核都更快，功能更强；擅长顺序任务。虽然gpu有更多的内核，但每个内核都慢得多“笨”；非常适合并行任务</li><li>GPU核心需要协同工作。有自己的记忆</li><li>矩阵乘法来自于适合gpu的运算。它有独立于MxN的操作，可以并行进行。</li><li>卷积运算也可以瘫痪，因为它有独立的运算。</li><li>编程GPU框架:<ul><li><strong>CUDA</strong> (仅限英伟达)<ul><li>编写直接在GPU上运行的类c代码。</li><li>很难构建一个运行在GPU上的好的优化代码。这就是为什么他们提供高级API。</li><li>高级API：cuBLAS、cuDNN等</li><li><strong>CuDNN</strong> 已经实施了反向传播，卷积，循环，对你来说更多！</li><li>实际上，您不用编写并行代码。你可以使用其他人实现和优化的代码！</li></ul></li><li><strong>OpenCl</strong><ul><li>类似于CUDA，但可以在任何GPU上运行</li><li>通常较慢。</li><li>目前还没有得到所有深度学习软件的支持。</li></ul></li></ul></li><li>学习并行编程有很多课程。</li><li>如果不小心，训练可能会成为读取数据和传输到GPU的瓶颈。 解决方案如下:<ul><li>将所有数据读入RAM. # If possible</li><li>使用SSD而不是HDD</li><li>使用多个CPU线程预取数据!<ul><li>当GPU进行计算时，CPU线程将为您获取数据</li><li>很多框架都为您实现了这一点，因为这有点痛苦！</li></ul></li></ul></li></ul></li><li><strong>深度学习框架</strong><ul><li>它的移动速度非常快!</li><li>当前可用的框架:<ul><li>Tensorflow (Google)</li><li>Caffe (UC Berkeley)</li><li>Caffe2 (Facebook)</li><li>Torch (NYU / Facebook)</li><li>PyTorch (Facebook)</li><li>Theano (U monteral) </li><li>Paddle (Baidu)</li><li>CNTK (Microsoft)</li><li>MXNet (Amazon)</li></ul></li><li>老师认为你应该把重点放在Tensorflow和Pythorch上。</li><li>深度学习框架的意义:<ul><li>轻松构建大型计算图.</li><li>在计算图中容易地计算梯度。</li><li>在GPU上高效运行（cuDNN-cuBLAS）</li></ul></li><li>Numpy不能在GPU上运行。</li><li>大多数框架在正向传播时都会像NUMPY一样，然后他们会为你计算梯度。</li></ul></li><li><strong>Tensorflow (Google)</strong><ul><li>代码由两部分组成:<ol><li>定义计算图.</li><li>运行图形并多次重用它。</li></ol></li><li>Tensorflow使用静态图形架构。</li><li>Tensorflow变量存在于图中。用占位符来挨个喂养数据</li><li>全局初始化器函数初始化图中的变量。</li><li>使用预定义的优化器和损失。</li><li>你可以用<code>layers.dense</code>函数来实现一个完整的网络层.</li><li><strong>Keras</strong> (高级包装机High level wrapper):<ul><li>Keras是tensorflow顶部的一层,使普通的事情容易做。</li><li>太受欢迎了</li><li>用几行代码训练一个完整的深层神经网络。</li></ul></li><li>有很多高级包装:<ul><li>Keras</li><li>TFLearn</li><li>TensorLayer</li><li>tf.layers   <code>#使用tensorflow</code></li><li>tf-Slim   <code>#使用tensorflow</code></li><li>tf.contrib.learn   <code>#使用tensorflow</code></li><li>Sonnet <code># 心灵深处的新事物</code></li></ul></li><li>Tensorflow有预先训练过的模型，您可以在使用转移学习时使用这些模型。</li><li>Tensorboard增加了记录损失和统计数据的功能。运行服务器，得到漂亮的图形!</li><li>如果您想在某些节点上拆分图，它具有分布式代码</li><li>Tensorflow的灵感来自Theano。它有相同的灵感和结构。</li></ul></li></ul><ul><li><p><strong>PyTorch (Facebook)</strong></p><ul><li>有三层抽象:<ul><li>Tensor: <code>ndarray</code>但在tensorflow中 #<code>类似于numpy数组的GPU上运行</code><ul><li>Variable:计算图中的结点; 存储数据和梯度 <code>#Like Tensor, Variable, Placeholders</code></li></ul></li><li>Module: A NN layer;可以存储状态或可学习的权重<code>#Like tf.layers in tensorflow</code></li></ul></li><li>在PyTorch中，图形运行在您正在执行的同一个循环中，这使得调试更加容易。这叫做动态图。</li><li>在PyTorch中，您可以通过向前和向后写入张量来定义自己的autograd函数。大多数时候它会为你实现。</li><li>torch.nn是一个类似于tensorflow中keras的高级api。你可以创建模型，然后继续下去<ul><li>您可以定义自己的nn模块</li></ul></li><li>Pythorch还包含tensorflow之类的优化器。</li><li>它包含一个数据加载器，它包装了一个数据集，并提供了minbatches、shuffling和多线程处理。</li><li>Pythorch包含最好和超级容易使用的预训练模型</li><li>Pythorch含有类似Tensorboard的Visdom。但Tensorboard 似乎更强大。</li><li>与Torch相比，PyTorch是一个新的且仍在不断发展。它仍然处于beta状态。</li><li>Pythorch最适合研究</li></ul></li><li><p>Tensorflow构建一次图形，然后运行多次（称为静态图形）</p></li><li><p>在每个PyTorch迭代中，我们构建一个新的图（称为动态图）</p></li><li><p><strong>静态图vs动态图</strong>:</p><ul><li><p>最优化(Optimization):</p><ul><li>使用静态图，框架可以在运行之前为您优化图形.</li></ul></li><li><p>序列化(Serialization)</p><ul><li><strong>Static</strong>: 一旦构建了graph，就可以序列化它并运行它，而不需要构建该图的代码。例如在c中使用图++</li><li><strong>Dynamic</strong>: 总是需要保留代码。</li></ul></li><li><p>条件(Conditional)</p><ul><li>在动态图中更容易,在静态图中更加复杂。</li></ul></li><li><p>循环(Loops):</p><ul><li>在动态图中更容易,在静态图中更加复杂。</li></ul></li></ul></li><li><p>Tensorflow fold 通过动态批处理使动态图在Tensorflow中更容易实现</p></li><li><p>动态图的应用包括：递归网络(recurrent networks and recursive networks).</p></li><li><p>Caffe2使用静态图，可以在python中训练模型，也可以在IOS和Android上运行</p></li><li><p>Tensorflow/Caffe2在生产中得到了广泛的应用，特别是在移动设备上</p></li></ul><h2 id="09-CNN-architectures"><a href="#09-CNN-architectures" class="headerlink" title="09. CNN architectures"></a>09. CNN architectures</h2><ul><li><p>本节介绍著名的CNN架构。关注自2012年以来赢得<a href="www.image-net.org/">ImageNet</a>竞赛的CNN架构。 </p><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/43.png" alt></li></ul></li><li><p>这些体系结构包括: <a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">AlexNet</a>, <a href="https://arxiv.org/abs/1409.1556" target="_blank" rel="noopener">VGG</a>, <a href="https://research.google.com/pubs/pub43022.html" target="_blank" rel="noopener">GoogLeNet</a>, and <a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="noopener">ResNet</a>.</p></li><li><p>我们还将讨论一些有趣的架构。</p></li><li><p>第一个ConvNet是Yann Lecun在1998年提出的<a href="http://ieeexplore.ieee.org/document/726791/" target="_blank" rel="noopener">LeNet-5</a> 体系结构</p><ul><li>结构是: <code>CONV-POOL-CONV-POOL-FC-FC-FC</code><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/02.jpg" alt></li></ul></li><li>每个卷积层滤波器步幅为<code>1</code>且采用<code>5x5</code>尺寸</li><li>每个池化层滤波器步幅为<code>2</code>且采用<code>2x2</code>尺寸</li><li>它在数字识别中很有用。</li><li>特别是图像特征分布在整个图像上的特点，以及具有可学习参数的卷积是在多个位置用较少的参数提取相似特征的有效方法。</li><li>它正好包含 <strong><u>5</u></strong> 层</li></ul></li><li><p>In <a href="https://arxiv.org/abs/1003.0358" target="_blank" rel="noopener">2010</a> 丹·克劳迪乌西雷桑（Dan Claudiu Ciresan）和Jurgen Schmidhuber发表了GPU神经网络的最早实现之一。这种实现方法在NVIDIA GTX 280 图形处理器上实现了前向和后向两个层次的神经网络。</p></li><li><p><a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener"><strong>AlexNet</strong></a> (2012):</p><ul><li>ConvNet开创了进化之路，并在2012年赢得了ImageNet.</li><li>结构如下: <code>CONV1-MAXPOOL1-NORM1-CONV2-MAXPOOL2-NORM2-CONV3-CONV4-CONV5-MAXPOOL3-FC6-FC7-FC8</code></li><li>包含 <strong><u>8</u></strong> 层，前5层为卷积层，后3层为完全连通层。</li><li>AlexNet的准确度误差为<code>16.4%</code></li><li>例如，如果输入为227 x 227 x3，则每层输出的形状如下：<ul><li>CONV1    (96 11 x 11 filters at stride 4, pad 0)<ul><li>Output shape <code>(55,55,96)</code>,   Number of weights are <code>(11*11*3*96)+96 = 34944</code></li></ul></li><li>MAXPOOL1 (3 x 3 filters applied at stride 2)<ul><li>Output shape <code>(27,27,96)</code>,   No Weights</li></ul></li><li>NORM1<ul><li>Output shape <code>(27,27,96)</code>,     We don’t do this any more</li></ul></li><li>CONV2 (256 5 x 5 filters at stride 1, pad 2)</li><li>MAXPOOL2 (3 x 3 filters at stride 2)</li><li>NORM2</li><li>CONV3 (384 3 x 3 filters ar stride 1, pad 1)</li><li>CONV4 (384 3 x 3 filters ar stride 1, pad 1)</li><li>CONV5 (256 3 x 3 filters ar stride 1, pad 1)</li><li>MAXPOOL3 (3 x 3 filters at stride 2)<ul><li>Output shape <code>(6,6,256)</code></li></ul></li><li>FC6 (4096)</li><li>FC7 (4096)</li><li>FC8 (1000 neurons for class score)</li></ul></li><li>一些其他细节:<ul><li>首次使用RELU.</li><li>标准层(Norm layers)，但不再使用。</li><li>海量数据扩充</li><li>Dropout <code>0.5</code></li><li>batch size <code>128</code></li><li>SGD momentum <code>0.9</code></li><li>Learning rate <code>1e-2</code> reduce by 10 at some iterations</li><li>7 CNN ensembles!</li></ul></li><li>AlexNet是在GTX 580 GPU上训练的，只有3GB，这不足以在一台机器上进行训练，所以他们将特征地图分为两半。第一个AlexNet是分布式的</li><li>在很多任务中，迁移学习仍然使用它</li><li>参数总数为<code>6000万</code></li></ul></li><li><p><a href="https://arxiv.org/abs/1311.2901" target="_blank" rel="noopener"><strong>ZFNet</strong></a> (2013)</p><ul><li>2013年获胜，错误率为11.7%</li><li>它具有相同的一般结构，但它们在超参数上有一些变化，以获得最佳输出。</li><li>也包含 <strong><u>8</u></strong> 层。</li><li>AlexNet but:<ul><li><code>CONV1</code>: 从 (11 x 11 stride 4) 变为 (7 x 7 stride 2)</li><li><code>CONV3,4,5</code>: 分别用 512, 1024, 512 滤波器来代替 384, 384, 256 滤波器</li></ul></li></ul></li><li><p><a href="https://arxiv.org/abs/1312.6229" target="_blank" rel="noopener">OverFeat</a> (2013)</p><ul><li>2013赢得比赛</li><li>我们展示了如何在ConvNet中有效地实现多尺度滑动窗口方法。我们还介绍了一种新的深度学习方法，通过学习预测对象边界来定位。</li></ul></li><li><p><a href="https://arxiv.org/pdf/1409.1556" target="_blank" rel="noopener"><strong>VGGNet</strong></a> (2014) (Oxford)</p><ul><li>更深层次的网络。</li><li>包含19层。</li><li>2014年和GoogleNet一起赢得比赛，错误率7.3%</li><li>具有较深层的较小过滤器</li><li>VGG的最大优点在于，连续多次3×3卷积可以模拟较大感受野的影响，例如5×5和7×7。</li><li>网络全程使用简单的3 x 3 Conv。<ul><li>3个（3 x 3）核的效果可以与一个（7 x 7）核相同</li></ul></li><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/03.png" alt></li><li>该体系结构包含多个CONV层，然后是5层以上的池化层，然后是全连接层。</li><li>它每个图像的总内存为96MB，仅用于前向传播<ul><li>大多数内存都在前几层</li></ul></li><li>参数总数为1.38亿<ul><li>大多数参数都在完全连接的层中</li></ul></li><li>在训练中也有类似的细节。比如利用momentum 和 dropout。</li><li>VGG19是VGG16的升级版，性能稍好，但内存更大<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/04.png" alt></li></ul></li></ul></li><li><p><a href="https://research.google.com/pubs/pub43022.html" target="_blank" rel="noopener"><strong>GoogleNet</strong></a> (2014)</p><ul><li>更深层次的网络。</li><li>包含22层。</li><li>它具有高效的 <strong><u>Inception</u></strong> 模块</li><li>只有500万个参数！比AlexNet少12倍</li><li>2014年赢得VGGNet，错误率为6.7%</li><li>Inception 模块:<ul><li>设计一个良好的局域网拓扑结构 (网络中的网络network within a network (NiN)) 然后将这些模块堆叠在一起。</li><li>它包括：<ul><li>对上一层的输入应用并行过滤操作<ul><li>多种规格的卷积 (1 x 1, 3 x 3, 5 x 5) <ul><li>添加填充以保持大小</li></ul></li><li>池化层操作. (Max Pooling)<ul><li>添加填充以保持大小</li></ul></li></ul></li><li>将所有滤波器输出串联在一起。</li></ul></li><li>比如:<ul><li>inception模块的输入是 28 x 28 x 256</li><li>然后应用并行滤波器:<ul><li>(1 x 1), 128 filter               <code># output shape (28,28,128)</code></li><li>(3 x 3), 192 filter                 <code># output shape (28,28,192)</code></li><li>(5 x 5), 96 filter                   <code># output shape (28,28,96)</code></li><li>(3 x 3) Max pooling            <code># output shape (28,28,256)</code></li></ul></li><li>连接后，这将是 <code>(28,28,672)</code></li></ul></li><li>通过这种设计，我们称之为天真(Naive)，它有很大的计算复杂性。<ul><li>最后一个例子将使:<ul><li>[1 x 1 conv, 128] ==&gt; 28 <em> 28 </em> 128 <em> 1 </em> 1 * 256 = 25 Million approx</li><li>[3 x 3 conv, 192] ==&gt; 28 <em> 28 </em> 192 <em>3 </em>3 * 256 = 346 Million approx</li><li>[5 x 5 conv, 96] ==&gt; 28 <em> 28 </em> 96 <em> 5 </em> 5 * 256 = 482 Million approx</li><li>总共约8.54亿次操作!</li></ul></li></ul></li><li>解决方案：使用1x1卷积来减少特征深度的瓶颈层<ul><li>受 NiN (<a href="https://arxiv.org/abs/1312.4400" target="_blank" rel="noopener">Network in network</a>)的启发</li></ul></li><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/05.png" alt></li><li>在这个例子中，瓶颈解决方案的总操作量将达到358M，与原始的实现相比是很好的。</li></ul></li><li>所以GoogleNet将这个初始模块进行多次堆叠，以获得一个完整的网络架构，可以在没有完全连接的层的情况下解决问题。</li><li>它在分类步骤之前的末尾使用平均池层。</li><li>完整体系结构:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/44.png" alt></li></ul></li><li>2015年2月，批量标准化初始作为Inception V2引入。批量标准化计算图层输出处所有特征图的平均值和标准差，并用这些值规范化它们的响应。</li><li><a href="https://arxiv.org/abs/1512.00567" target="_blank" rel="noopener">2015</a>年12月，他们介绍了一篇论文“重新思考计算机视觉的初始架构”，这篇论文很好地解释了早期的Inception模型，并引入了新版本V3。</li></ul></li><li><p>第一个GoogleNet和VGG是在批处理规范化发明之前，所以他们有一些技巧来训练NN并很好地收敛。</p></li><li><p><a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="noopener"><strong>ResNet</strong></a> (2015) (Microsoft Research)</p><ul><li><p>ImageNet的152层模型。以3.57%胜出，这好于人为水平的误差。</p></li><li><p>这也是第一次训练一个超过100层甚至1000层的网络。</p></li><li><p>在ILSVRC’15和COCO’15横扫了所有的分类和探测比赛！</p></li><li><p>当我们继续在一个“普通”的卷积神经网络上堆积更深的层时会发生什么？</p><ul><li>较深的模型性能更差，但不是由于过度拟合造成的！</li><li>学习停止执行得很好，因为更深的神经网络更难优化！</li></ul></li><li><p>更深层次的模型应该至少能和浅层次的模型一样好</p></li><li><p>构造的解决方案是从较浅的模型复制学习的层，并将附加层设置为标识映射。</p></li><li><p>残差块:</p><ul><li><p>微软提出了一个残差块，它具有以下架构：:</p><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/45.png" alt></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Instead of us trying To learn a new representation, We learn only Residual</span></span><br><span class="line">Y = (W2* RELU(W1x+b1) + b2) + X</span><br></pre></td></tr></table></figure></li><li><p>假设你有一个直到N层深度的网络。你只想添加一个新的层，如果你得到了额外的添加层。</p></li><li><p>确保这个新的（N+1）层学习网络新知识的一种方法是同时提供输入（x），而无需对第（N+1）层的输出进行任何转换。这本质上驱动新层学习与输入已经编码的内容不同的内容。</p></li><li><p>另一个优点是这种连接有助于处理非常深的网络中的消失梯度问题。</p></li></ul></li><li><p>有了残差块，我们现在可以得到任何深度的深度神经网络，而不用担心我们无法优化网络。</p></li><li><p>ResNet在具有大量层的情况下开始使用类似于Inception瓶颈的瓶颈层(即1x1核)来降低维数。</p><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/07.jpg" alt></li></ul></li><li><p><strong><u>完整的ResNet架构</u></strong>:</p><ul><li>残差块堆积.<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/08.png" alt></li></ul></li><li>每个剩余块有两个3 x 3 conv层。</li><li>开始时的附加转换层</li><li>结尾没有FC层（只有FC 1000到输出类）</li><li>周期性地，两倍数量的过滤器和使用步长2（每个维度中的/2）在空间上进行下采样</li><li>ResNet实践培训:<ul><li>每层转换后Batch Normalization.</li><li>来自He等人的Xavier/2初始化.</li><li>SGD + Momentum (<code>0.9</code>) </li><li>Learning rate: 0.1, 当验证误差稳定时除以10</li><li>Mini-batch size <code>256</code></li><li>Weight decay of <code>1e-5</code></li><li>No dropout used.</li></ul></li></ul></li></ul></li><li><p><a href="https://arxiv.org/abs/1602.07261" target="_blank" rel="noopener">Inception-v4</a>: Resnet + Inception and was founded in 2016.</p></li><li><p>所有体系结构的复杂性：</p><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/09.png" alt></li><li>VGG:最高的内存，最多的操作.</li><li>GoogLeNet: 效率最高.</li></ul></li><li><p><strong>ResNets 改进</strong>:</p><ul><li>(<a href="https://arxiv.org/abs/1603.05027" target="_blank" rel="noopener">2016</a>) <u>深剩余网络中的恒等映射</u><ul><li>来自ResNet的创造者.</li><li>提供更好的性能。</li></ul></li><li>(<a href="https://arxiv.org/abs/1605.07146" target="_blank" rel="noopener">2016</a>) <u>宽残差网络</u><ul><li>认为残差是重要因素，而不是深度</li><li>50层宽ResNet优于152层原始ResNet</li><li>增加宽度而不是深度更有效地计算（可并行化）</li></ul></li><li>(<a href="https://arxiv.org/abs/1603.09382" target="_blank" rel="noopener">2016</a>) 深度随机网络<ul><li>动机：在训练过程中通过短网络减少消失梯度和训练时间。</li><li>在每一次训练过程中随机放下一个子集的图层</li><li>在测试时使用全深度网络。</li></ul></li></ul></li><li><p><strong>超越 ResNets</strong>:</p><ul><li>(<a href="https://arxiv.org/abs/1605.07648" target="_blank" rel="noopener">2017</a>) <u>分形网络：无残差的超深神经网络</u><ul><li>认为关键是要有效地从浅层过渡到深层，不需要残差表示。.</li><li>通过退出子路径训练</li><li>测试时全网。</li></ul></li><li>(<a href="https://arxiv.org/abs/1608.06993" target="_blank" rel="noopener">2017</a>) <u>密接卷积网络</u></li><li>(<a href="https://arxiv.org/abs/1602.07360" target="_blank" rel="noopener">2017</a>) SqueezeNet:AlexNet级精度，参数减少50倍，型号尺寸&lt;0.5Mb<ul><li>有利于生产</li><li>它是对ResNet和Inception中的许多概念的重新散列，并表明，毕竟，一个更好的架构设计将提供较小的网络规模和参数，而不需要复杂的压缩算法。</li></ul></li></ul></li><li><p>结论:</p><ul><li>ResNet当前最佳默认值</li><li>网络极深的趋势</li><li>在过去的几年里，一些模型都使用像“ResNet”这样的快捷方式来改变梯度。</li></ul></li></ul><h2 id="10-Recurrent-Neural-networks"><a href="#10-Recurrent-Neural-networks" class="headerlink" title="10. Recurrent Neural networks"></a>10. Recurrent Neural networks</h2><ul><li>Vanilla 神经网络给神经网络“输入”，固定大小的输入经过一些隐藏单元，然后输出。我们称之为一对一网络。</li><li><p>递归神经网络RNN模型:</p><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/46.png" alt></li><li>一对多<ul><li>示例：图像字幕<ul><li>图像==&gt;单词序列</li></ul></li></ul></li><li>多对一<ul><li>示例：情绪分类<ul><li>词序==&gt;情感</li></ul></li></ul></li><li>多对多<ul><li>示例：机器翻译<ul><li>一种语言的单词序列==&gt;另一种语言的单词序列</li></ul></li><li>示例：帧级视频分类</li></ul></li></ul></li><li><p>RNN也可以用于非序列数据（一对一问题）</p><ul><li>它通过采取一系列“瞥见”的方式进行了数字分类<ul><li>“<a href="https://arxiv.org/abs/1412.7755" target="_blank" rel="noopener">视觉注意下的多目标识别</a>”, ICLR 2015.</li></ul></li><li>它致力于一次生成一幅图像<ul><li>比如生成 <a href="http://ieeexplore.ieee.org/document/7966808/" target="_blank" rel="noopener">验证码</a></li></ul></li></ul></li><li><p>那么什么是递归神经网络?</p><ul><li><p>接收输入x的循环核心单元，该单元具有每次读取输入时更新的内部状态。</p></li><li><p><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/47.png" alt></p></li><li><p>RNN块应该返回一个向量</p></li><li><p>我们可以通过在每个时间步应用递归公式来处理向量x序列：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[t] = fw (h[t<span class="number">-1</span>], x[t])</span><br><span class="line"><span class="comment"># Where fw is some function with parameters W</span></span><br></pre></td></tr></table></figure><ul><li>每个时间步使用相同的函数和相同的参数集。</li></ul></li><li><p>(Vanilla) Recurrent Neural Network:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">h[t] &#x3D; tanh (W[h,h]*h[t-1] + W[x,h]*x[t])   </span><br><span class="line"># Then we save h[t]</span><br><span class="line">y[t] &#x3D; W[h,y]*h[t]</span><br></pre></td></tr></table></figure><ul><li>这是RNN最简单的例子。</li></ul></li><li><p>RNN处理一系列相关数据。</p></li></ul></li><li><p>递归神经网络计算图:</p><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/10.png" alt></li><li><code>h0</code>初始化为零</li><li>梯度W是所有已计算的W梯度之和</li><li>多对多图<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/11.png" alt></li><li>最后一个是所有损失的和，Y的权重是1，通过求和所有梯度来更新</li></ul></li><li>多对一图<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/12.png" alt></li></ul></li><li>一对多图<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/13.png" alt></li></ul></li><li>序列到图形<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/14.png" alt></li><li>编码器和解码器原理。</li></ul></li></ul></li><li><p>例子:</p><ul><li>假设我们使用字符来构建单词 。我们需要一个模型来预测序列的下一个特征。假设字符只有[h，e，l，o]，单词是[hello]<ul><li>训练:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/15.png" alt></li><li>这里只有第三个预言是正确的。损失需要优化。</li><li>我们可以通过输入整个单词来训练网络。</li></ul></li><li>测试:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/16.png" alt></li><li>在测试时，我们逐个处理。输出字符将是下一个输入，其他已保存的隐藏激活。</li><li>这个<a href="https://gist.github.com/karpathy/d4dee566867f8291f086" target="_blank" rel="noopener">链接</a> 包含了所有的代码，但是使用了截短的反向传播，正如我们将要讨论的那样。</li></ul></li></ul></li></ul></li><li><p>反向传播通过时间向前通过整个序列来计算损耗，然后反向通过整个序列来计算梯度。</p><ul><li>但如果我们选择整个序列，它将是如此缓慢，占用大量内存，永远不会收敛！</li></ul></li><li><p>所以在实践中，人们做的是“通过时间截短的反向传播”，我们继续向前和向后运行序列的块，而不是整个序列</p><ul><li>然后将隐藏状态永远向前推进，但只对一些较小的步骤进行反向传播。</li></ul></li><li><p>图像字幕示例:</p><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/17.png" alt></li><li>他们用代币来完成跑步。</li><li>最大的图片字幕数据集是微软COCO</li></ul></li><li><p>注意图像字幕是一个项目，在这个项目中，RNN在生成字幕时，会看到图像的特定部分，而不是整个图像。</p><ul><li>在“视觉答疑”问题中也采用了带注意的图像字幕技术</li></ul></li><li><p>多层rnn通常使用一些层作为隐藏层，这些层被再次馈入。<strong>LSTM</strong>是一个多层RNN。</p></li><li><p>可能会以反方向消失。爆炸是通过渐变剪裁控制的。消失由加性相互作用控制（LSTM）</p></li><li><p>LSTM代表长时短时记忆。它的目的是帮助解决RNNs上的消失梯度问题。</p><ul><li>它包括:<ul><li>f: Forget gate, 是否删除单元格</li><li>i: Input gate, 是否写入单元格</li><li>g: Gate gate (?), 写多少个单元格</li><li>o: Output gate, 输出多少个单元格</li></ul></li><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/18.png" alt></li><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/18.1.png" alt></li><li>像ResNet一样，LSTM梯度很容易计算</li><li>LSTM将数据保存在长或短内存中，因为它训练意味着它不仅可以记住最后一层的内容，而且可以记住各个层的内容</li></ul></li><li><p>公路网是介于ResNet和LSTM之间的东西，目前仍在研究中。</p></li><li><p>更好/更简单的体系结构是当前研究的热点</p></li><li><p>需要更好的理解（理论和经验）</p></li><li><p>RNN用于更多地使用相关输入序列的问题。比如NLP和语音识别。</p></li></ul><h2 id="11-Detection-and-Segmentation"><a href="#11-Detection-and-Segmentation" class="headerlink" title="11. Detection and Segmentation"></a>11. Detection and Segmentation</h2><ul><li><p>到目前为止，我们讨论的是图像分类问题。在本节中，我们将讨论分割、定位和检测。</p></li><li><p><strong><u>语义切分(Semantic Segmentation)</u></strong></p><ul><li><p>我们想用分类标签来标记图像中的每个像素。</p></li><li><p><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/19.png" alt></p></li><li><p>当你看到图像中的奶牛时，语义分割并不区分实例，只关心像素。</p></li><li><p>第一个想法是使用<strong>滑动窗口</strong>。我们取一个小尺寸的窗口，把它滑到整个画面上。对于每个窗口，我们要标记中心像素。</p><ul><li>它可以工作，但这不是一个好主意，因为它的计算成本很高</li><li>效率很低！不重复使用重叠修补程序之间的共享功能</li><li>实际上没人用这个</li></ul></li><li><p>第二个想法是将一个网络设计成一组卷积层，以便一次对像素进行预测！</p><ul><li>输入是整个图像。输出是每个像素标记的图像。</li><li>我们需要很多标签数据。而且数据非常昂贵。</li><li>它需要很深的卷积层。</li><li>损失是提供的每个像素之间的交叉熵。</li><li>数据扩充在这里很好。</li><li>这种实现的问题是原始图像分辨率下的卷积将非常昂贵。</li><li>所以在实践中，我们现在还没有看到这样的情况。</li></ul></li><li><p>第三个想法是基于最后一个想法。不同的是，我们在网络内部进行下采样和上采样。</p><ul><li><p>我们下采样是因为使用整个图像是非常昂贵的。所以我们在最后进行了多层下采样和上采样。</p></li><li><p>下采样是一种类似于池化和跨步卷积的操作。.</p></li><li><p>Upsampling is like “Nearest Neighbor” or “Bed of Nails” or “Max unpooling”</p><ul><li><p><strong>Nearest Neighbor</strong> example:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:   1  2               Output:   1  1  2  2</span><br><span class="line">         3  4                         1  1  2  2</span><br><span class="line">                                      3  3  4  4</span><br><span class="line">                                      3  3  4  4</span><br></pre></td></tr></table></figure></li><li><p><strong>Bed of Nails</strong> example:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:   1  2               Output:   1  0  2  0</span><br><span class="line">         3  4                         0  0  0  0</span><br><span class="line">                                      3  0  4  0</span><br><span class="line">                                      0  0  0  0</span><br></pre></td></tr></table></figure></li><li><p><strong>Max unpooling</strong> 取决于Max pooling之前的步骤。填充发生最大池化的像素，然后用零填充其他像素。</p></li></ul></li><li><p>Max unpooling似乎是上采样的最佳方法。</p></li><li><p>有一种可学习的上采样的想法叫做 “<strong>Transpose Convolution</strong>“</p><ul><li>我们做的不是卷积，而是相反。</li><li>也叫做:<ul><li>上卷积(Upconvolution)</li><li>分步卷积(Fractionally strided convolution)</li><li>后跨步卷积(Backward strided convolution)</li></ul></li><li>学习上采样的艺术性请参考<a href="https://arxiv.org/abs/1603.07285" target="_blank" rel="noopener">此文章</a>第四章.</li></ul></li></ul></li></ul></li><li><p><strong><u>Classification + Localization</u></strong>:</p><ul><li>在这个问题中，我们希望将图像中的主要对象及其位置分类为矩形。</li><li>我们假设有一个物体。</li><li>我们将创建一个多任务NN。体系结构如下:<ul><li>卷积网络层连接到<ul><li>对对象进行分类的FC层. <code># 我们知道的简单分类问题</code></li><li>连接到四个数字<code>（x、y、w、h）</code>的FC层<ul><li>我们将本地化(Localization)视为一个回归问题。</li></ul></li></ul></li></ul></li><li>这个问题会有两个损失:<ul><li>Softmax分类损失</li><li>局部回归（线性损失）（L2损失）</li></ul></li><li>Loss = SoftmaxLoss + L2 loss</li><li>通常，第一个Conv层是像AlexNet一样经过预训练的nn!</li><li>这种技术可以应用于许多其他问题，如：人体姿态估计。</li></ul></li><li><p><strong><u>Object Detection</u></strong></p><ul><li>计算机视觉的核心思想。我们将详细讨论这个问题。</li><li>“分类+定位”和这个问题的区别在于，我们要检测一个或多个不同的对象及其位置</li><li>第一个想法是使用滑动窗口<ul><li>干得好但是时间长</li><li>步骤是:<ul><li>将CNN应用于图像的许多不同裁剪，CNN将每种裁剪分类为对象或背景。</li></ul></li><li>问题是我们需要将CNN应用于大量的位置和规模，计算非常昂贵</li><li>成千上万的人会用上千次的蛮力来滑动窗口</li></ul></li><li>区域建议将帮助我们决定在哪个区域运行NN:<ul><li>查找可能包含对象的滴状(blobby)图像区域</li><li>运行速度相对较快；例如，选择性搜索在CPU上几秒钟内提供1000个区域建议</li></ul></li><li>所以现在我们可以应用其中一个区域提案网络，然后应用第一个想法</li><li>还有一个想法叫做R-CNN<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/20.png" alt></li><li>这个想法是不好的，因为它将图像的一部分——包括区域建议——如果大小不同，在将它们全部缩放到一个尺寸后，将其提供给CNN。缩放不好</li><li>而且他非常缓慢</li></ul></li><li>快速R-CNN是在R-CNN上发展起来的另一个想法<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/48.png" alt></li><li>它用一个CNN来做任何事情。</li></ul></li><li>Faster R-CNN 通过插入区域建议网络（RPN）来根据特征预测提案，从而完成自己的区域提案。<ul><li>最快的R-CNNs.</li></ul></li><li>另一个想法是没有建议的检测: YOLO / SSD<ul><li>YOLO 代表你只看一次.</li><li>YOLO/SDD 是两个独立的算法</li><li>速度更快但不够准确。</li></ul></li><li>Takeaways<ul><li>Faster R-CNN速度较慢，但更准确。</li><li>SSD/YOLO 速度快得多，但不够准确</li></ul></li></ul></li><li><p><strong><u>Denese Captioning</u></strong></p><ul><li>Denese Captioning is “Object Detection + Captioning”</li><li>关于这个想法的<a href="https://arxiv.org/abs/1511.07571" target="_blank" rel="noopener">论文</a>可以在这里找到.</li></ul></li><li><p><strong><u>实例分割(Instance Segmentation)</u></strong></p><ul><li>问题就是这样</li><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/49.png" alt></li><li>我们不想预测边界框，而是想知道哪个像素标签，同时还要区分它们。</li><li>有很多想法</li><li>有一个新的想法”Mask R-CNN”<ul><li>像R-CNN一样，但在它里面我们应用了语义分割</li><li>这篇论文有很多很好的结果。</li><li>它总结了我们在这堂课上讨论过的所有事情</li><li>这方面的表现似乎不错。</li></ul></li></ul></li></ul><h2 id="12-Visualizing-and-Understanding"><a href="#12-Visualizing-and-Understanding" class="headerlink" title="12. Visualizing and Understanding"></a>12. Visualizing and Understanding</h2><ul><li><p>我们想知道ConvNets内部发生了什么？</p></li><li><p>人们希望相信黑匣子（CNN）并知道它是如何工作的，并做出正确的决定。</p></li><li><p>第一种方法是可视化第一层的过滤器</p><ul><li>可能第一层过滤器的形状是5×5×3，过滤器的数量是16。然后我们将有16个不同的“彩色”过滤器图像。</li><li>事实证明，这些过滤器像人脑一样学习原始形状和定向边缘。</li><li>这些过滤器在你将要训练的每个Conv网络上看起来都是一样的，例如如果你试图从AlexNet、VGG、GoogleNet或ResNet获取它。</li><li>这将告诉您第一个卷积层在图像中寻找什么。</li></ul></li><li><p>我们可以看到下一层的过滤器，但它们不会告诉我们任何信息。</p><ul><li>第一层过滤器的形状可能是5×5×20，过滤器的数量是16。然后我们将有16*20个不同的“灰色”滤镜图像。</li></ul></li><li><p>在AlexNet，最后有一些FC层。如果我们取4096维特征向量作为图像，并收集这些特征向量。</p><ul><li>如果我们在这些特征向量之间建立一个最近的邻域，并得到这些特征的真实图像，那么与直接在图像上运行KNN相比，我们将得到非常好的结果！</li><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/21.png" alt></li><li>这种相似性告诉我们，这些cnn真正获得的是这些图像的语义，而不是像素级的语义！</li><li>我们可以对4096维特征进行降维，并将其压缩到二维。<ul><li>这可以通过PCA或t-SNE来实现。</li><li>t-SNE更多地与深度学习一起用于可视化数据。可以在<a href="http://cs.stanford.edu/people/karpathy/cnnembed/" target="_blank" rel="noopener">这里</a>找到示例</li></ul></li></ul></li><li><p>我们可以看到激活图</p><ul><li>例如，如果CONV5功能图是128 x 13 x 13，我们可以将其可视化为128 13 x 13灰度图像。</li><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/50.png" alt></li><li>其中的一个特性是根据输入激活的，所以现在我们知道这个特定的映射正在寻找一些东西。</li><li>这是由吉辛斯基等人(Yosinski et.)完成的。更多信息在<a href="http://yosinski.com/deepvis#toolbox" target="_blank" rel="noopener">这里</a>。</li></ul></li><li><p>有一种叫做最大激活补丁(<strong>Maximally Activating Patches</strong>)的东西可以帮助我们可视化Convnets中的中间特性</p><ul><li>这样做的步骤如下:<ul><li>我们先选择一层神经元<ul><li>例如，我们在AlexNet中选择Conv5，它是128 x 13 x 13，然后选择通道（神经元）17/128</li></ul></li><li>通过网络运行许多图像，记录所选频道的值</li><li>可视化对应于最大激活的图像块<ul><li>我们会发现每个神经元都在观察图像的特定部分</li><li>利用感受野(eceptive field)提取(Extract)图像</li></ul></li></ul></li></ul></li><li><p>另一个想法是遮挡实验(<strong>Occlusion Experiments</strong>)</p><ul><li>我们将图像的一部分蒙版后再输入CNN，在每个掩模位置绘制概率热图（输出为真）</li><li>它将给你形象中最重要的部分，从中我们学习到了。</li><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/51.png" alt></li></ul></li><li><p>显著性映射(<strong>Saliency Maps</strong>)指出哪些像素对分类很重要</p><ul><li>类似于遮挡实验，但使用了完全不同的方法</li><li>我们计算（未规范化）类分数相对于图像像素的梯度，在RGB通道上取绝对值和最大值。它会给我们一个灰色的图像，代表图像中最重要的区域。</li><li>这有时可以用于语义分割。</li></ul></li><li><p>（引导的）backprop可以最大限度地激活补丁(<strong>Maximally Activating Patches</strong>)，但不同的是，它能获得我们所关心的像素。</p><ul><li>在该方法中，选择一个最大激活块的通道，然后计算神经元值相对于图像像素的梯度</li><li>如果您只通过每个RELU反向投影正渐变（guided backprop），图像会变得更好</li></ul></li><li><p>坡度上升(<strong>Gradient Ascent</strong>)</p><ul><li><p>生成一个最大限度地激活神经元的合成图像。</p></li><li><p>反向坡度下降。不是取最小值而是取最大值。</p></li><li><p>我们想用输入图像最大化神经元。因此，我们在这里尝试学习使激活最大化的图像：</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># R（I）是自然图像正则化器，f（I）是神经元值</span></span><br><span class="line">I *= argmax(f(I)) + R(I)</span><br></pre></td></tr></table></figure></li><li><p>坡度上升的步骤</p><ul><li>将图像初始化为零.</li><li>传播图像以计算当前分数。</li><li>Backprop获取神经元值相对于图像像素的梯度</li><li>对图像做一个小的更新</li></ul></li><li><p><code>R(I)</code> 可能等于生成图像的L2</p></li><li><p>为了得到更好的结果，我们使用了一个更好的正则化器:</p><ul><li>惩罚图像的L2范数；也在周期性优化期间:<ul><li>高斯模糊图像</li><li>将小值的像素剪裁为0</li><li>将小梯度的像素剪裁为0</li></ul></li></ul></li><li><p>一个更好的正则化器使图像更干净</p></li><li><p><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/22.png" alt></p></li><li><p>后一层的结果似乎比其他层更有意义</p></li></ul></li><li><p>我们可以用这个程序愚弄CNN:</p><ul><li>从任意图像开始.            <code># 无根据的随机图片</code></li><li>选择任意类 <code># Random class</code></li><li>修改图像以最大化类</li><li>重复，直到网络被愚弄。</li></ul></li><li><p>愚弄网络的结果令人惊讶</p><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/23.png" alt></li><li>对于人眼来说，它们是一样的，但它只是通过添加一些噪音来愚弄网络</li></ul></li><li><p><strong>DeepDream</strong>: 扩大现有功能(Amplify existing features)</p><ul><li>谷歌在他们的网站上发布了DeepDream</li><li>它的实际操作与我们讨论过的愚弄神经网络的过程是一样的，但不是合成一个图像来最大化特定的神经元，而是试图放大网络中某一层的神经元激活。</li><li>Steps:<ul><li>Forward: 计算所选层的激活.        <code># form an input image (Any image)</code></li><li>设置所选层的梯度等于其激活.<ul><li>相当于<code>I* = arg max[I] sum(f(I)^2)</code></li></ul></li><li>Backward: 计算图像的梯度</li><li>更新图像.</li></ul></li><li>deep dream 的代码是在线的，你可以自己下载和检查yourself.</li></ul></li><li><p>特征反演(<strong>Feature Inversion</strong>)</p><ul><li>让我们知道不同层次的网络元素被捕捉到了什么</li><li>给定一个图像的CNN特征向量，找到一个新的图像<ul><li>匹配给定的特征向量</li><li>看起来自然（图像优先正则化）</li></ul></li></ul></li><li><p>纹理合成(<strong>Texture Synthesis</strong>)</p><ul><li>计算机图形学中的老问题。</li><li>给定一个纹理的样本块，我们能生成一个更大的相同纹理的图像吗</li><li>有一种算法不依赖于神经网络:<ul><li>Wei and Levoy, 基于树结构矢量量化的快速纹理合成，SIGGRAPH 2000</li><li>这是一个非常简单的算法</li></ul></li><li>这里的想法是，这是一个老问题，有很多算法已经解决了这个问题，但是简单的算法在复杂的纹理上效果不佳</li><li>2015年提出了一种基于梯度上升的神经网络方法，称之为“神经纹理合成”<ul><li>它依赖于一种叫做Gram矩阵的东西。</li></ul></li></ul></li><li><p>Neural Style Transfer =  Feature + Gram Reconstruction</p><ul><li>Gatys, Ecker, and Bethge, 使用卷积神经网络的图像风格传输(Image style transfer using Convolutional neural<br>networks)，CVPR 2016</li><li>Implementation by pytorch <a href="https://github.com/jcjohnson/neural-style" target="_blank" rel="noopener">here</a>.</li></ul></li><li><p>风格转换需要许多向前/向后通过VGG；非常慢</p><ul><li>训练另一个神经网络为我们进行风格转换</li><li>快速风格转换是解决方案</li><li>Johnson, Alahi, and Fei-Fei, 实时风格转换和超分辨率感知损失(Perceptual Losses for Real-Time Style Transfer and Super-Resolution)，ECCV 2016</li><li><a href="https://github.com/jcjohnson/fast-neural-style" target="_blank" rel="noopener">https://github.com/jcjohnson/fast-neural-style</a></li></ul></li><li><p>有很多关于这种风格转换的工作，而且一直持续到现在</p></li><li><p>总结:</p><ul><li>Activations: 最近邻，降维，最大面片，遮挡( Nearest neighbors, Dimensionality reduction, maximal patches,<br>occlusion)</li><li>Gradients: 显著图，类可视化，愚弄图像，特征反演(Saliency maps, class visualization, fooling images, feature inversion)</li><li>Fun: 深度梦想，风格转换(DeepDream, Style Transfer)</li></ul></li></ul><h2 id="13-Generative-models"><a href="#13-Generative-models" class="headerlink" title="13. Generative models"></a>13. Generative models</h2><ul><li><p>生成模型是一种无监督学习</p></li><li><p>有监督vs无监督学习:</p></li></ul><div class="table-container"><table><thead><tr><th></th><th>有监督学习</th><th>无监督学习</th></tr></thead><tbody><tr><td>数据结构</td><td>Data: (x, y), x是数据，y是标签</td><td>Data: x, 只有数据，没有标签！</td></tr><tr><td>数据代价</td><td>在很多情况下，培训数据是昂贵的。</td><td>训练数据很便宜！</td></tr><tr><td>目标</td><td>学习映射x-&gt;y的函数</td><td>了解一些隐藏的数据结构</td></tr><tr><td>例子</td><td>分类，回归，目标检测，语义分割，图像字幕</td><td>聚类，降维，特征学习，密度估计</td></tr></tbody></table></div><ul><li><p>自动编码器是一种特征学习技术。</p><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/24.png" alt></li><li>它包含一个编码器和一个解码器。编码器对图像进行降采样，而解码器对特征进行上采样。</li><li>损失为L2损失。</li></ul></li><li><p>密度估计是我们要学习/估计数据的底层分布的地方</p></li><li><p>与有监督学习相比，无监督学习还存在许多研究性开放性问题！</p></li><li><p>生成模型(<strong>Generative Models</strong>)</p><ul><li>给定训练数据，从同一分布生成新样本。</li><li>解决了无监督学习中的一个核心问题——密度估计。</li><li>我们有不同的方法：<ul><li>显式密度估计：明确定义和求解学习模型</li><li>学习模型，它可以从学习模型中进行采样，而无需显式地定义它</li></ul></li><li>为什么是生成模型<ul><li>艺术作品、超分辨率、彩色化等的逼真样品</li><li>时间序列数据的生成模型可用于模拟和规划（强化学习应用程序！）</li><li>训练生成模型还可以推理潜在的表示，这些表示可以作为一般特征有用</li></ul></li><li>生成模型分类法:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/52.png" alt></li></ul></li><li>在这节课中，我们将讨论: PixelRNN/CNN, 变分自动编码器和GANs，因为它们是目前研究中流行的模型。</li></ul></li><li><p><strong>PixelRNN</strong> and <strong>PixelCNN</strong></p><ul><li>在完全可见的信念网络中，我们使用链式规则将图像x的似然分解为一维分布的乘积<ul><li><code>p(x) = sum(p(x[i]| x[1]x[2]....x[i-1]))</code></li><li>其中p（x）是图像x的可能性，x[i]是给定所有先前像素的第i个像素值的概率。</li></ul></li><li>为了解决这个问题，我们需要最大化训练数据的可能性，但是像素值的分布非常复杂。</li><li>我们还需要定义先前像素的顺序。</li><li>PixelRNN<ul><li>Founded by [van der Oord et al. 2016]</li><li>对使用RNN（LSTM）建模的先前像素的依赖性</li><li>从角点开始生成图像像素</li><li>缺点：顺序生成速度慢！因为你必须逐像素地生成</li></ul></li><li>PixelCNN<ul><li>Also Founded by [van der Oord et al. 2016]</li><li>仍然生成从角开始的图像像素。</li><li>对先前像素的依赖现在使用CNN的上下文区域建模</li><li>训练比pixerlnn快（可以并行卷积，因为从训练图像知道上下文区域值）</li><li>生成仍然必须循序渐进，仍然缓慢。</li></ul></li><li>有一些技巧需要改进 PixelRNN &amp; PixelCNN.</li><li>PixelRNN and PixelCNN 能产生良好的样本，目前仍是研究的活跃领域。</li></ul></li><li><p><strong>Autoencoders</strong></p><ul><li>无监督方法从未标记的训练数据中学习低维特征表示。</li><li>由编码器和解码器组成。</li><li>编码器:<ul><li>将输入x转换为特性z。z应小于x才能从输入中获取重要值。我们可以称之为降维。</li><li>编码器可以用:<ul><li>线性或非线性层(earlier days days)</li><li>Deep fully connected NN (Then)</li><li>RELU CNN (Currently we use this on images)</li></ul></li></ul></li><li>解码器:<ul><li>我们希望编码器映射我们已经产生的特性，以输出类似于x或相同x的东西。</li><li>解码器可以用同样的技术，我们做编码器，目前它使用一个RELU CNN。</li></ul></li><li>编码器是conv层，而解码器是deconv层！意思是先降后升。</li><li>损失函数为L2损失函数:<ul><li><code>L[i] = |y[i] - y&#39;[i]|^2</code><ul><li>经过训练，我们把解码器拆掉了.<code># 现在我们有了我们需要的功能</code></li></ul></li></ul></li><li>我们可以用这个编码器我们要做一个有监督的模型<ul><li>这一点的价值在于它可以学习到一个好的特征来表示你所拥有的输入</li><li>很多时候我们会有少量的数据来解决问题。解决这个问题的一个方法是使用一个自动编码器来学习如何从图像中获取特征，并在模型上训练你的小数据集</li></ul></li><li>问题是我们能从这个自动编码器生成数据（图像）吗</li></ul></li><li><p>变分自动编码器<strong>Variational Autoencoders (VAE)</strong></p><ul><li>自动编码器上的概率自旋-将让我们从模型中取样生成数据</li><li>我们将z作为使用编码器形成的特征向量。</li><li>然后我们选择先验p（z）是简单的，例如高斯。<ul><li>合理的隐藏属性：例如姿势，微笑的程度。</li></ul></li><li>条件p（x | z）是复杂的（生成图像）=&gt;用神经网络表示</li><li>但是我们不能用下面的方程来计算P（z）P（x | z）dz的积分:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/25.png" alt></li></ul></li><li>在解决了最后一个方程的所有方程之后，我们应该:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/26.png" alt></li></ul></li><li>变分自动编码器是生成模型的一种方法，但与最先进的（GANs）相比，样本更模糊，质量更低</li><li>活跃的研究领域:<ul><li>更灵活的近似，例如更丰富的后验近似，而不是对角高斯</li><li>在潜在变量中加入结构</li></ul></li></ul></li><li><p>生成性对抗网络<strong>Generative Adversarial Networks (GANs)</strong></p><ul><li><p>GAN不适用于任何明确的密度函数</p></li><li><p>首先，采取博弈论的方法：通过两人博弈，从训练分配中学习生成。</p></li><li><p>在Facebook负责人工智能研究的Yann LeCun称GANs:</p><ul><li><blockquote><p>近20年来深度学习中最酷的想法</p></blockquote></li></ul></li><li><p>问题：想从复杂的、高维的培训分布中取样。我们已经讨论过了，没有直接的方法！</p></li><li><p>解决方案：从简单分布中取样，例如随机噪声。学习向培训分配的转变。</p></li><li><p>因此，我们创建一个噪声图像，从简单的分布中提取出来，将其馈送给神经网络，我们将其称为一个发电机网络，应该学会将其转换成我们想要的分布。</p></li><li><p>Training GANs: Two-player game:</p><ul><li><strong>Generator network</strong>: 试图通过生成真实感图像来愚弄鉴别器</li><li><strong>Discriminator network</strong>: 试着区分真假图像。</li></ul></li><li><p>如果我们能够很好地训练鉴别器，那么我们就可以训练生成器生成正确的图像。</p></li><li><p>这里给出了GANs作为极小极大对策的损失函数</p><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/27.png" alt></li></ul></li><li><p>生成器网络的标签为0，实际图像为1。</p></li><li><p>为了训练我们的网络:</p><ul><li>鉴别器上的梯度上升。</li><li>生成器上的梯度上升，但损耗不同。</li></ul></li><li><p>你可以在这里阅读完整的算法和方程式</p><ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/28.png" alt></li></ul></li><li><p>旁白：联合培养两个网络是有挑战性的，可以是不稳定的。选择具有更好损失景观的目标有助于培训是一个活跃的研究领域。</p></li><li><p>卷积结构(Convolutional Architectures):</p><ul><li>生成器是一个上采样网络的分数阶跃卷积鉴别器是一个卷积网络。</li><li>稳定深部Conv-GANs指南:<ul><li>用跨步卷积（鉴别器）替换任何池层，用（生成器）替换部分跨步卷积</li><li>对两个网络使用批处理规范</li><li>移除完全连接的隐藏层以获得更深层的架构。</li><li>在生成器中对所有层使用RELU激活，除了使用Tanh的输出</li><li>所有层在鉴别器中使用leaky RELU</li></ul></li></ul></li><li><p>2017年是GANS年！它爆炸了，有一些非常好的结果</p></li><li><p>研究的活跃领域也是GANs的各种应用领域。</p></li><li><p>可以在这里找到 GAN zoo: <a href="https://github.com/hindupuravinash/the-gan-zoo" target="_blank" rel="noopener">https://github.com/hindupuravinash/the-gan-zoo</a></p></li><li><p>使用GANs的提示和技巧: <a href="https://github.com/soumith/ganhacks" target="_blank" rel="noopener">https://github.com/soumith/ganhacks</a></p></li><li><p>NIPS 2016 GANS教程: <a href="https://www.youtube.com/watch?v=AJVyzd0rqdc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=AJVyzd0rqdc</a></p></li></ul></li></ul><h2 id="14-Deep-reinforcement-learning"><a href="#14-Deep-reinforcement-learning" class="headerlink" title="14. Deep reinforcement learning"></a>14. Deep reinforcement learning</h2><ul><li>这一节包含了很多数学知识。</li><li>强化学习问题涉及到一个智能体与一个环境的交互作用，它提供了数字奖励信号。</li><li>步骤是:<ul><li>Environment —&gt; State <code>s[t]</code> —&gt; Agent —&gt; Action <code>a[t]</code> —&gt; Environment —&gt; <code>Reward r[t]</code> + Next state <code>s[t+1]</code> —&gt; Agent —&gt; and so on..</li></ul></li><li>我们的目标是学习如何采取行动以获得最大的回报。</li><li>机器人移动就是一个例子:<ul><li>目标：使机器人向前移动</li><li>状态：关节的角度和位置</li><li>行为：施加在接头上的扭矩</li><li>每次1步直立+向前移动</li></ul></li><li>另一个例子是Atari Games：<ul><li>深度学习在这个问题上有着很好的研究现状。</li><li>目标：以最高分数完成游戏。</li><li>状态：游戏状态的原始像素输入。</li><li>行为：游戏控制，如左、右、上、下</li><li>奖励：每一个时间步增加/减少分数</li></ul></li><li>围棋游戏是AlphaGo团队在去年（2016年）赢得的又一个例子，这对于人工智能和深度学习来说是一个巨大的成就，因为问题太难了。</li><li>利用马尔可夫决策过程(<u><strong>Markov Decision Process</strong></u>)，我们可以在数学上表示强化学习</li><li>马尔可夫决策过程(<strong>Markov Decision Process</strong>)<ul><li>由（S，A，R，P，Y）定义，其中<ul><li><code>S</code>: set of possible states.</li><li><code>A</code>: set of possible actions</li><li><code>R</code>: distribution of reward given (state, action) pair</li><li><code>P</code>: 转移概率，即下一状态给定（状态，动作）对的分布</li><li><code>Y</code>: discount factor    <code># 我们对即将到来的奖励有多重视，请稍后讨论</code></li></ul></li><li>算法:<ul><li>在时间步长t=0时，环境采样初始状态s[0]</li><li>然后，t=0直到完成:<ul><li>代理选择动作a[t]</li><li>R的环境样品奖励（s[t]，a[t]）</li><li>环境用（s[t]，a[t]）从P中采样下一个状态</li><li>代理人获得奖励r[t]和下一状态s[t+1]</li></ul></li></ul></li><li>策略pi是从S到A的函数，它指定在每个状态下要执行的操作</li><li>目标：找到使累计折扣奖励最大化的策略pi<em>: `Sum(Y^t </em> r[t], t&gt;0)`</li><li>例子:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/29.png" alt></li></ul></li><li>解决方案是:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/30.png" alt></li></ul></li></ul></li><li>状态s的值函数是从s状态遵循策略得到的预期累积回报:<ul><li><code>V[pi](s) = Sum(Y^t * r[t], t&gt;0) given s0 = s, pi</code></li></ul></li><li>状态s和行动a的Q值函数是在s状态下采取行动a，然后遵循策略所得到的预期累积回报:<ul><li><code>Q[pi](s,a) = Sum(Y^t * r[t], t&gt;0) given s0 = s,a0 = a, pi</code></li></ul></li><li>最优Q值函数Q*是给定（状态、动作）对所能达到的最大期望累积报酬:<ul><li><code>Q*[s,a] = Max(for all of pi on (Sum(Y^t * r[t], t&gt;0) given s0 = s,a0 = a, pi))</code></li></ul></li><li>贝尔曼方程(Bellman equation)<ul><li>重要的是RL</li><li>给定任何一个状态-动作对，这个对的值将是你将得到的回报r加上你结束的状态的值。</li><li><code>Q*[s,a] = r + Y * max Q*(s&#39;,a&#39;) given s,a  # 提示等式中没有策略</code></li><li>最优策略pi<em>对应于在Q指定的任何状态下采取最佳操作</em></li></ul></li><li>利用Bellman方程作为迭代更新的值迭代算法，可以得到最优策略<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/31.png" alt></li></ul></li><li>由于实际应用中空间维数巨大，我们将使用函数逼近器来估计Q（s，a）。E、 神经网络！这叫做Q学习(<strong>Q-learning</strong>)<ul><li>任何时候我们有一个复杂的函数，我们不能代表我们使用神经网络！</li></ul></li><li><strong>Q-learning</strong><ul><li>第一个解决RL的深度学习算法</li><li>使用函数逼近器估计动作值函数</li><li>如果函数逼近器是深度神经网络=&gt;深度q-学习</li><li>损失函数zh:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/32.png" alt></li></ul></li></ul></li><li>现在让我们考虑一下“玩雅达利游戏”的问题:<ul><li>我们的总奖励通常是我们在屏幕顶部看到的奖励。</li><li>Q网络体系结构:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/33.png" alt></li></ul></li><li>从成批的连续样本中学习是一个问题。如果我们记录了一个训练数据，并设置了神经网络来处理它，如果数据不够，我们将走向高偏差误差。因此，我们应该使用“经验回放”而不是连续的样本，在这种情况下，神经网络将不断尝试游戏，直到它掌握了它。</li><li>随着游戏（体验）情节的播放，不断更新转换（s[t]、a[t]、r[t]、s[t+1]）的回放记忆表。</li><li>从重放存储器中随机训练Q网络，而不是连续的样本。</li><li>完整算法:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/34.png" alt></li></ul></li><li>在这里可以找到演示Atari游戏算法的视频: “<a href="https://www.youtube.com/watch?v=V1eYniJ0Rnk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=V1eYniJ0Rnk</a>“</li></ul></li><li>政策梯度(<strong>Policy Gradients</strong>)<ul><li>解决RL的第二个深度学习算法。</li><li>Q函数的问题是Q函数可能非常复杂。<ul><li>机器人抓取物体的状态非常高维。</li><li>但政策可以简单得多：只需握紧你的手。</li></ul></li><li>我们是否可以直接学习策略，例如从一组策略中找到最佳策略？</li><li>政策梯度方程:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/35.png" alt></li></ul></li><li>收敛到J（ceta）的局部极小值，通常足够好</li><li>强化算法是一种能够得到/预测最优策略的算法</li><li>补强算法的方程与直观性:<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/36.png" alt></li><li>问题是这个方程的高方差，我们能解决吗？</li><li>方差缩减是一个活跃的研究领域！</li></ul></li><li>递归注意模型（RAM）是一种基于增强算法的图像分类算法:<ul><li>采取一系列的“瞥见”选择性地聚焦在图像的区域，以预测类<ul><li>灵感来自人类的感知和眼球运动。</li><li>节省计算资源=&gt;可伸缩性<ul><li>如果一个高分辨率的图像可以节省大量的计算</li></ul></li><li>能够忽略图像的杂乱/不相关部分</li></ul></li><li>RAM在许多任务中得到了广泛的应用：包括细粒度的图像识别、图像字幕和可视问答</li></ul></li><li>AlphaGo使用了监督学习和强化学习的混合，它也使用了策略梯度。</li></ul></li><li>斯坦福德关于深度强化学习的好课程<ul><li><a href="http://web.stanford.edu/class/cs234/index.html" target="_blank" rel="noopener">http://web.stanford.edu/class/cs234/index.html</a></li><li><a href="https://www.youtube.com/playlist?list=PLkFD6_40KJIwTmSbCv9OVJB3YaO4sFwkX" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLkFD6_40KJIwTmSbCv9OVJB3YaO4sFwkX</a></li></ul></li><li>深度强化学习好课程（2017）<ul><li><a href="http://rll.berkeley.edu/deeprlcourse/" target="_blank" rel="noopener">http://rll.berkeley.edu/deeprlcourse/</a></li><li><a href="https://www.youtube.com/playlist?list=PLkFD6_40KJIznC9CDbVTjAF2oyt8_VAe3" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLkFD6_40KJIznC9CDbVTjAF2oyt8_VAe3</a></li></ul></li><li>一篇好文章<ul><li><a href="https://www.kdnuggets.com/2017/09/5-ways-get-started-reinforcement-learning.html" target="_blank" rel="noopener">https://www.kdnuggets.com/2017/09/5-ways-get-started-reinforcement-learning.html</a></li></ul></li></ul><h2 id="15-Efficient-Methods-and-Hardware-for-Deep-Learning"><a href="#15-Efficient-Methods-and-Hardware-for-Deep-Learning" class="headerlink" title="15. Efficient Methods and Hardware for Deep Learning"></a>15. Efficient Methods and Hardware for Deep Learning</h2><ul><li>最初的讲座是由斯坦福大学的博士生宋晗做的。The original lecture was given by Song Han a PhD Candidate at standford.</li><li>深度转换网络、递归网络和深度强化学习正在形成许多应用程序，并改变了我们的生活。<ul><li>比如自动驾驶汽车，机器翻译，alphaGo等等。</li></ul></li><li>但现在的趋势是，如果我们想要高精度，我们需要更大（更深）的模型。<ul><li>2012年至2015年，ImageNet Competition的模型尺寸增加了16倍，以达到较高的精确度。</li><li>Deep speech 2的训练操作是Deep speech 1的10倍，而且这只需要一年！#在百度</li></ul></li><li>我们从中得到了三个挑战<ul><li><strong>模型尺寸(Model Size)</strong><ul><li>很难在我们的个人电脑、手机或汽车上部署更大的型号</li></ul></li><li><strong>速度(Speed)</strong><ul><li>ResNet152训练耗时1.5周，准确率为6.16%</li><li>长时间的培训限制了研究人员的生产力</li></ul></li><li><strong>能源效率(Energy Efficiency)</strong><ul><li>AlphaGo:1920个CPU和280个GPU。每场3000每元电费</li><li>如果我们在手机上使用它，它会耗尽电池电量。</li><li>谷歌在他们的博客中提到如果所有的用户使用谷歌语音3分钟，他们必须加倍他们的数据中心</li><li>能源消耗在哪里?<ul><li>更大的模型=&gt;更多的内存引用=&gt;更多的能量</li></ul></li></ul></li></ul></li><li>通过算法硬件协同设计，可以提高深度学习的效率。<ul><li>从硬件和算法的角度。</li></ul></li><li>Hardware 101: the Family<ul><li>General Purpose # Used for any hardware<ul><li>CPU                <code># 面向延迟，单一强线程，就像一个元素</code></li><li>GPU            <code># 面向吞吐量，所以很多小线程就像很多蚂蚁</code></li><li>GPGPU<ul><li>专业硬件(<strong>Specialized HW</strong>)        <code>#针对应用程序领域进行了调整</code><ul><li>现场可编程门阵列（field-programmable gate array）FPGA  <code>#可编程逻辑，它便宜但效率低</code></li><li>特定用途集成电路（Application Specific Integrated Circuit）ASIC <code># 固定逻辑，为特定应用而设计（可用于深度学习应用程序）</code></li></ul></li></ul></li></ul></li></ul></li><li>Hardware 101: 数字表示法（Number Representation）<ul><li>计算机中的数字用离散存储器表示。</li><li>在浮点运算中，硬件从32位变为16位是非常好和节能的。</li></ul></li><li>Part 1: 有效推理算法（<strong><u>Algorithms for Efficient Inference</u></strong>）<ul><li>修剪神经网络（<strong>Pruning neural networks</strong>）<ul><li>我们的想法是，我们可以去掉一些权重/神经元，而神经网络的行为仍然是一样的吗?</li><li>2015年，将AlexNet参数从6000万到600万！用修剪的方法。</li><li>剪枝可以应用于CNN和RNN中，迭代地达到与原始剪枝相同的精度。</li><li>修剪实际上发生在人类身上:<ul><li>新生儿（50万亿突触）==&gt; 1岁（1000万亿突触）==&gt; 青少年（500万亿突触）</li></ul></li><li>算法:<ol><li>得到训练的网络。</li><li>评估神经元的重要性</li><li>移除最不重要的神经元。</li><li>微调网络。</li><li>如果我们需要继续修剪，我们再次进入第2步，否则我们停止。</li></ol></li></ul></li><li>权重分担(<strong>Weight Sharing</strong>)<ul><li>我们的想法是，我们想让我们的模型数量更少。</li><li>训练量子化:<ul><li>示例：2.09、2.12、1.92、1.87的所有权重值将替换为2</li><li>为了做到这一点，我们可以使k均值聚类在一个过滤器上，并减少它的数目。通过使用此方法，我们还可以减少计算坡度所需的操作数。</li><li>经过训练的量化后，权重是离散的。</li><li>经过训练的量化可以显著减少每层数字所需的比特数。</li></ul></li><li>剪枝+训练量化可以共同减小模型的大小</li><li>哈夫曼编码(Huffman Coding)<ul><li>我们可以使用哈夫曼编码来减少/压缩权重的位数。</li><li>不频繁权重：使用更多的位来表示。</li><li>频繁权重：使用较少的位来表示。</li></ul></li><li>使用剪枝+训练量化+霍夫曼编码被称为深度压缩<ul><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/37.png" alt></li><li><img src="/2020/08/03/CS231N%E7%BF%BB%E8%AF%91%E7%89%88/38.png" alt></li><li><strong>SqueezeNet</strong><ul><li>到目前为止，我们讨论的所有模型都是使用预先训练过的模型。我们能做一个新的节省内存和计算的程序吗?</li><li>SqueezeNet获得了alexnet的精确度，参数减少了50倍，模型尺寸为0.5倍.</li></ul></li><li>挤压网甚至可以进一步压缩通过应用深度压缩他们</li><li>现在的模型更节能，速度也快了很多。</li><li>深度压缩通过facebook和百度应用于行业</li></ul></li></ul></li><li><strong>Quantization</strong><ul><li>算法（量化权重和激活）:<ul><li>用浮点数训练</li><li>量化重量和激活:<ul><li>收集体重和活动的统计数据。</li><li>选择合适的基点位置。</li></ul></li><li>微调浮动格式。</li><li>转换为定点格式。</li></ul></li></ul></li><li><strong>Low Rank Approximation</strong><ul><li>是CNN使用的另一种大小缩减算法。</li><li>想法是分解conv层，然后尝试两个组合层。</li></ul></li><li><strong>Binary / Ternary Net</strong><ul><li>我们能只用三个数字来表示神经网络中的权重吗？</li><li>如果只有-1，0，1，大小就会小得多</li><li>这是2017年发表的一个新观点”Zhu, Han, Mao, Dally. Trained Ternary Quantization, ICLR’17”</li><li>Works after training.</li><li>他们已经在AlexNet上尝试过了，它几乎达到了与AlexNet相同的错误</li><li>每个寄存器的操作数将增加: <a href="https://xnor.ai/" target="_blank" rel="noopener">https://xnor.ai/</a></li></ul></li><li><strong>Winograd Transformation</strong><ul><li>基于3x3 WINOGRAD卷积，比普通的卷积运算更少</li><li>cuDNN 5使用了WINOGRAD卷积，提高了速度</li></ul></li></ul></li><li>Part 2:有效的硬件推理(<strong><u>Hardware for Efficient Inference</u></strong>)<ul><li>我们为深入学习开发了许多ASIC。所有这些都有一个相同的目标，即最小化内存访问。<ul><li>麻省理工学院(Eyeriss MIT)</li><li>DaDiannao</li><li>TPU Google (Tensor processing unit)<ul><li>它可以用来替换服务器中的磁盘。</li><li>每台服务器最多4张卡</li><li>这种硬件所消耗的功率比GPU要小得多，芯片的尺寸也更小。</li></ul></li><li>EIE Standford<ul><li>By Han at 2016 [et al. ISCA’16]</li><li>我们不会保存零权重，也不会对硬件中的数字进行量化。</li><li>他说EIE有更好的吞吐量和能源效率。</li></ul></li></ul></li></ul></li><li>Part 3: <strong><u>Algorithms for Efficient Training</u></strong><ul><li><strong>Parallelization</strong><ul><li><strong>Data Parallel</strong> – 并行运行多个输入<ul><li>同时运行两个图像！</li><li>并行运行多个培训示例</li><li>受批量大小限制</li><li>渐变必须由主节点应用</li></ul></li><li><strong>Model Parallel</strong><ul><li>拆分模型-即网络</li><li>按层将模型拆分到多个处理器上</li></ul></li><li>Hyper-Parameter Parallel<ul><li>尝试多个并行的替代网络。</li><li>易于获得16-64 GPU并行训练一个模型</li></ul></li></ul></li><li><strong>Mixed Precision</strong> with FP16 and FP32<ul><li>我们已经讨论过，如果我们在整个模型中使用16位实数，那么能耗将减少4倍</li><li>我们可以使用一个完全16位数字的模型吗？我们可以用混合的FP16和FP32来实现这一点。我们在任何地方都使用16位，但有些地方我们需要FP32</li><li>以FP16乘以FP16为例，我们需要FP32</li><li>在你训练模型后，你可以成为一个近乎精确的著名模型，如AlexNet和ResNet。</li></ul></li><li><strong>Model Distillation</strong><ul><li>问题是我们能否使用一个经过高级（良好）训练的神经网络，并使它们指导学生（新的）神经网络</li><li>欲了解更多信息，请参阅Hinton等人。暗知识/神经网络中知识的提取</li></ul></li><li>DSD: 密集稀疏密集训练(Dense-Sparse-Dense Training)<ul><li>Han et al. “深度神经网络的密集稀疏密集训练(DSD: Dense-Sparse-Dense Training for Deep Neural Networks)”, ICLR 2017</li><li>有更好的规则化</li><li>我们的想法是训练模型，我们称之为稠密，然后对其应用修剪，让我们称之为稀疏</li><li>DSD产生相同的模型结构，但能找到更好的优化解，达到更好的局部极小值，达到更高的预测精度。</li><li>在以上两个步骤之后，我们去连接剩下的连接并再次学习它们（再次密集）。</li><li>这大大提高了许多深度学习模型的性能。</li></ul></li></ul></li><li>Part 4: <strong><u>Hardware for Efficient Training</u></strong><ul><li>GPUs for training:<ul><li>Nvidia PASCAL GP100 (2016)</li><li>Nvidia Volta GV100 (2017)<ul><li>可以进行混合精确操作</li><li>如此强大。</li><li>新的内克尔炸弹(The new neclar bomb)!</li></ul></li></ul></li><li>Google Announced “Google Cloud TPU” on May 2017!<ul><li>云TPU提供高达180兆次的浮点运算来训练和运行机器学习模型.</li><li>我们的一个新的大型翻译模型曾经需要一整天的时间来训练32个最好的商用gpu，现在它只需要一个TPU吊舱的八分之一就可以在一个下午训练到同样的精度</li></ul></li></ul></li><li>我们已经从PC时代==&gt;移动第一时代==&gt;人工智能第一时代</li></ul><h2 id="16-Adversarial-Examples-and-Adversarial-Training"><a href="#16-Adversarial-Examples-and-Adversarial-Training" class="headerlink" title="16. Adversarial Examples and Adversarial Training"></a>16. Adversarial Examples and Adversarial Training</h2><ul><li>什么是对抗性的例子(<strong><u>What are adversarial examples?</u></strong>)<ul><li>自2013年以来，深度神经网络已经在<ul><li>人脸识别</li><li>物体识别</li><li>验证码识别<ul><li>因为它的准确度比人类高，所以网站试图找到另一种解决方法，而不是验证码。</li></ul></li><li>以及其他任务</li></ul></li><li>2013年以前，如果看到电脑出错，没人会感到惊讶！但是现在存在深度学习，了解问题和原因是非常重要的。</li><li>对抗性是深度学习所犯的问题和不寻常的错误。</li><li>这个话题直到现在的深度学习能比人类做得越来越好时才成为热门话题</li><li>对手方是一个被仔细计算后被错误分类的例子</li><li>从人的角度看，在很多情况下，对手形象与原始形象相比并没有太大变化。</li><li>近代论文史:<ul><li>Biggio <a href="https://link.springer.com/chapter/10.1007/978-3-642-40994-3_25" target="_blank" rel="noopener">2013</a>: fool neural nets.</li><li>Szegedy et al 2013: fool ImageNet classifiers imperceptibly</li><li>Goodfellow et al <a href="https://arxiv.org/abs/1412.6572" target="_blank" rel="noopener">2014</a>: cheap, closed form attack.</li></ul></li><li>所以第一个故事发生在2013年。当塞格迪有一个CNN可以很好的分类图像。<ul><li>他想了解更多关于CNN如何改进它的工作。</li><li>他给出了一个物体的图像，通过梯度上升，他试图更新图像，使之成为另一个物体。</li><li>奇怪的是，他发现从人类的角度来看，结果图像并没有太大变化！</li><li>如果你尝试了，你不会通知任何变化，你会认为这是一个错误！但这并不是说，如果你去追求形象，你会发现他们完全不同</li></ul></li><li>这些错误几乎可以在我们研究过的任何深度学习算法中找到<ul><li>结果表明，RBF（Radial Basis Network）可以抵抗这种情况</li><li>用于密度估计的深层模型可以抵抗这种情况</li></ul></li><li>不仅仅是因为神经网络可以被愚弄<ul><li>Linear models<ul><li>Logistic regression</li><li>Softmax regression</li><li>SVMs</li></ul></li><li>Decision trees </li><li>Nearest neighbors</li></ul></li></ul></li><li>为什么会发生敌对(<strong><u>Why do adversarial happen?</u></strong>)<ul><li>在试图了解发生了什么的过程中，2016年，他们认为这是由于高维数据案例中的过度拟合模型造成的。<ul><li>因为在如此高的维中，我们可以发现一些随机误差。</li><li>所以如果我们用另一个参数训练一个模型，它不会犯同样的错误吗?</li><li>他们发现那是不对的。模型也出现了同样的错误，所以这并不意味着它是过度拟合的。</li></ul></li><li>在前面提到的实验中发现，问题是由系统性的东西引起的，而不是随机的。<ul><li>如果他们给一个例子添加一些向量，它将被错误地分类为任何模型。</li></ul></li><li>也许他们是因为不合身而不是过度合身。</li><li>现代深网是非常分段线性的<ul><li>Rectified linear unit</li><li>Carefully tuned sigmoid  <code># 大多数时候我们都在线性曲线内</code></li><li>Maxout</li><li>LSTM</li></ul></li><li>参数与输出之间的关系是非线性的，因为它是相乘的，这使得训练神经网络困难，而从输入和输出的线性映射是线性的，而且容易得多。</li></ul></li><li>如何利用对抗性来破坏机器学习系统？(<strong><u>How can adversarial be used to compromise machine learning systems?</u></strong>)<ul><li>如果我们正在试验一个NN有多容易被欺骗，我们要确保我们实际上是在愚弄它，而不仅仅是改变输出类，如果我们是攻击者，我们希望对NN（Get hole）采取这种行为。</li><li>当我们建立对抗性的例子时，我们使用最大范数来约束扰动。</li><li>快速梯度符号法:<ul><li>这种方法来自于这样一个事实，即几乎所有的神经网络都使用线性激活（如RELU），这是我们之前说过的假设</li><li>任何像素的变化都不能超过一定量的epsilon</li><li>快速的方法是用你用来训练网络的代价的梯度，然后用这个梯度的符号乘以epsilon。</li><li>Equation:<ul><li><code>Xdash = x + epslion * (sign of the gradient)</code></li><li>其中Xdash是对抗性示例，x是普通示例</li></ul></li><li>所以只要用符号（方向）和一些epsilon就可以检测到。</li></ul></li><li>一些攻击基于ADAM优化器。</li><li>敌对的例子不是随机的噪音！</li><li>神经网络训练在某个分布上，并且在该分布中表现良好。但是如果你改变这个分布，神经网络将不能回答正确的答案。他们很容易被愚弄。</li><li>深RL也可以被愚弄。</li><li>Attack of the weights:<ul><li>在线性模型中，我们可以将学习到的权重图像取出来，取图像的符号并将其添加到任何一个例子中，以迫使权重类为真。Andrej Karpathy，“打破ImageNet上的线性分类器”</li></ul></li><li>事实证明，有些利纳的型号表现很好（我们很难从他们那里得到广告）<ul><li>特别是浅层RBFs网络采用快速梯度符号法抵抗对抗性扰动<ul><li>问题是径向基函数在数据集上没有得到太多的精确性，因为它只是一个浅层模型，如果你试图让这个模型更深入，几乎所有层的梯度都将变为零。</li><li>rbf神经网络即使在批处理范数下也很难训练。算法。</li><li>伊恩认为，如果我们有一个更好的超参数或一个更好的梯度下降优化算法，我们将能够训练径向基函数，解决对抗性问题</li></ul></li></ul></li><li>我们也可以用另一个模型来愚弄当前的模型。例如使用支持向量机来愚弄深层神经网络。<ul><li>欲了解更多详情，请参考该报：“Papernot 2016”</li></ul></li><li>可转移攻击(Transferability Attack)<ol><li>具有未知权重的目标模型、机器学习算法、训练集；可能不可微</li><li>使用来自您的输入从这个模型中生成训练集，将它们发送到模型，然后从模型中获取输出</li><li>训练你自己的模特。“遵循Papernot 2016的一些表格”</li><li>在你的模型上创建一个对抗性的例子。</li><li>针对目标模型使用这些示例。</li><li>你几乎有可能得到好的结果并愚弄这个目标！</li></ol></li><li>在可转移性攻击中，通过100%的概率增加你的欺骗网络，你可以使不止一个模型可能是五个模型，然后应用它们。 “(Liu et al, 2016)”</li><li>对抗性的例子对人脑也是有用的！比如那些能骗过你眼睛的图像。他们在网上很多</li><li>在实践中，一些研究愚弄了真实的模型(MetaMind, Amazon, Google)</li><li>有人在facebook上上传了一些微扰，facebook被愚弄了</li></ul></li><li>防御措施是什么(<strong><u>What are the defenses?</u></strong>)<ul><li>伊恩尝试的很多防御措施都失败了，真的很糟糕！包括:<ul><li>Ensembles</li><li>Weight decay</li><li>Dropout</li><li>Adding noise at train time or at test time</li><li>Removing perturbation with an autoencoder </li><li>Generative modeling</li></ul></li><li>通用逼近定理<ul><li>无论我们希望我们的分类函数有一个足够大的神经网络可以使它成为任何形状。</li><li>我们可以训练一个神经网络来探测敌方</li></ul></li><li>线性模型和KNN比NN更容易被愚弄。神经网络实际上比其他模型更安全。在任何机器学习模型的对抗性例子中，对抗性训练的神经网络具有最佳的经验成功率<ul><li>深层神经网络可以用非线性函数进行训练，但我们只需要一种好的优化技术或使用像“RELU”这样的线性激活器来解决问题</li></ul></li></ul></li><li>在没有对手的情况下，如何使用对抗性示例来改进机器学习(<strong><u>How to use adversarial examples to improve machine learning, even when there is no adversary?</u></strong>)<ul><li>通用工程机械（基于模型的优化）        <code>#被伊恩称为通用工程机械</code><ul><li>For example:<ul><li>想象一下我们想要设计一辆速度快的汽车</li><li>我们训练了一个神经网络来查看汽车的设计图，并告诉我们蓝图是否能使我们成为一辆快车。</li><li>T这里的想法是优化网络的输入，使输出达到最大，这可以给我们一个最好的汽车蓝图！</li></ul></li><li>通过寻找使模型的预测性能最大化的输入来进行新的发明</li><li>现在，通过使用敌对的例子，我们只是得到了我们不喜欢的结果，但是如果我们解决了这个问题，我们就可以拥有最快的汽车、最好的GPU、最好的椅子、新药…。。</li></ul></li><li>整个对抗是一个活跃的研究领域，尤其是网络防御</li></ul></li><li>Conclusion<ul><li>进攻很容易</li><li>防守很难</li><li>对抗训练提供正规化和半监督学习</li><li>域外输入问题是基于模型优化的瓶颈问题</li></ul></li><li>有一个Github代码可以让你通过代码（构建在tensorflow之上）来了解敌方的一切:<ul><li>一个对抗性的示例库，用于构建攻击、构建防御和基准测试: <a href="https://github.com/tensorflow/cleverhans" target="_blank" rel="noopener">https://github.com/tensorflow/cleverhans</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;斯坦福大学深度学习课程笔记翻译版&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="CS231N" scheme="http://yoursite.com/tags/CS231N/"/>
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>论文-卷积经典模型-AlexNet</title>
    <link href="http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/"/>
    <id>http://yoursite.com/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/</id>
    <published>2020-07-31T03:36:06.000Z</published>
    <updated>2020-08-03T06:53:32.761Z</updated>
    
    <content type="html"><![CDATA[<p><a href="http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">点击下载原文pdf</a><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">http:&#x2F;&#x2F;papers.nips.cc&#x2F;paper&#x2F;4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf</span><br></pre></td></tr></table></figure><br><a id="more"></a></p><p><a href="#" onclick="window.print()">下载/导出/打印本文</a></p><h1 id="原文"><a href="#原文" class="headerlink" title="原文"></a>原文</h1><div style="text-align:center;font-size:2rem">ImageNet Classification with Deep Convolutional Neural Networks</div><h2 id="Abstract"><a href="#Abstract" class="headerlink" title="Abstract"></a>Abstract</h2><p>We trained a large, deep convolutional neural network to classify the 1.2 million high-resolution images in the ImageNet LSVRC-2010 contest into the 1000 different classes.On the test data, we achieved top-1 and top-5 error rates of 37.5% and 17.0% which is considerably better than the previous state-of-the-art.The neural network, which has 60 million parameters and 650,000 neurons, consists of five convolutional layers, some of which are followed by max-pooling layers, and three fully-connected layers with a final 1000-way softmax. To make training faster, we used non-saturating neurons and a very efficient GPU implementation of the convolution operation. To reduce overfitting in the fully-connected layers we employed a recently-developed regularization method called “dropout” that proved to be very effective.We also entered a variant of this model in the ILSVRC-2012 competition and achieved a winning top-5 test error rate of 15.3%, compared to 26.2% achieved by the second-best entry.</p><h2 id="1-Introduction"><a href="#1-Introduction" class="headerlink" title="1.Introduction"></a>1.Introduction</h2><p>Current approaches to object recognition make essential use of machine learning methods. To improve their performance, we can collect larger datasets, learn more powerful models, and use better techniques for preventing overfitting.<br>Until recently, datasets of labeled images were relatively small — on the order of tens of thousands of images (e.g., NORB [16], Caltech-101/256 [8, 9], and CIFAR-10/100 [12]). Simple recognition tasks can be solved quite well with datasets of this size, especially if they are augmented with label-preserving transformations.For example, the currentbest error rate on the MNIST digit-recognition task (&lt;0.3%) approaches human performance [4]. But objects in realistic settings exhibit considerable variability, so to learn to recognize them it is necessary to use much larger training sets.And indeed, the shortcomings of small image datasets have been widely recognized (e.g., Pinto et al. [21]), but it has only recently become possible to collect labeled datasets with millions of images.The new larger datasets include LabelMe [23], which consists of hundreds of thousands of fully-segmented images, and ImageNet [6], which consists of over 15 million labeled high-resolution images in over 22,000 categories.</p><p>To learn about thousands of objects from millions of images, we need a model with a large learning capacity.However, the immense complexity of the object recognition task means that this problem cannot be specified even by a dataset as large as ImageNet, so our model should also have lots of prior knowledge to compensate for all the data we don’t have.Convolutional neural networks (CNNs) constitute one such class of models [16, 11, 13, 18, 15, 22, 26]. Their capacity can be controlled by varying their depth and breadth, and they also make strong and mostly correct assumptions about the nature of images (namely, stationarity of statistics and locality of pixel dependencies).Thus, compared to standard feedforward neural networks with similarly-sized layers, CNNs have much fewer connections and parameters and so they are easier to train, while their theoretically-best performance is likely to be only slightly worse.</p><p>Despite the attractive qualities of CNNs, and despite the relative efficiency of their local architecture, they have still been prohibitively expensive to apply in large scale to high-resolution images.Luckily, current GPUs, paired with a highly-optimized implementation of 2D convolution, are powerful enough to facilitate the training of interestingly-large CNNs, and recent datasets such as ImageNet contain enough labeled examples to train such models without severe overfitting.</p><p>The specific contributions of this paper are as follows: we trained one of the largest convolutional neural networks to date on the subsets of ImageNet used in the ILSVRC-2010 and ILSVRC-2012 competitions [2] and achieved by far the best results ever reported on these datasets.We wrote a highly-optimized GPU implementation of 2D convolution and all the other operations inherent in training convolutional neural networks, which we make available publicly $^1$.Our network contains a number of new and unusual features which improve its performance and reduce its training time, which are detailed in Section 3.The size of our network made overfitting a significant problem, even with 1.2 million labeled training examples, so we used several effective techniques for preventing overfitting, which are described in Section 4.Our final network contains five convolutional and three fully-connected layers, and this depth seems to be important: we found that removing any convolutional layer (each of which contains no more than 1% of the model’s parameters) resulted in inferior performance.</p><hr><p>$^1$<a href="http://code.google.com/p/cuda-convnet/" target="_blank" rel="noopener">http://code.google.com/p/cuda-convnet/</a></p><p>In the end, the network’s size is limited mainly by the amount of memory available on current GPUs and by the amount of training time that we are willing to tolerate.Our network takes between five and six days to train on two GTX 580 3GB GPUs. All of our experiments suggest that our results can be improved simply by waiting for faster GPUs and bigger datasets to become available.</p><h2 id="2-The-Dataset"><a href="#2-The-Dataset" class="headerlink" title="2.The Dataset"></a>2.The Dataset</h2><p>ImageNet is a dataset of over 15 million labeled high-resolution images belonging to roughly 22,000 categories.The images were collected from the web and labeled by human labelers using Amazon’s Mechanical Turk crowd-sourcing tool.Starting in 2010, as part of the Pascal Visual Object Challenge, an annual competition called the ImageNet Large-Scale Visual Recognition Challenge (ILSVRC) has been held. ILSVRC uses a subset of ImageNet with roughly 1000 images in each of 1000 categories. In all, there are roughly 1.2 million training images, 50,000 validation images, and 150,000 testing images.</p><p>ILSVRC-2010 is the only version of ILSVRC for which the test set labels are available, so this is the version on which we performed most of our experiments.Since we also entered our model in the ILSVRC-2012 competition, in Section 6 we report our results on this version of the dataset as well, for which test set labels are unavailable.On ImageNet, it is customary to report two error rates: top-1 and top-5, where the top-5 error rate is the fraction of test images for which the correct label is not among the five labels considered most probable by the model.</p><p>ImageNet consists of variable-resolution images, while our system requires a constant input dimensionality.Therefore, we down-sampled the images to a fixed resolution of 256 × 256. Given a rectangular image, we first rescaled the image such that the shorter side was of length 256, and then cropped out the central 256×256 patch from the resulting image.We did not pre-process the images in any other way, except for subtracting the mean activity over the training set from each pixel. So we trained our network on the (centered) raw RGB values of the pixels.</p><h2 id="3-The-Architecture"><a href="#3-The-Architecture" class="headerlink" title="3.The Architecture"></a>3.The Architecture</h2><p>The architecture of our network is summarized in Figure 2. It contains eight learned layers — five convolutional and three fully-connected. Below, we describe some of the novel or unusual features of our network’s architecture. Sections 3.1-3.4 are sorted according to our estimation of their importance, with the most important first.</p><h3 id="3-1-ReLU-Nonlinearity"><a href="#3-1-ReLU-Nonlinearity" class="headerlink" title="3.1 ReLU Nonlinearity"></a>3.1 ReLU Nonlinearity</h3><p>The standard way to model a neuron’s output f as a function of its input x is with f(x) = tanh(x) or f(x) = (1 + $e^x$)−1. In terms of training time with gradient descent, these saturating nonlinearities are much slower than the non-saturating nonlinearity f(x) = max(0, x). Following Nair and Hinton [20], we refer to neurons with this nonlinearity as Rectified Linear Units (ReLUs). Deep convolutional neural networks with ReLUs train several times faster than their equivalents with tanh units. This is demonstrated in Figure 1, which shows the number of iterations required to reach 25% training error on the CIFAR-10 dataset for a particular four-layer convolutional network. This plot shows that we would not have been able to experiment with such large neural networks for this work if we had used traditional saturating neuron models.</p><p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure1.png" alt></p><p>Figure 1: A four-layer convolutional neural network with ReLUs (solid line) reaches a 25% training error rate on CIFAR-10 six times faster than an equivalent network with tanh neurons (dashed line). The learning rates for each network were chosen independently to make training as fast as possible. No regularization of any kind was employed. The magnitude of the effect demonstrated here varies with network architecture, but networks with ReLUs consistently learn several times faster than equivalents with saturating neurons.</p><p>We are not the first to consider alternatives to traditional neuron models in CNNs. For example, Jarrett etal.[11] claim that the nonlinearityf(x) = |tanh(x)| works particularly well with their type of contrast normalization followed by local average pooling on the Caltech-101 dataset. However, on this dataset the primary concern is preventing overfitting, so the effect they are observing is different from the accelerated ability to fit the training set which we report when using ReLUs. Faster learning has a great influence on the performance of large models trained on large datasets.</p><h3 id="3-2-Training-on-Multiple-GPUs"><a href="#3-2-Training-on-Multiple-GPUs" class="headerlink" title="3.2 Training on Multiple GPUs"></a>3.2 Training on Multiple GPUs</h3><p>A single GTX 580 GPU has only 3GB of memory, which limits the maximum size of the networks that can be trained on it. It turns out that 1.2 million training examples are enough to train networks which are too big to fit on one GPU. Therefore we spread the net across two GPUs. Current GPUs are particularly well-suited to cross-GPU parallelization, as they are able to read from and write to one another’s memory directly, without going through host machine memory. The parallelization scheme that we employ essentially puts half of the kernels (or neurons) on each GPU, with one additional trick: the GPUs communicate only in certain layers. This means that, for example, the kernels of layer 3 take input from all kernel maps in layer 2. However, kernels in layer 4 take input only from those kernel maps in layer 3 which reside on the same GPU. Choosing the pattern of connectivity is a problem for cross-validation, but this allows us to precisely tune the amount of communication until it is an acceptable fraction of the amount of computation.</p><p>The resultant architecture is somewhat similar to that of the “columnar” CNN employed by Cire¸ san et al. [5], except that our columns are not independent (see Figure 2). This scheme reduces our top-1 and top-5 error rates by 1.7% and 1.2%, respectively, as compared with a net with half as many kernels in each convolutional layer trained on one GPU. The two-GPU net takes slightly less time to train than the one-GPU  ${net}^2$。</p><hr><p>$^2$The one-GPU net actually has the same number of kernels as the two-GPU net in the final convolutional layer. This is because most of the net’s parameters are in the first fully-connected layer, which takes the last convolutional layer as input. So to make the two nets have approximately the same number of parameters, we did not halve the size of the final convolutional layer (nor the fully-conneced layers which follow). Therefore this comparison is biased in favor of the one-GPU net, since it is bigger than “half the size” of the two-GPU net.</p><h3 id="3-3-Local-Response-Normalization"><a href="#3-3-Local-Response-Normalization" class="headerlink" title="3.3 Local Response Normalization"></a>3.3 Local Response Normalization</h3><p>ReLUs have the desirable property that they do not require input normalization to prevent them from saturating. If at least some training examples produce a positive input to a ReLU, learning will happen in that neuron. However, we still find that the following local normalization scheme aids generalization. Denoting by $a^i_{x, y}$ the activity of a neuron computed by applying kernel i at position (x, y) and then applying the ReLU nonlinearity, the response-normalized activity $b^i_{x, y}$ given by the expression</p><script type="math/tex; mode=display">b^i_{x,y} = a^i_{x,y}/ (k+a\sum^{min(N-1,i+n/2)}_{j=max(0,i-n/2)} {a^i_{x,y}}^2)^\beta</script><p>where the sum runs over n “adjacent” kernel maps at the same spatial position, and N is the total number of kernels in the layer. The ordering of the kernel maps is of course arbitrary and determined before training begins. This sort of response normalization implements a form of lateral inhibition inspired by the type found in real neurons, creating competition for big activities amongst neuron outputs computed using different kernels. The constants k, n, α, and β are hyper-parameters whose values are determined using a validation set; we used k = 2, n = 5, α = $10^{-4}$, and β = 0.75. We applied this normalization after applying the ReLU nonlinearity in certain layers (see Section 3.5).</p><p>This scheme bears some resemblance to the local contrast normalization scheme of Jarrett et al. [11], but ours would be more correctly termed “brightness normalization”, since we do not subtract the mean activity. Response normalization reduces our top-1 and top-5 error rates by 1.4% and 1.2%, respectively. We also verified the effectiveness of this scheme on the CIFAR-10 dataset: a four-layer CNN achieved a 13% test error rate without normalization and 11% with normalization $^3$.</p><hr><p>$^3$We cannot describe this network in detail due to space constraints, but it is specified precisely by the code and parameter files provided here: <a href="http://code.google.com/p/cuda-convnet/" target="_blank" rel="noopener">http://code.google.com/p/cuda-convnet/</a></p><h3 id="3-4Overlapping-Pooling"><a href="#3-4Overlapping-Pooling" class="headerlink" title="3.4Overlapping Pooling"></a>3.4Overlapping Pooling</h3><p>Pooling layers in CNNs summarize the outputs of neighboring groups of neurons in the same kernel map.  Traditionally, the neighborhoods summarized by adjacent pooling units do not overlap (e.g.,[17, 11, 4]). To be more precise, a pooling layer can be thought of as consisting of a grid of pooling units spaced s pixels apart, each summarizing a neighborhood of size z × z centered at the location of the pooling unit. If we set s = z, we obtain traditional local pooling as commonly employed in CNNs. If we set s &lt; z, we obtain overlapping pooling. This is what we use throughout our network, with s = 2 and z = 3. This scheme reduces the top-1 and top-5 error rates by 0.4% and 0.3%, respectively, as compared with the non-overlapping scheme s = 2, z = 2, which produces output of equivalent dimensions. We generally observe during training that models with overlapping pooling find it slightly more difficult to overfit.</p><h3 id="3-5-Overall-Architecture"><a href="#3-5-Overall-Architecture" class="headerlink" title="3.5 Overall Architecture"></a>3.5 Overall Architecture</h3><p>Now we are ready to describe the overall architecture of our CNN. As depicted in Figure 2, the net contains eight layers with weights; the first five are convolutional and the remaining three are fullyconnected. The output of the last fully-connected layer is fed to a 1000-way softmax which produces a distribution over the 1000 class labels. Our network maximizes the multinomial logistic regression objective, which is equivalent to maximizing the average across training cases of the log-probability of the correct label under the prediction distribution. The kernels of the second, fourth, and fifth convolutional layers are connected only to those kernel maps in the previous layer which reside on the same GPU (see Figure 2). The kernels of the third convolutional layer are connected to all kernel maps in the second layer. The neurons in the fully-connected layers are connected to all neurons in the previous layer.Response-normalization layers follow the first and second convolutional layers. Max-poolinglayers, ofthekinddescribedinSection 3.4, follow both response-normalization layers as well as the fifth convolutional layer. The ReLU non-linearity is applied to the output of every convolutional and fully-connected layer. The first convolutional layer filters the 224×224×3 input image with 96 kernels of size 11×11×3 with a stride of 4 pixels (this is the distance between the receptive field centers of neighboring neurons in a kernel map). The second convolutional layer takes as input the (response-normalized and pooled) output of the first convolutional layer and filters it with 256 kernels of size 5 × 5 × 48. The third, fourth, and fifth convolutional layers are connected to one another without any intervening pooling or normalization layers. The third convolutional layer has 384 kernels of size 3 × 3 × 256 connected to the (normalized, pooled) outputs of the second convolutional layer. The fourth convolutional layer has 384 kernels of size 3 × 3 × 192 , and the fifth convolutional layer has 256 kernels of size 3 × 3 × 192. The fully-connected layers have 4096 neurons each.</p><p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure2.png" alt></p><p>Figure 2: An illustration of the architecture of our CNN, explicitly showing the delineation of responsibilities between the two GPUs. One GPU runs the layer-parts at the top of the figure while the other runs the layer-parts at the bottom. The GPUs communicate only at certain layers. The network’s input is 150,528-dimensional, and the number of neurons in the network’s remaining layers is given by 253,440–186,624–64,896–64,896–43,264– 4096–4096–1000.</p><h2 id="4-Reducing-Overfitting"><a href="#4-Reducing-Overfitting" class="headerlink" title="4 Reducing Overfitting"></a>4 Reducing Overfitting</h2><p>Our neural network architecture has 60 million parameters. Although the 1000 classes of ILSVRC make each training example impose 10 bits of constraint on the mapping from image to label, this turns out to be insufficient to learn so many parameters without considerable overfitting. Below, we describe the two primary ways in which we combat overfitting.</p><h3 id="4-1-Data-Augmentation"><a href="#4-1-Data-Augmentation" class="headerlink" title="4.1 Data Augmentation"></a>4.1 Data Augmentation</h3><p>The easiest and most common method to reduce overfitting on image data is to artificially enlarge the dataset using label-preserving transformations (e.g., [25, 4, 5]). We employ two distinct forms of data augmentation, both of which allow transformed images to be produced from the original images with very little computation, so the transformed images do not need to be stored on disk. In our implementation, the transformed images are generated in Python code on the CPU while the GPU is training on the previous batch of images. So these data augmentation schemes are, in effect, computationally free.</p><p>The first form of data augmentation consists of generating image translations and horizontal reflections. We do this by extracting random 224×224 patches (and their horizontal reflections) from the 256×256 images and training our network on these extracted patches $^4$. This increases the size of our training set by a factor of 2048, though the resulting training examples are, of course, highly interdependent. Without this scheme, our network suffers from substantial overfitting, which would have forced us to use much smaller networks. At test time, the network makes a prediction by extracting five 224 × 224 patches (the four corner patches and the center patch) as well as their horizontal reflections (hence ten patches in all), and averaging the predictions made by the network’s softmax layer on the ten patches.</p><hr><p>$^4$This is the reason why the input images in Figure 2 are 224 × 224 × 3-dimensional.</p><p>The second form of data augmentation consists of altering the intensities of the RGB channels in training images. Specifically, we perform PCA on the set of RGB pixel values throughout the ImageNet training set. To each training image, we add multiples of the found principal components,with magnitudes proportional to the corresponding eigenvalues times a random variable drawn from a Gaussian with mean zero and standard deviation 0.1. Therefore to each RGB image pixel $I_{xy}=[I_{xy}^R,I_{xy}^G,I_{xy}^B]$ we add the following quantity:</p><script type="math/tex; mode=display">[P1,P2,P3][\alpha1 \lambda1,\alpha2 \lambda2,\alpha3 \lambda3]^T</script><p>where pi and λi are ith eigenvector and eigenvalue of the 3 × 3 covariance matrix of RGB pixel values, respectively, and αiis the aforementioned random variable. Each αiis drawn only once for all the pixels of a particular training image until that image is used for training again, at which point it is re-drawn. This scheme approximately captures an important property of natural images, namely, that object identity is invariant to changes in the intensity and color of the illumination. This scheme reduces the top-1 error rate by over 1%.</p><h3 id="4-2-Dropout"><a href="#4-2-Dropout" class="headerlink" title="4.2 Dropout"></a>4.2 Dropout</h3><p>Combining the predictions of many different models is a very successful way to reduce test errors [1, 3], but it appears to be too expensive for big neural networks that already take several days to train. There is, however, a very efficient version of model combination that only costs about a factor of two during training. The recently-introduced technique, called “dropout” [10], consists of setting to zero the output of each hidden neuron with probability 0.5. The neurons which are “dropped out” in this way do not contribute to the forward pass and do not participate in backpropagation. So every time an input is presented, the neural network samples a different architecture, but all these architectures share weights. This technique reduces complex co-adaptations of neurons, since a neuron cannot rely on the presence of particular other neurons. It is, therefore, forced to learn more robust features that are useful in conjunction with many different random subsets of the other neurons. At test time, we use all the neurons but multiply their outputs by 0.5, which is a reasonable approximation to taking the geometric mean of the predictive distributions produced by the exponentially-many dropout networks. We use dropout in the first two fully-connected layers of Figure 2. Without dropout, our network exhibits substantial overfitting. Dropout roughly doubles the number of iterations required to converge.</p><h2 id="5-Details-of-learning"><a href="#5-Details-of-learning" class="headerlink" title="5 Details of learning"></a>5 Details of learning</h2><p>We trained our models using stochastic gradient descent with a batch size of 128 examples, momentum of 0.9, and weight decay of 0.0005. We found that this small amount of weight decay was important for the model to learn. In other words, weight decay here is not merely a regularizer: it reduces the model’s training error. The update rule for weight w was</p><script type="math/tex; mode=display">v_{i+1}:=0.9v_{i}-0.0005\epsilon w_i-\epsilon \langle \frac{\delta L}{\delta W }|_{w_i}\rangle _{D_i}</script><script type="math/tex; mode=display">w_{i+1}:=w_i+v_{i+1}</script><p>where i is the iteration index,v is the momentum variable,$\epsilon $is the learning rate,$\langle \frac{\delta L}{\delta W }|_{w_i}\rangle _{D_i}$is the average over the ith batch Diof the derivative of the objective with respect to w, evaluated at wi.<br><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure3.png" alt></p><p>Figure 3: 96 convolutional kernels of size 11×11×3learned by the first convolutional layer on the 224×224×3 input images. The top 48 kernels were learned on GPU 1 while the bottom 48 kernels were learned on GPU 2. See Section 6.1 for details.</p><p>We initialized the weights in each layer from a zero-mean Gaussian distribution with standard deviation 0.01. We initialized the neuron biases in the second, fourth, and fifth convolutional layers, as well as in the fully-connected hidden layers, with the constant 1. This initialization accelerates the early stages of learning by providing the ReLUs with positive inputs. We initialized the neuron biases in the remaining layers with the constant 0.</p><p>We used an equal learning rate for all layers, which we adjusted manually throughout training.<br>The heuristic which we followed was to divide the learning rate by 10 when the validation error rate stopped improving with the current learning rate. The learning rate was initialized at 0.01 and reduced three times prior to termination. We trained the network for roughly 90 cycles through the training set of 1.2 million images, which took five to six days on two NVIDIA GTX 580 3GB GPUs.</p><h2 id="6-Results"><a href="#6-Results" class="headerlink" title="6 Results"></a>6 Results</h2><p>Our results on ILSVRC-2010 are summarized in Table 1. Our network achieves top-1 and top-5 test set error rates of 37.5% and 17.0% $^5$.</p><hr><p>$^5 $ The error rates without averaging predictions over ten patches as described in Section 4.1 are 39.0% and 18.3%. The best performance achieved during the ILSVRC2010 competition was 47.1% and 28.2% with an approach that averages the predictions produced from six sparse-coding models trained on different features [2], and since then the best published results are 45.7% and 25.7% with an approach that averages the predictions of two classifiers trained on Fisher Vectors (FVs) computed from two types of densely-sampled features [24].</p><p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/table1.png" alt><br>Table 1: Comparison of results on ILSVRC2010 test set. In italics are best results achieved by others.</p><p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/table2.png" alt><br>Table 2: Comparison of error rates on ILSVRC-2012 validation and test sets. In italics are best results achieved by others. Models with an asterisk* were “pre-trained” to classify the entire ImageNet 2011 Fall release. See Section 6 for details.</p><p>We also entered our model in the ILSVRC-2012 competition and report our results in Table 2. Since the ILSVRC-2012 test set labels are not publicly available, we cannot report test error rates for all the models that we tried. In the remainder of this paragraph, we use validation and test error rates interchangeably because in our experience they do not differ by more than 0.1% (see Table 2). The CNN described in this paper achieves a top-5 error rate of 18.2%. Averaging the predictions of five similar CNNs gives an error rate of 16.4%. Training one CNN, with an extra sixth convolutional layer over the last pooling layer, to classify the entire ImageNet Fall 2011 release (15M images, 22K categories), and then “fine-tuning” it on ILSVRC-2012 gives an error rate of 16.6%. Averaging the predictions of two CNNs that were pre-trained on the entire Fall 2011 release with the aforementioned five CNNs gives an error rate of 15.3%. The second-best contest entry achieved an error rate of 26.2% with an approach that averages the predictions of several classifiers trained on FVs computed from different types of densely-sampled features [7]. </p><p>Finally, we also report our error rates on the Fall 2009 version of ImageNet with 10,184 categories and 8.9 million images. On this dataset we follow the convention in the literature of using half of the images for training and half for testing. Since there is no established test set, our split necessarily differs from the splits used by previous authors, but this does not affect the results appreciably. Our top-1 and top-5 error rates on this dataset are 67.4% and 40.9%, attained by the net described above but with an additional, sixth convolutional layer over the last pooling layer. The best published results on this dataset are 78.1% and 60.9% [19].</p><h3 id="6-1-Qualitative-Evaluations"><a href="#6-1-Qualitative-Evaluations" class="headerlink" title="6.1 Qualitative Evaluations"></a>6.1 Qualitative Evaluations</h3><p>Figure 3 shows the convolutional kernels learned by the network’s two data-connected layers. The network has learned a variety of frequency- and orientation-selective kernels, as well as various colored blobs. Notice the specialization exhibited by the two GPUs, a result of the restricted connectivity described in Section 3.5. The kernels on GPU 1 are largely color-agnostic, while the kernels on on GPU 2 are largely color-specific. This kind of specialization occurs during every run and is independent of any particular random weight initialization (modulo a renumbering of the GPUs).</p><p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure4.png" alt></p><p>Figure 4: (Left) Eight ILSVRC-2010 test images and the five labels considered most probable by our model. The correct label is written under each image, and the probability assigned to the correct label is also shown with a red bar (if it happens to be in the top 5). (Right) Five ILSVRC-2010 test images in the first column. The remaining columns show the six training images that produce feature vectors in the last hidden layer with the smallest Euclidean distance from the feature vector for the test image.</p><p>In the left panel of Figure 4 we qualitatively assess what the network has learned by computing its top-5 predictions on eight test images. Notice that even off-center objects, such as the mite in the top-left, can be recognized by the net. Most of the top-5 labels appear reasonable. For example, only other types of cat are considered plausible labels for the leopard. In some cases (grille, cherry) there is genuine ambiguity about the intended focus of the photograph.</p><p>Another way to probe the network’s visual knowledge is to consider the feature activations induced by an image at the last, 4096-dimensional hidden layer. If two images produce feature activation vectors with a small Euclidean separation, we can say that the higher levels of the neural network consider them to be similar. Figure 4 shows five images from the test set and the six images from the training set that are most similar to each of them according to this measure. Notice that at the pixel level, the retrieved training images are generally not close in L2 to the query images in the first column. For example, the retrieved dogs and elephants appear in a variety of poses. We present the results for many more test images in the supplementary material.</p><p>Computing similarity by using Euclidean distance between two 4096-dimensional, real-valued vec-torsisinefficient, but it could be made efficient by training an auto-encoder to compress these vectors to short binary codes. This should produce a much better image retrieval method than applying auto-encoders to the raw pixels [14], which does not make use of image labels and hence has a tendency to retrieve images with similar patterns of edges, whether or not they are semantically similar.</p><h2 id="7-Discussion"><a href="#7-Discussion" class="headerlink" title="7 Discussion"></a>7 Discussion</h2><p>Our results show that a large, deep convolutional neural network is capable of achieving recordbreaking results on a highly challenging dataset using purely supervised learning. It is notable that our network’s performance degrades if a single convolutional layer is removed. For example, removing any of the middle layers results in a loss of about 2% for the top-1 performance of the network. So the depth really is important for achieving our results.</p><p>To simplify our experiments, we did not use any unsupervised pre-training even though we expect that it will help, especially if we obtain enough computational power to significantly increase the size of the network without obtaining a corresponding increase in the amount of labeled data. Thus far, our results have improved as we have made our network larger and trained it longer but we still have many orders of magnitude to go in order to match the infero-temporal pathway of the human visual system. Ultimately we would like to use very large and deep convolutional nets on video sequences where the temporal structure provides very helpful information that is missing or far less obvious in static images.</p><h2 id="References"><a href="#References" class="headerlink" title="References"></a>References</h2><p>[1] R.M. Bell and Y . Koren. Lessons from the netflixprizechallenge. ACM SIGKDD Explorations Newsletter,<br>9(2):75–79, 2007.<br>[2] A. Berg, J. Deng, and L. Fei-Fei.  Large scale visual recognition challenge 2010. www.image-<br>net.org/challenges. 2010.<br>[3] L. Breiman. Random forests. Machine learning, 45(1):5–32, 2001.<br>[4] D. Cire¸ san, U. Meier, and J. Schmidhuber. Multi-column deep neural networks for image classification.<br>Arxiv preprint arXiv:1202.2745, 2012.<br>[5] D.C. Cire¸ san, U. Meier, J. Masci, L.M. Gambardella, and J. Schmidhuber. High-performance neural<br>networks for visual object classification. Arxiv preprint arXiv:1102.0183, 2011.<br>[6] J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei-Fei. ImageNet: A Large-Scale Hierarchical<br>Image Database. In CVPR09, 2009.<br>[7] J. Deng, A. Berg, S. Satheesh, H. Su, A. Khosla, and L. Fei-Fei. ILSVRC-2012, 2012.  URL<br><a href="http://www.image-net.org/challenges/LSVRC/2012/" target="_blank" rel="noopener">http://www.image-net.org/challenges/LSVRC/2012/</a>.<br>[8] L. Fei-Fei, R. Fergus, and P . Perona. Learning generative visual models from few training examples: An<br>incremental bayesian approach tested on 101 object categories. Computer Vision and Image Understand-<br>ing, 106(1):59–70, 2007.<br>[9] G. Griffin, A. Holub, and P. Perona. Caltech-256 object category dataset. Technical Report 7694, Cali-<br>fornia Institute of Technology, 2007. URL <a href="http://authors.library.caltech.edu/7694" target="_blank" rel="noopener">http://authors.library.caltech.edu/7694</a>.<br>[10] G.E. Hinton, N. Srivastava, A. Krizhevsky, I. Sutskever, and R.R. Salakhutdinov. Improving neural net-<br>works by preventing co-adaptation of feature detectors. arXiv preprint arXiv:1207.0580, 2012.<br>[11] K. Jarrett, K. Kavukcuoglu, M. A. Ranzato, and Y . LeCun. What is the best multi-stage architecture for<br>object recognition? In International Conference on Computer Vision, pages 2146–2153. IEEE, 2009.<br>[12] A. Krizhevsky. Learning multiple layers of features from tiny images. Master’s thesis, Department of<br>Computer Science, University of Toronto, 2009.<br>[13] A. Krizhevsky. Convolutional deep belief networks on cifar-10. Unpublished manuscript, 2010.<br>[14] A. Krizhevsky and G.E. Hinton. Using very deep autoencoders for content-based image retrieval. In<br>ESANN, 2011.<br>[15] Y . Le Cun, B. Boser, J.S. Denker, D. Henderson, R.E. Howard, W. Hubbard, L.D. Jackel, et al. Hand-<br>written digit recognition with a back-propagation network. In Advances in neural information processing<br>systems, 1990.<br>[16] Y . LeCun, F.J. Huang, and L. Bottou. Learning methods for generic object recognition with invariance to<br>pose and lighting. In Computer Vision and Pattern Recognition, 2004. CVPR 2004. Proceedings of the<br>2004 IEEE Computer Society Conference on, volume 2, pages II–97. IEEE, 2004.<br>[17] Y . LeCun, K. Kavukcuoglu, and C. Farabet. Convolutional networks and applications in vision. In<br>Circuits and Systems (ISCAS), Proceedings of 2010 IEEE International Symposium on, pages 253–256.<br>IEEE, 2010.<br>[18] H. Lee, R. Grosse, R. Ranganath, and A.Y . Ng. Convolutional deep belief networks for scalable unsuper-<br>vised learning of hierarchical representations. InProceedings of the 26th Annual International Conference<br>on Machine Learning, pages 609–616. ACM, 2009.<br>[19] T. Mensink, J. V erbeek, F. Perronnin, and G. Csurka. Metric Learning for Large Scale Image Classifi-<br>cation: Generalizing to New Classes at Near-Zero Cost. In ECCV - European Conference on Computer<br>Vision, Florence, Italy, October 2012.<br>[20] V . Nair and G. E. Hinton. Rectified linear units improve restricted boltzmann machines. In Proc. 27th<br>International Conference on Machine Learning, 2010.<br>[21] N. Pinto, D.D. Cox, and J.J. DiCarlo. Why is real-world visual object recognition hard? PLoS computa-<br>tional biology, 4(1):e27, 2008.<br>[22] N. Pinto, D. Doukhan, J.J. DiCarlo, and D.D. Cox. A high-throughput screening approach to discovering<br>good forms of biologically inspired visual representation. PLoS computational biology, 5(11):e1000579,<br>2009.<br>[23] B.C. Russell, A. Torralba, K.P . Murphy, and W.T. Freeman. Labelme: a database and web-based tool for<br>image annotation. International journal of computer vision, 77(1):157–173, 2008.<br>[24] J. Sánchez and F. Perronnin. High-dimensional signature compression for large-scale image classification.<br>InComputer Vision and Pattern Recognition (CVPR), 2011 IEEE Conference on, pages 1665–1672. IEEE,<br>2011.<br>[25] P .Y . Simard, D. Steinkraus, and J.C. Platt. Best practices for convolutional neural networks applied to<br>visual document analysis. In Proceedings of the Seventh International Conference on Document Analysis<br>and Recognition, volume 2, pages 958–962, 2003.<br>[26] S.C. Turaga, J.F. Murray, V . Jain, F. Roth, M. Helmstaedter, K. Briggman, W. Denk, and H.S. Seung. Con-<br>volutional networks can learn to generate affinity graphs for image segmentation. Neural Computation,<br>22(2):511–538, 2010.</p><h1 id="翻译"><a href="#翻译" class="headerlink" title="翻译"></a>翻译</h1><div style="text-align:center;font-size:2rem">基于深卷积神经网络的图像网络分类</div><h2 id="摘要"><a href="#摘要" class="headerlink" title="摘要"></a>摘要</h2><p>我们训练了一个大型的深卷积神经网络，将ImageNetLSVRC-2010竞赛中的120万张高分辨率图像分成1000个不同的类别。在测试数据上，我们获得了前1名和前5名的错误率分别为37.5%和17.0%，这比以前的最新技术要好得多。这个神经网络有6000万个参数和65万个神经元，由5个卷积层组成，其中一些是最大池化层，还有3个完全连接的层，最后是1000-way的softmax。为了加快训练速度，我们使用非饱和神经元和一个非常有效的GPU实现卷积运算。为了减少完全连接层中的过拟合，我们采用了一种最近发展起来的正则化方法，称为“dropout”，这被证明是非常有效的。我们还在ILSVRC-2012竞赛中输入了该模型的一个变体，并获得了15.3%的前5名测试错误率，而第二名的测试错误率为26.2%。</p><h2 id="1-介绍"><a href="#1-介绍" class="headerlink" title="1.介绍"></a>1.介绍</h2><p>当前的目标识别方法主要利用机器学习方法。为了提高它们的性能，我们可以收集更大的数据集，学习更强大的模型，并使用更好的技术来防止过度拟合。直到最近，标记图像的数据集相对较小，只有数万张图像（例如，NORB[16]、Caltech-101/256[8,9]和CIFAR-10/100[12]）。使用这种大小的数据集可以很好地解决简单的识别任务，特别是如果使用保留标签的转换对它们进行扩充的话。例如，MNIST数字识别任务的当前最佳错误率（&lt;0.3%）接近人因绩效[4]。但是现实环境中的物体表现出相当大的可变性，所以要学会识别它们就必须使用更大的训练集。事实上，小图像数据集的缺点已经被广泛地认识到（例如，Pinto等人。[21]），但直到最近才有可能收集带有数百万图像的标记数据集。新的更大的数据集包括LabelMe[23]和ImageNet[6]，前者由数十万张全分割图像组成，后者由超过22000个类别的1500万张高分辨率图像组成。</p><p>要从数百万幅图像中了解成千上万的物体，我们需要一个具有很大学习能力的模型。然而，对象识别任务的巨大复杂性意味着即使像ImageNet这样大的数据集也不能指定这个问题，因此我们的模型还应该有大量的先验知识来弥补我们没有的所有数据。卷积神经网络(CNNs)就是这样一类模型[16,11,13,18,15,22,26]。它们的容量可以通过改变深度和宽度来控制，而且它们还可以对图像的性质(即统计的平稳性和像素依赖的局部性)做出强有力的、基本正确的假设。因此，与具有相似层大小的标准前馈神经网络相比，cnn具有更少的连接和参数，因此更容易训练，而理论上最好的性能可能只会稍微差一点。</p><p>尽管cnn具有吸引人的品质，尽管其本地架构相对高效，但大规模应用于高分辨率图像的成本仍令人望而却步。幸运的是，目前的gpu，加上一个高度优化的2D卷积实现，已经足够强大来方便训练大的cnn，而最近的数据集，比如ImageNet包含了足够多的带标记的例子来训练这样的模型，而不会出现严重的过拟合。</p><p>本文的具体贡献如下:我们在ILSVRC-2010和ILSVRC-2012竞赛[2]中使用的ImageNet子集训练了迄今为止最大的卷积神经网络之一，并在这些数据集上取得了迄今为止最好的结果。我们编写了一个高度优化的二维卷积GPU实现，以及训练卷积神经网络所固有的所有其他操作，这些操作我们已经公开提供了 $^1$。我们的网络包含了许多新的和不寻常的特性，这些特性提高了它的性能，减少了它的训练时间，这在第3节中详细介绍。我们的网络的规模使得过拟合成为一个严重的问题，即使有120万个标记的训练样本，所以我们使用了几种有效的技术来防止过拟合，这些技术将在第4节中描述。我们最终的网络包含5个卷积层和3个全连接层，而这种深度似乎很重要:我们发现，删除任何卷积层(每个卷积层包含的参数不超过模型的1%)都会导致性能下降。</p><hr><p>$^1$<a href="http://code.google.com/p/cuda-convnet/" target="_blank" rel="noopener">http://code.google.com/p/cuda-convnet/</a></p><p>最后，网络的大小主要受到当前gpu上可用的内存数量和我们愿意容忍的训练时间的限制。我们的网络在两个GTX 580 3GB gpu上需要5到6天的训练。我们所有的实验都表明，我们的结果可以通过等待更快的gpu和更大的数据集得到改善。</p><h2 id="2-数据集"><a href="#2-数据集" class="headerlink" title="2.数据集"></a>2.数据集</h2><p>ImageNet是一个包含超过1500万张高分辨率图像的数据集，大约属于22,000个类别。这些图片是从网上收集的，并由人使用Amazon’s Mechanical Turk crowd-sourcing tool进行手工标记。从2010年开始，作为Pascal视觉物体挑战赛的一部分，一年一度的ImageNet大型视觉识别挑战赛(ILSVRC)已经举行。从2010年开始，作为Pascal视觉物体挑战赛的一部分，一年一度的ImageNet大型视觉识别挑战赛(ILSVRC)已经举行。</p><p>ILSVRC-2010是唯一一个有测试集标签的ILSVRC版本，所以我们在这个版本上执行了大部分实验。由于我们也在ILSVRC-2012竞赛中输入了我们的模型，所以在第6节中，我们也报告了这个版本的数据集的结果，因为测试集标签是不可用的。在ImageNet上，通常会报告两个错误率:top-1和top-5，其中top-5错误率是测试图像中正确的标签不在模型认为最可能出现的5个标签中所占的比例。</p><p>ImageNet由不同分辨率的图像组成，而我们的系统需要一个恒定的输入维数。因此，我们将图像下采样到固定分辨率为256×256。对于一个矩形图像，我们首先对图像进行重新标定，使较短的边的长度为256，然后从得到的图像中裁剪出中间的256×256的patch。除了从每个像素中减去训练集上的平均活跃度之外，我们没有采用任何其他方法对图像进行预处理。因此，我们根据像素(居中)的原始RGB值训练我们的网络。</p><h2 id="3-体系结构"><a href="#3-体系结构" class="headerlink" title="3.体系结构"></a>3.体系结构</h2><p>图2总结了我们的网络架构。它包含8个学习层——5个卷积层和3个完全连接层。下面，我们将描述我们网络架构的一些新奇或不寻常的特征。3.1-3.4部分根据我们对其重要性的估计进行排序，最重要的放在前面。</p><h3 id="3-1-非线性的ReLU"><a href="#3-1-非线性的ReLU" class="headerlink" title="3.1 非线性的ReLU"></a>3.1 非线性的ReLU</h3><p>将神经元的输出f建模为其输入x的函数的标准方法是:f(x) = tanh(x)或f(x) = (1 + $e^x$)−1。在梯度下降的训练时间方面，这些饱和非线性比非饱和非线性f(x) = max(0, x)要慢得多。根据Nair和Hinton[20]，我们将具有这种非线性的神经元称为改良的直线单元(Rectified Linear Units简称ReLUs)。使用ReLUs的深度卷积神经网络的训练速度比使用tanh单元的神经网络快好几倍。如图1所示，它显示了对于一个特定的四层卷积网络，在CIFAR-10数据集上达到25%的训练误差所需的迭代次数。这张图表明，如果我们使用传统的饱和神经元模型，我们就无法用这么大的神经网络进行实验。</p><p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure1.png" alt></p><p>图1:带ReLUs(实线)的四层卷积神经网络在CIFAR-10上的训练错误率达到25%，比等效的带tanh神经元网络(虚线)快6倍。每个网络的学习率都是独立选择的，以便尽可能快地进行训练。没有采用任何形式的正规化。这里显示的影响的大小随着网络结构的不同而不同，但是有ReLUs的网络始终比有饱和神经元的网络学习速度快几倍。</p><p>我们不是第一个考虑替代传统神经元模型的cnn。例如，Jarrett etal.[11]声称非线性函数f(x) = |tanh(x)|与Caltech-101数据集上的对比归一化和本地平均池化层的类型一起工作得特别好。然而，在这个数据集上，主要的关注点是防止过拟合，因此他们观察到的效果与我们在使用ReLUs时报告的快速拟合训练集的能力不同。快速学习对在大数据集上训练的大模型的性能有很大的影响。这意味着，例如，第3层的内核从第2层的所有内核映射中获取输入。然而，层4中的内核只从层3中驻留在同一GPU上的内核映射中获取输入。</p><h3 id="3-2-在多GPU上的训练"><a href="#3-2-在多GPU上的训练" class="headerlink" title="3.2 在多GPU上的训练"></a>3.2 在多GPU上的训练</h3><p>一个GTX 580 GPU只有3GB的内存，这限制了它能训练的最大网络大小。事实证明，120万个训练例子足以训练那些大到无法在一个GPU上运行的网络。因此，我们将网络分散到两个gpu上。当前的gpu特别适合交叉gpu并行，因为它们能够直接读写彼此的内存，而不需要通过主机内存。我们采用的并行化方案本质上是将一半的内核(或神经元)放在每个GPU上，还有一个额外的技巧:GPU只在特定的层上通信。 选择连接模式是交叉验证的一个问题，但这允许我们精确地调整通信量，直到它成为计算量的一个可接受的部分。</p><p>这种架构与Cire¸ san et al. [5]所使用的“柱状”CNN有些相似，只是我们的专栏不是独立的(见图2)。 与在一个GPU上训练每个卷积层内核数量减半的网络相比，该方案将我们的top-1和top-5错误率分别降低了1.7%和1.2%。双gpu网络的训练时间略少于单gpu $网络^2$。</p><hr><p>$^2$在最终的卷积层中，单gpu网络实际上拥有与双gpu网络相同数量的内核。这是因为网络的大多数参数都在第一个完全连接层中，它将最后一个卷积层作为输入。 因此，为了使这两个网络具有大致相同数量的参数，我们没有将最后的卷积层(也没有将后面的完全连接层)的大小减半。因此这种比较偏向于单gpu网络，因为它大于双gpu网络的“一半大小”。</p><h3 id="3-3局部响应归一化"><a href="#3-3局部响应归一化" class="headerlink" title="3.3局部响应归一化"></a>3.3局部响应归一化</h3><p>ReLUs具有理想的特性，它们不需要输入归一化来防止饱和。如果至少有一些训练例子对一个ReLU产生了积极的输入，学习就会在那个神经元中发生。然而，我们仍然发现下面的局部归一化方案有助于推广。用$a^i_{x, y}$表示在位置(x, y)处应用核i计算的神经元的活性，再应用ReLU非线性，响应归一化的活性$b^i_{x, y}$由表达式给出</p><script type="math/tex; mode=display">b^i_{x,y} = a^i_{x,y}/ (k+a\sum^{min(N-1,i+n/2)}_{j=max(0,i-n/2)} {a^i_{x,y}}^2)^\beta</script><p>其中，和在同一空间位置的n个“相邻”核映射上运行，n是这一层的核总数。内核映射的顺序当然是任意的，在训练开始之前就确定了。这种响应归一化实现了一种形式的侧向抑制，这种抑制是由在真实神经元中发现的类型激发的，在使用不同内核计算的神经元输出之间产生对大型活动的竞争。常数k, n，以及，和，都是超参数，它们的值是通过验证集确定的;我们使用k = 2, n = 5，$\alpha$= $10^{-4}$，和$\beta$ = 0.75。我们在某些层中应用ReLU非线性后应用了这种归一化(见3.5节)。</p><p>这种方案与Jarrett等人[11]的局部对比度归一化方案有一些相似之处，但我们的方案更准确地称为“亮度归一化”，因为我们没有减去平均活动。 响应归一化使前1和前5的错误率分别降低了1.4%和1.2%。我们还验证了该方案在CIFAR-10数据集上的有效性:一个四层CNN在不进行归一化的情况下测试错误率为13%，在进行归一化的情况下测试错误率为11% $^3$。</p><hr><p>$^3$由于空间的限制，我们无法详细描述这个网络，但在这里提供的代码和参数文件中有精确的说明:<a href="http://code.google.com/p/cuda-convnet/" target="_blank" rel="noopener">http://code.google.com/p/cuda-convnet/</a></p><h3 id="3-4-重叠池化层"><a href="#3-4-重叠池化层" class="headerlink" title="3.4 重叠池化层"></a>3.4 重叠池化层</h3><p>网络神经网络的池化层总结同一核图中相邻神经元的输出。传统上，由相邻的共用单元汇总的社区并不重叠(如[17,11,4])。更精确地说，一个池化层可以被认为是由一个间隔s像素的池化单元网格组成，每个池化单元汇总一个大小为z×z的以池化单元位置为中心的邻域。设s = z，得到CNNs中常用的传统局部池。如果我们设置s &lt; z，我们得到重叠池。这是我们在整个网络中使用的，s = 2和z = 3。与不重叠的方案s = 2、z = 2相比，该方案的top-1和top-5错误率分别降低了0.4%和0.3%，产生了等效维数的输出。 我们通常在训练过程中观察到，使用重叠池的模型很难过度适应。</p><h3 id="3-5总体架构"><a href="#3-5总体架构" class="headerlink" title="3.5总体架构"></a>3.5总体架构</h3><p>现在我们准备描述CNN的整体架构。如图2所示，该网包含8个带有权重的层;前5个是卷积的，其余3个是完全连通的。最后的全连接层的输出被馈给一个1000-way的softmax，它产生超过1000类标签的分布。我们的网络最大化了多项logistic回归的目标，它等价于在预测分布下最大化正确标签的对数概率的训练案例的平均值。 第二、四、五卷积层的内核只与上一层位于同一GPU上的内核映射相连(见图2)。第三卷积层的内核与第二层的所有内核映射相连。完全连接层中的神经元与前一层的所有神经元相连。响应归一化层紧随第一个第二个卷积层。 3.4节提到的最大池化层遵循两个响应规范化层和第五个卷积层。每个卷积层和全连通层的输出均采用ReLU非线性。第一卷积层用96个11×11×3的核对224×224×3输入图像进行滤波，步长为4个像素（这是相邻的感受野中心之间的距离）。 第二个卷积层将第一个卷积层的（响应规范化和池化）输出作为输入，并用大小为5×5×48的256个核对其进行滤波。第三、第四和第五卷积层彼此连接而没有任何中间的池或规范化层。第三卷积层有384个大小为3×3×256的核，连接到第二个卷积层的（标准化的、混合的）输出端。第四卷积层有384个3×3×192的核，第五个卷积层有256个3×3×192的核。完全连接的层每层有4096个神经元。</p><p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure2.png" alt></p><p>图2：我们的CNN架构图，明确显示了两个GPU之间的职责划分。一个GPU运行图形顶部的层部件，而另一个GPU运行底部的层部件。gpu只在某些层进行通信。网络的输入为150528维，网络剩余层中的神经元数量为253440–186624–64896–64896–43264–4096–4096–1000。</p><h2 id="4-减少过拟合"><a href="#4-减少过拟合" class="headerlink" title="4.减少过拟合"></a>4.减少过拟合</h2><p>我们的神经网络架构有6000万个参数。虽然ILSVRC的1000个类使得每个训练示例对从图像到标签的映射施加10个位的约束，但这并不足以在不过度拟合的情况下学习这么多参数。下面，我们将介绍我们对抗过度拟合的两种主要方法。</p><p>减少图像数据过度拟合的最简单和最常见的方法是使用保留标签的变换（例如[25,4,5]）人为地放大数据集。我们采用了两种不同的数据增强形式，这两种方式都允许从原始图像生成经过变换的图像，而无需将转换后的图像存储在磁盘上。在我们的实现中，转换后的图像是在CPU上用Python代码生成的，而GPU正在对前一批图像进行训练。因此，这些数据扩充方案实际上是无需计算的。</p><p>数据增强的第一种形式包括生成图像平移和水平反射。我们通过从256×256幅图像中随机提取224×224个面片（及其水平反射），并在这些提取的斑块上训练我们的网络$^4$。这使我们的培训规模增加了2048倍，尽管最终的培训示例当然是高度相互依赖的。如果没有这个方案，我们的网络将遭受严重的过度拟合，这将迫使我们使用更小的网络。在测试时，网络通过提取五个224×224个面片（四角面片和中心面片）及其水平反射（因此总共十个面片）进行预测，并将网络的softmax层在这十个面片上所做的预测取平均值。</p><hr><p>$^4$ 这就是为什么图2中的输入图像是224×224×3维的。</p><p>第二种形式的数据增强包括改变训练图像中RGB通道的强度。具体地说，我们在ImageNet训练集中对RGB像素值集执行PCA。在每个训练图像中，我们添加找到的主成分的倍数，量值与相应的特征值乘以从平均值为零，标准偏差为0.1的高斯随机变量。因此，对每个RGB图像像素$I_{xy}=[I_{xy}^R,I_{xy}^G,I_{xy}^B]$加上以下数量：</p><script type="math/tex; mode=display">[P1,P2,P3][\alpha1 \lambda1,\alpha2 \lambda2,\alpha3 \lambda3]^T</script><p>其中，pi和λi分别为RGB像素值的3×3协方差矩阵的特征向量和特征值，α为上述随机变量。每个αi只为一个特定训练图像的所有像素绘制一次，直到该图像再次用于训练，此时重新绘制该图像。该方案近似地捕捉到了自然图像的一个重要特性，即物体的同一性随光照强度和颜色的变化而变化。该方案使前1个错误率降低了1%以上。</p><h3 id="4-2-Dropout-1"><a href="#4-2-Dropout-1" class="headerlink" title="4.2 Dropout"></a>4.2 Dropout</h3><p>将许多不同模型的预测结合起来是减少测试误差的一种非常成功的方法[1,3]，但对于已经花费数天时间进行训练的大型神经网络来说，这似乎太贵了。然而，有一个非常有效的模型组合版本，在培训期间只需花费大约两倍的成本。最近引入的技术称为“dropout”[10]，包括将每个隐藏神经元的输出设为0，概率为0.5。 以这种方式“退出”的神经元不参与前向传递，也不参与反向传播。 所以每次输入被提出时，神经网络都会对不同的结构进行采样，但所有这些结构都共享权重。 这种技术减少了神经元复杂的共适应，因为一个神经元不能依赖于其他特定神经元的存在。 因此，它被迫学习更健壮的特征，这些特征与其他神经元的许多不同的随机子集结合起来是有用的。在测试时，我们使用所有的神经元，但将它们的输出乘以0.5，这是一个合理的近似值，取指数型多个丢失网络产生的预测分布的几何平均值。我们在图2中的前两个完全连接的层中使用dropout。在没有dropout的情况下，我们的网络表现出严重的过度适应。Dropout大约是收敛所需迭代次数的两倍。</p><h2 id="5-学习细节"><a href="#5-学习细节" class="headerlink" title="5.学习细节"></a>5.学习细节</h2><p>我们使用随机梯度下降训练我们的模型，批量大小为128个例子，动量为0.9，权重衰减为0.0005。我们发现这个小的重量衰减对模型的学习很重要。换句话说，这里的权重衰减不仅仅是一个正则化器：它减少了模型的训练误差。权重w的更新规则是</p><script type="math/tex; mode=display">v_{i+1}:=0.9v_{i}-0.0005\epsilon w_i-\epsilon \langle \frac{\delta L}{\delta W }|_{w_i}\rangle _{D_i}</script><script type="math/tex; mode=display">w_{i+1}:=w_i+v_{i+1}</script><p>其中i是迭代索引,v是动量变量，$\epsilon$ 是学习率，$\langle \frac{\delta L}{\delta W }|_{w_i}\rangle _{D_i}$是第i批中目标相对于w的导数的平均值，在wi处计算。</p><p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure3.png" alt><br>图3:224×224×3输入图像第一卷积层学习的96个卷积核，大小为11×11×3。前48个内核在gpu1上学习，而后48个内核在gpu2上学习。详见第6.1节。</p><p>我们用标准差为0.01的零均值高斯分布初始化每个层的权重。我们用常数1初始化第二、第四和第五卷积层以及完全连接的隐藏层中的神经元偏差。这种初始化通过向ReLUs提供积极的输入加快了学习的早期阶段。我们用常数0初始化剩余层中的神经元偏差。</p><p>我们对所有层使用相同的学习率，在整个培训过程中我们手动调整。我们遵循的启发式方法是，当验证错误率不再随当前学习率提高时，将学习率除以10。学习率初始化为0.01，终止前降低3倍。我们通过120万张图像的训练集训练了网络大约90个周期，在两个 NVIDIA GTX 5803 gb gpu上花了5到6天的时间。</p><h2 id="6-Results-1"><a href="#6-Results-1" class="headerlink" title="6 Results"></a>6 Results</h2><p>表1总结了我们在ILSVRC-2010上的结果。我们的网络实现了前1名和前5名测试集错误率分别为37.5%和17.0% $^5$。</p><hr><p>$^5$ 如第4.1节所述，未对10个补丁进行平均预测的错误率分别为39.0%和18.3%。在ILSVRC2010竞赛中取得的最佳性能分别为47.1%和28.2%，采用的方法是平均六个针对不同特征训练的稀疏编码模型生成的预测值[2]，从那时起，最好的发布结果分别为45.7%和25.7%，使用一种方法，即使用两种密集采样特征计算出的Fisher向量（fv）训练的两个分类器的预测值的平均值[24]。</p><p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/table1.png" alt><br>表1:ILSVRC2010测试集结果比较。斜体字是别人取得的最好成绩。</p><p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/table2.png" alt><br>表2:ILSVRC-2012验证集和测试集的错误率比较。斜体字是别人取得的最好成绩。带有星号*的模型经过“预先训练”，对ImageNet 2011秋季发布的整个版本进行分类。详见第6节。</p><p>我们还在ILSVRC-2012竞赛中输入了我们的模型，并在表2中报告了我们的结果。由于ILSVRC-2012测试集标签不公开，我们无法报告我们尝试的所有模型的测试错误率。在本段的其余部分中，我们交替使用验证和测试错误率，因为根据我们的经验，它们之间的差异不超过0.1%（见表2）。本文描述的CNN的前5位错误率为18.2%。对5个相似的cnn进行平均预测，误差率为16.4%。训练一个CNN，在最后一个池层上增加一个第六个卷积层，对整个ImageNet Fall 2011发布版（15M图像，22K类别）进行分类，然后在ILSVRC-2012上对其进行“微调”，错误率为16.6%。对2011年秋季发布的两个CNN的预测值进行平均，这两个CNN在上述五个CNN中进行了预训练，其预测误差率为15.3%。第二名最佳竞赛条目的错误率为26.2%，其方法是将训练在基于不同类型密集采样特征的FVs上的几个分类器的预测平均化[7]。</p><p>最后，我们还报告了2009年秋季版本的ImageNet的错误率，该版本包含10184个类别和890万个图像。在这个数据集上，我们遵循文献中的惯例，使用一半的图像进行训练，另一半用于测试。由于没有已建立的测试集，我们的分割必然不同于先前作者使用的分割，但这不会对结果产生明显的影响。我们在这个数据集上的前1名和前5名的错误率分别为67.4%和40.9%，通过上述网络实现，但是在最后一个池层上有一个额外的第六个卷积层。在这个数据集上发表的最佳结果分别是78.1%和60.9%[19]。</p><h3 id="6-1定性评价"><a href="#6-1定性评价" class="headerlink" title="6.1定性评价"></a>6.1定性评价</h3><p>图3显示了由网络的两个数据连接层学习的卷积核。网络已经学习了各种频率和方向选择性核，以及各种颜色的斑点。 请注意这两个gpu所显示的专门化，这是第3.5节中描述的受限连接的结果。gpu1上的内核基本上是颜色不可知的，而gpu2上的内核主要是颜色特定的。这种专门化发生在每次运行期间，并且独立于任何特定的随机权重初始化（对gpu进行模化重新编号）。</p><p><img src="/2020/07/31/%E8%AE%BA%E6%96%87-%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B-AlexNet/figure4.png" alt></p><p>图4：（左）8个ILSVRC-2010测试图像和我们模型认为最有可能的五个标签。正确的标签写在每个图像下面，并且分配给正确标签的概率也用红色条显示（如果它正好在前5位）。（右）第一列中的五幅ILSVRC-2010测试图像。剩下的列显示了六个训练图像，它们在最后一个隐藏层中生成特征向量，与测试图像的特征向量的欧几里德距离最小。</p><p>在图4的左侧面板中，我们通过计算8张测试图像的前5位预测，定性地评估了网络所学的知识。请注意，即使是偏离中心的对象，如左上角的斜接体，也可以被网络识别。前五名中的大多数似乎都是合理的。例如，只有其他种类的猫才被认为是豹的合理标签。在某些情况下（格栅，樱桃），有真正的含糊不清的预定焦点的照片。</p><p>探索网络视觉知识的另一种方法是考虑图像在最后4096维隐藏层引起的特征激活。如果两幅图像产生的特征激活向量具有很小的欧几里德分离，我们可以说，较高层次的神经网络认为他们是相似的。图4显示了来自测试集的五个图像和来自训练集的六个图像，这些图像与此度量中的每一个最相似。注意，在像素级别，检索到的训练图像在L2中通常与第一列中的查询图像不太接近。例如，被找回的狗和大象以各种姿势出现。我们在补充材料中展示了更多测试图像的结果。</p><p>利用两个4096维实值向量之间的欧几里德距离来计算相似性是低效的，但是通过训练nauto编码器将这些向量压缩成短的二进制代码，可以提高效率。这将产生比对原始像素应用自动编码器更好的图像检索方法[14]，后者不使用图像标签，因此倾向于检索具有相似边缘模式的图像，无论它们在语义上是否相似。</p><h2 id="7讨论"><a href="#7讨论" class="headerlink" title="7讨论"></a>7讨论</h2><p>我们的结果表明，一个大的，深卷积神经网络能够在一个高挑战性的数据集上使用纯监督学习获得破纪录的结果。值得注意的是，如果去掉单个卷积层，我们的网络性能会下降。例如，删除任何中间层都会导致网络的前1性能损失约2%。所以深度对我们的结果很重要。</p><p>为了简化我们的实验，我们没有使用任何无监督的预训练，即使我们期望它会有所帮助，特别是如果我们获得足够的计算能力来显著地增加网络的规模，而不获得相应增加的标记数据量。到目前为止，我们的结果已经有所改善，因为我们已经扩大了我们的网络并训练了它更长的时间，但我们仍然有许多数量级的工作要去匹配人类视觉系统的时间-时间路径。最后，我们希望在视频序列上使用非常大和很深的卷积网络，其中时间结构提供了非常有用的信息，而这些信息在静态图像中是缺失的或不太明显的。</p><h2 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h2><p>[1] R.M. Bell and Y . Koren. Lessons from the netflixprizechallenge. ACM SIGKDD Explorations Newsletter,<br>9(2):75–79, 2007.<br>[2] A. Berg, J. Deng, and L. Fei-Fei.  Large scale visual recognition challenge 2010. www.image-<br>net.org/challenges. 2010.<br>[3] L. Breiman. Random forests. Machine learning, 45(1):5–32, 2001.<br>[4] D. Cire¸ san, U. Meier, and J. Schmidhuber. Multi-column deep neural networks for image classification.<br>Arxiv preprint arXiv:1202.2745, 2012.<br>[5] D.C. Cire¸ san, U. Meier, J. Masci, L.M. Gambardella, and J. Schmidhuber. High-performance neural<br>networks for visual object classification. Arxiv preprint arXiv:1102.0183, 2011.<br>[6] J. Deng, W. Dong, R. Socher, L.-J. Li, K. Li, and L. Fei-Fei. ImageNet: A Large-Scale Hierarchical<br>Image Database. In CVPR09, 2009.<br>[7] J. Deng, A. Berg, S. Satheesh, H. Su, A. Khosla, and L. Fei-Fei. ILSVRC-2012, 2012.  URL<br><a href="http://www.image-net.org/challenges/LSVRC/2012/" target="_blank" rel="noopener">http://www.image-net.org/challenges/LSVRC/2012/</a>.<br>[8] L. Fei-Fei, R. Fergus, and P . Perona. Learning generative visual models from few training examples: An<br>incremental bayesian approach tested on 101 object categories. Computer Vision and Image Understand-<br>ing, 106(1):59–70, 2007.<br>[9] G. Griffin, A. Holub, and P. Perona. Caltech-256 object category dataset. Technical Report 7694, Cali-<br>fornia Institute of Technology, 2007. URL <a href="http://authors.library.caltech.edu/7694" target="_blank" rel="noopener">http://authors.library.caltech.edu/7694</a>.<br>[10] G.E. Hinton, N. Srivastava, A. Krizhevsky, I. Sutskever, and R.R. Salakhutdinov. Improving neural net-<br>works by preventing co-adaptation of feature detectors. arXiv preprint arXiv:1207.0580, 2012.<br>[11] K. Jarrett, K. Kavukcuoglu, M. A. Ranzato, and Y . LeCun. What is the best multi-stage architecture for<br>object recognition? In International Conference on Computer Vision, pages 2146–2153. IEEE, 2009.<br>[12] A. Krizhevsky. Learning multiple layers of features from tiny images. Master’s thesis, Department of<br>Computer Science, University of Toronto, 2009.<br>[13] A. Krizhevsky. Convolutional deep belief networks on cifar-10. Unpublished manuscript, 2010.<br>[14] A. Krizhevsky and G.E. Hinton. Using very deep autoencoders for content-based image retrieval. In<br>ESANN, 2011.<br>[15] Y . Le Cun, B. Boser, J.S. Denker, D. Henderson, R.E. Howard, W. Hubbard, L.D. Jackel, et al. Hand-<br>written digit recognition with a back-propagation network. In Advances in neural information processing<br>systems, 1990.<br>[16] Y . LeCun, F.J. Huang, and L. Bottou. Learning methods for generic object recognition with invariance to<br>pose and lighting. In Computer Vision and Pattern Recognition, 2004. CVPR 2004. Proceedings of the<br>2004 IEEE Computer Society Conference on, volume 2, pages II–97. IEEE, 2004.<br>[17] Y . LeCun, K. Kavukcuoglu, and C. Farabet. Convolutional networks and applications in vision. In<br>Circuits and Systems (ISCAS), Proceedings of 2010 IEEE International Symposium on, pages 253–256.<br>IEEE, 2010.<br>[18] H. Lee, R. Grosse, R. Ranganath, and A.Y . Ng. Convolutional deep belief networks for scalable unsuper-<br>vised learning of hierarchical representations. InProceedings of the 26th Annual International Conference<br>on Machine Learning, pages 609–616. ACM, 2009.<br>[19] T. Mensink, J. V erbeek, F. Perronnin, and G. Csurka. Metric Learning for Large Scale Image Classifi-<br>cation: Generalizing to New Classes at Near-Zero Cost. In ECCV - European Conference on Computer<br>Vision, Florence, Italy, October 2012.<br>[20] V . Nair and G. E. Hinton. Rectified linear units improve restricted boltzmann machines. In Proc. 27th<br>International Conference on Machine Learning, 2010.<br>[21] N. Pinto, D.D. Cox, and J.J. DiCarlo. Why is real-world visual object recognition hard? PLoS computa-<br>tional biology, 4(1):e27, 2008.<br>[22] N. Pinto, D. Doukhan, J.J. DiCarlo, and D.D. Cox. A high-throughput screening approach to discovering<br>good forms of biologically inspired visual representation. PLoS computational biology, 5(11):e1000579,<br>2009.<br>[23] B.C. Russell, A. Torralba, K.P . Murphy, and W.T. Freeman. Labelme: a database and web-based tool for<br>image annotation. International journal of computer vision, 77(1):157–173, 2008.<br>[24] J. Sánchez and F. Perronnin. High-dimensional signature compression for large-scale image classification.<br>InComputer Vision and Pattern Recognition (CVPR), 2011 IEEE Conference on, pages 1665–1672. IEEE,<br>2011.<br>[25] P .Y . Simard, D. Steinkraus, and J.C. Platt. Best practices for convolutional neural networks applied to<br>visual document analysis. In Proceedings of the Seventh International Conference on Document Analysis<br>and Recognition, volume 2, pages 958–962, 2003.<br>[26] S.C. Turaga, J.F. Murray, V . Jain, F. Roth, M. Helmstaedter, K. Briggman, W. Denk, and H.S. Seung. Con-<br>volutional networks can learn to generate affinity graphs for image segmentation. Neural Computation,<br>22(2):511–538, 2010.</p><h1 id="我的总结"><a href="#我的总结" class="headerlink" title="我的总结"></a>我的总结</h1><ul><li>1.现实环境中的物体表现出相当大的可变性，需要大的数据集</li><li>2.需要大的数据集，为此需要学习能力很强的模型。</li><li>3.事实上数据集没法提供的无穷大，需要先验知识来弥补所没有的数据集</li><li>4.先验知识:卷积神经网络的容量可以通过改变深度和宽度来控制,还可以对图像的性质(即统计的平稳性和像素依赖的局部性)做出强有力的、基本正确的假设。</li><li>5.与具有相似层大小的标准前馈神经网络相比，cnn具有更少的连接和参数，因此更容易训练，而理论上最好的性能可能只会稍微差一点。</li><li>6.ImageNet的数据集里的图片分辨率不一样，需要将图像下采样到固定分辨率为256×256,因为系统需要一个恒定的输入维数</li><li>7.Rectified Linear Units简称ReLUs比sigmoid快好几倍</li><li>8.因为一个GTX 580 GPU只有3GB的内存,所以用两个GPU来并行计算,用两个GPU直接读写彼此的内存，而不需要通过主机内存。</li><li>9.双gpu网络的训练时间略少于单gpu网络(在一个GPU上训练每个卷积层内核数量减半的网络),因为使这两个网络具有大致相同数量的参数，我们没有将最后的卷积层(也没有将后面的完全连接层)的大小减半。</li><li>10.局部相应归一化</li><li>11.重叠池化层</li><li>12.数据增强(1图像平移水平翻转,2通道增强)</li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;&lt;a href=&quot;http://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;点击下载原文pdf&lt;/a&gt;&lt;br&gt;&lt;figure class=&quot;highlight plain&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;td class=&quot;code&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;http:&amp;#x2F;&amp;#x2F;papers.nips.cc&amp;#x2F;paper&amp;#x2F;4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf&lt;/span&gt;&lt;br&gt;&lt;/pre&gt;&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;&lt;/figure&gt;&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="论文" scheme="http://yoursite.com/categories/%E8%AE%BA%E6%96%87/"/>
    
    
      <category term="卷积经典模型论文" scheme="http://yoursite.com/tags/%E5%8D%B7%E7%A7%AF%E7%BB%8F%E5%85%B8%E6%A8%A1%E5%9E%8B%E8%AE%BA%E6%96%87/"/>
    
      <category term="翻译" scheme="http://yoursite.com/tags/%E7%BF%BB%E8%AF%91/"/>
    
  </entry>
  
  <entry>
    <title>CS231N</title>
    <link href="http://yoursite.com/2020/07/29/CS231N/"/>
    <id>http://yoursite.com/2020/07/29/CS231N/</id>
    <published>2020-07-29T14:11:12.000Z</published>
    <updated>2020-08-05T16:34:23.978Z</updated>
    
    <content type="html"><![CDATA[<p>斯坦福大学深度学习课程笔记<br><a id="more"></a></p><h1 id="Standford-CS231n-2017-Summary"><a href="#Standford-CS231n-2017-Summary" class="headerlink" title="Standford CS231n 2017 Summary"></a>Standford CS231n 2017 Summary</h1><p>After watching all the videos of the famous Standford’s <a href="http://cs231n.stanford.edu/" target="_blank" rel="noopener">CS231n</a> course that took place in 2017, i decided to take summary of the whole course to help me to remember and to anyone who would like to know about it. I’ve skipped some contents in some lectures as it wasn’t important to me.</p><h2 id="Table-of-contents"><a href="#Table-of-contents" class="headerlink" title="Table of contents"></a>Table of contents</h2><ul><li><a href="#standford-cs231n-2017-summary">Standford CS231n 2017 Summary</a><ul><li><a href="#table-of-contents">Table of contents</a></li><li><a href="#course-info">Course Info</a></li><li><a href="#01-introduction-to-cnn-for-visual-recognition">01. Introduction to CNN for visual recognition</a></li><li><a href="#02-image-classification">02. Image classification</a></li><li><a href="#03-loss-function-and-optimization">03. Loss function and optimization</a></li><li><a href="#04-introduction-to-neural-network">04. Introduction to Neural network</a></li><li><a href="#05-convolutional-neural-networks-cnns">05. Convolutional neural networks (CNNs)</a></li><li><a href="#06-training-neural-networks-i">06. Training neural networks I</a></li><li><a href="#07-training-neural-networks-ii">07. Training neural networks II</a></li><li><a href="#08-deep-learning-software">08. Deep learning software</a></li><li><a href="#09-cnn-architectures">09. CNN architectures</a></li><li><a href="#10-recurrent-neural-networks">10. Recurrent Neural networks</a></li><li><a href="#11-detection-and-segmentation">11. Detection and Segmentation</a></li><li><a href="#12-visualizing-and-understanding">12. Visualizing and Understanding</a></li><li><a href="#13-generative-models">13. Generative models</a></li><li><a href="#14-deep-reinforcement-learning">14. Deep reinforcement learning</a></li><li><a href="#15-efficient-methods-and-hardware-for-deep-learning">15. Efficient Methods and Hardware for Deep Learning</a></li><li><a href="#16-adversarial-examples-and-adversarial-training">16. Adversarial Examples and Adversarial Training</a></li></ul></li></ul><h2 id="Course-Info"><a href="#Course-Info" class="headerlink" title="Course Info"></a>Course Info</h2><ul><li><p>Website: <a href="http://cs231n.stanford.edu/" target="_blank" rel="noopener">http://cs231n.stanford.edu/</a></p></li><li><p>Lectures link: <a href="https://www.youtube.com/playlist?list=PLC1qU-LWwrF64f4QKQT-Vg5Wr4qEE1Zxk" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLC1qU-LWwrF64f4QKQT-Vg5Wr4qEE1Zxk</a></p></li><li><p>Full syllabus link: <a href="http://cs231n.stanford.edu/syllabus.html" target="_blank" rel="noopener">http://cs231n.stanford.edu/syllabus.html</a></p></li><li><p>Assignments solutions: <a href="https://github.com/Burton2000/CS231n-2017" target="_blank" rel="noopener">https://github.com/Burton2000/CS231n-2017</a></p></li><li><p>Number of lectures: <strong>16</strong></p></li><li><p>Course description:</p><ul><li><blockquote><p>Computer Vision has become ubiquitous in our society, with applications in search, image understanding, apps, mapping, medicine, drones, and self-driving cars. Core to many of these applications are visual recognition tasks such as image classification, localization and detection. Recent developments in neural network (aka “deep learning”) approaches have greatly advanced the performance of these state-of-the-art visual recognition systems. This course is a deep dive into details of the deep learning architectures with a focus on learning end-to-end models for these tasks, particularly image classification. During the 10-week course, students will learn to implement, train and debug their own neural networks and gain a detailed understanding of cutting-edge research in computer vision. The final assignment will involve training a multi-million parameter convolutional neural network and applying it on the largest image classification dataset (ImageNet). We will focus on teaching how to set up the problem of image recognition, the learning algorithms (e.g. backpropagation), practical engineering tricks for training and fine-tuning the networks and guide the students through hands-on assignments and a final course project. Much of the background and materials of this course will be drawn from the <a href="http://image-net.org/challenges/LSVRC/2014/index" target="_blank" rel="noopener">ImageNet Challenge</a>.</p></blockquote></li></ul></li></ul><h2 id="01-Introduction-to-CNN-for-visual-recognition"><a href="#01-Introduction-to-CNN-for-visual-recognition" class="headerlink" title="01. Introduction to CNN for visual recognition"></a>01. Introduction to CNN for visual recognition</h2><ul><li>A brief history of Computer vision starting from the late 1960s to 2017.</li><li>Computer vision problems includes image classification, object localization, object detection, and scene understanding.</li><li><a href="http://www.image-net.org/" target="_blank" rel="noopener">Imagenet</a> is one of the biggest datasets in image classification available right now.</li><li>Starting 2012 in the Imagenet competition, CNN (Convolutional neural networks) is always winning.</li><li>CNN actually has been invented in 1997 by <a href="http://ieeexplore.ieee.org/document/726791/" target="_blank" rel="noopener">Yann Lecun</a>.</li></ul><h2 id="02-Image-classification"><a href="#02-Image-classification" class="headerlink" title="02. Image classification"></a>02. Image classification</h2><ul><li>Image classification problem has a lot of challenges like illumination and viewpoints.<ul><li><img src="/2020/07/29/CS231N/39.jpeg" alt></li></ul></li><li>An image classification algorithm can be solved with <strong>K nearest neighborhood</strong> (KNN) but it can poorly solve the problem. The properties of KNN are:<ul><li>Hyperparameters of KNN are: k and the distance measure</li><li>K is the number of neighbors we are comparing to.</li><li>Distance measures include:<ul><li>L2 distance (Euclidean distance)<ul><li>Best for non coordinate points</li></ul></li><li>L1 distance (Manhattan distance)<ul><li>Best for coordinate points</li></ul></li></ul></li></ul></li><li>Hyperparameters can be optimized using Cross-validation as following (In our case we are trying tp predict K):<ol><li>Split your dataset into <code>f</code> folds.</li><li>Given predicted hyperparameters:<ul><li>Train your algorithm with f-1 folds and test it with the remain flood. and repeat this with every fold.</li></ul></li><li>Choose the hyperparameters that gives the best training values (Average over all folds)</li></ol></li><li><strong>Linear SVM</strong> classifier is an option for solving the image classification problem, but the curse of dimensions makes it stop improving at some point.</li><li><strong>Logistic regression</strong> is a also a solution for image classification problem, but image classification problem is non linear!</li><li>Linear classifiers has to run the following equation: <code>Y = wX + b</code> <ul><li>shape of <code>w</code> is the same as <code>x</code> and shape of <code>b</code> is 1.</li></ul></li><li>We can add 1 to X vector and remove the bias so that: <code>Y = wX</code><ul><li>shape of <code>x</code> is <code>oldX+1</code> and <code>w</code> is the same as <code>x</code></li></ul></li><li>We need to know how can we get <code>w</code>‘s and <code>b</code>‘s that makes the classifier runs at best.</li></ul><h2 id="03-Loss-function-and-optimization"><a href="#03-Loss-function-and-optimization" class="headerlink" title="03. Loss function and optimization"></a>03. Loss function and optimization</h2><ul><li><p>In the last section we talked about linear classifier but we didn’t discussed how we could <strong>train</strong> the parameters of that model to get best <code>w</code>‘s and <code>b</code>‘s.</p></li><li><p>We need a loss function to measure how good or bad our current parameters.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Loss = L[i] =(f(X[i],W),Y[i])</span><br><span class="line">Loss_for_all = <span class="number">1</span>/N * Sum(Li(f(X[i],W),Y[i]))      <span class="comment"># Indicates the average</span></span><br></pre></td></tr></table></figure></li><li><p>Then we find a way to minimize the loss function given some parameters. This is called <strong>optimization</strong>.</p></li><li><p>Loss function for a linear <strong>SVM</strong> classifier:</p><ul><li><code>L[i] = Sum where all classes except the predicted class (max(0, s[j] - s[y[i]] + 1))</code></li><li>We call this <strong><em>the hinge loss</em></strong>.</li><li>Loss function means we are happy if the best prediction are the same as the true value other wise we give an error with 1 margin.</li><li>Example:<ul><li><img src="/2020/07/29/CS231N/40.jpg" alt></li><li>Given this example we want to compute the loss of this image.</li><li><code>L = max (0, 437.9 - (-96.8) + 1) + max(0, 61.95 - (-96.8) + 1) = max(0, 535.7) + max(0, 159.75) = 695.45</code></li><li>Final loss is 695.45 which is big and reflects that the cat score needs to be the best over all classes as its the lowest value now. We need to minimize that loss.</li></ul></li><li>Its OK for the margin to be 1. But its a hyperparameter too.</li></ul></li><li><p>If your loss function gives you zero, are this value is the same value for your parameter? No there are a lot of parameters that can give you best score.</p></li><li><p>You’ll sometimes hear about people instead using the squared hinge loss SVM (or L2-SVM). that penalizes violated margins more strongly (quadratically instead of linearly). The unsquared version is more standard, but in some datasets the squared hinge loss can work better.</p></li><li><p>We add <strong>regularization</strong> for the loss function so that the discovered model don’t overfit the data.</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Loss = L = <span class="number">1</span>/N * Sum(Li(f(X[i],W),Y[i])) + <span class="keyword">lambda</span> * R(W)</span><br></pre></td></tr></table></figure><ul><li>Where <code>R</code> is the regularizer, and <code>lambda</code> is the regularization term.</li></ul></li><li><p>There are different regularizations techniques:</p><ul><li>| Regularizer           | Equation                            | Comments               |<br>| ——————————- | —————————————————- | ——————————— |<br>| L2                    | <code>R(W) = Sum(W^2)</code>                   | Sum all the W squared  |<br>| L1                    | <code>R(W) = Sum(lWl)</code>                   | Sum of all Ws with abs |<br>| Elastic net (L1 + L2) | <code>R(W) = beta * Sum(W^2) + Sum(lWl)</code> |                        |<br>| Dropout               |                                     | No Equation            |</li></ul></li><li><p>Regularization prefers smaller <code>W</code>s over big <code>W</code>s.</p></li><li><p>Regularizations is called weight decay. biases should not included in regularization.</p></li><li><p>Softmax loss (Like linear regression but works for more than 2 classes):</p><ul><li><p>Softmax function:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">A[L] = e^(score[L]) / sum(e^(score[L]), NoOfClasses)</span><br></pre></td></tr></table></figure></li><li><p>Sum of the vector should be 1.</p></li><li><p>Softmax loss:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Loss = -logP(Y = y[i]|X = x[i])</span><br></pre></td></tr></table></figure><ul><li><p>Log of the probability of the good class. We want it to be near 1 thats why we added a minus.</p></li><li><p>Softmax loss is called cross-entropy loss.</p></li></ul></li><li><p>Consider this numerical problem when you are computing Softmax:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># example with 3 classes and each having large scores</span></span><br><span class="line">f = np.array([<span class="number">123</span>, <span class="number">456</span>, <span class="number">789</span>]) </span><br><span class="line"><span class="comment"># Bad: Numeric problem, potential blowup</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f)) </span><br><span class="line"></span><br><span class="line"><span class="comment"># instead: first shift the values of f so that the highest number is 0:</span></span><br><span class="line">f -= np.max(f) <span class="comment"># f becomes [-666, -333, 0]</span></span><br><span class="line"><span class="comment"># safe to do, gives the correct answer</span></span><br><span class="line">p = np.exp(f) / np.sum(np.exp(f))</span><br></pre></td></tr></table></figure></li></ul></li><li><p><strong>Optimization</strong>:</p><ul><li>How we can optimize loss functions we discussed?</li><li>Strategy one:<ul><li>Get a random parameters and try all of them on the loss and get the best loss. But its a bad idea.</li></ul></li><li><p>Strategy two:</p><ul><li><p>Follow the slope.</p><ul><li><img src="/2020/07/29/CS231N/41.png" alt></li><li>Image <a href="https://rasbt.github.io/mlxtend/user_guide/general_concepts/gradient-optimization_files/ball.png" target="_blank" rel="noopener">source</a>.</li></ul></li><li><p>Our goal is to compute the gradient of each parameter we have.</p><ul><li><strong>Numerical gradient</strong>: Approximate, slow, easy to write.   (But its useful in debugging.)</li><li><strong>Analytic gradient</strong>: Exact, Fast, Error-prone.   (Always used in practice)</li></ul></li><li><p>After we compute the gradient of our parameters, we compute the gradient descent:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W = W - learning_rate * W_grad</span><br></pre></td></tr></table></figure></li><li><p>learning_rate is so important hyper parameter you should get the best value of it first of all the hyperparameters.</p></li><li><p>stochastic gradient descent:</p><ul><li>Instead of using all the data, use a mini batch of examples (32/64/128 are commonly used) for faster results.</li></ul></li></ul></li></ul></li></ul><h2 id="04-Introduction-to-Neural-network"><a href="#04-Introduction-to-Neural-network" class="headerlink" title="04. Introduction to Neural network"></a>04. Introduction to Neural network</h2><ul><li><p>Computing the analytic gradient for arbitrary complex functions:</p><ul><li><p>What is a Computational graphs?</p><ul><li>Used to represent any function. with nodes.</li><li>Using Computational graphs can easy lead us to use a technique that called back-propagation. Even with complex models like CNN and RNN.</li></ul></li><li><p>Back-propagation simple example:</p><ul><li><p>Suppose we have <code>f(x,y,z) = (x+y)z</code></p></li><li><p>Then graph can be represented this way:</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">X         </span><br><span class="line">  \</span><br><span class="line">   (+)--&gt; q ---(*)--&gt; f</span><br><span class="line">  &#x2F;           &#x2F;</span><br><span class="line">Y            &#x2F;</span><br><span class="line">            &#x2F;</span><br><span class="line">           &#x2F;</span><br><span class="line">Z---------&#x2F;</span><br></pre></td></tr></table></figure></li><li><p>We made an intermediate variable <code>q</code>  to hold the values of <code>x+y</code></p></li><li><p>Then we have:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">q = (x+y)              <span class="comment"># dq/dx = 1 , dq/dy = 1</span></span><br><span class="line">f = qz                 <span class="comment"># df/dq = z , df/dz = q</span></span><br></pre></td></tr></table></figure></li><li><p>Then:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">df/dq = z</span><br><span class="line">df/dz = q</span><br><span class="line">df/dx = df/dq * dq/dx = z * <span class="number">1</span> = z       <span class="comment"># Chain rule</span></span><br><span class="line">df/dy = df/dq * dq/dy = z * <span class="number">1</span> = z       <span class="comment"># Chain rule</span></span><br></pre></td></tr></table></figure></li></ul></li><li><p>So in the Computational graphs, we call each operation <code>f</code>. For each <code>f</code> we calculate the local gradient before we go on back propagation and then we compute the gradients in respect of the loss function using the chain rule.</p></li><li><p>In the Computational graphs you can split each operation to as simple as you want but the nodes will be a lot. if you want the nodes to be smaller be sure that you can compute the gradient of this node.</p></li><li><p>A bigger example:</p><ul><li><img src="/2020/07/29/CS231N/01.png" alt></li><li>Hint: the back propagation of two nodes going to one node from the back is by adding the two derivatives.</li></ul></li><li><p>Modularized implementation: forward/ backward API (example multiply code):</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MultuplyGate</span><span class="params">(object)</span>:</span></span><br><span class="line">  <span class="string">"""</span></span><br><span class="line"><span class="string">  x,y are scalars</span></span><br><span class="line"><span class="string">  """</span></span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">forward</span><span class="params">(x,y)</span>:</span></span><br><span class="line">    z = x*y</span><br><span class="line">    self.x = x  <span class="comment"># Cache</span></span><br><span class="line">    self.y = y<span class="comment"># Cache</span></span><br><span class="line">    <span class="comment"># We cache x and y because we know that the derivatives contains them.</span></span><br><span class="line">    <span class="keyword">return</span> z</span><br><span class="line">  <span class="function"><span class="keyword">def</span> <span class="title">backward</span><span class="params">(dz)</span>:</span></span><br><span class="line">    dx = self.y * dz         <span class="comment">#self.y is dx</span></span><br><span class="line">    dy = self.x * dz</span><br><span class="line">    <span class="keyword">return</span> [dx, dy]</span><br></pre></td></tr></table></figure></li><li><p>If you look at a deep learning framework you will find it follow the Modularized implementation where each class has a definition for forward and backward. For example:</p><ul><li>Multiplication</li><li>Max</li><li>Plus</li><li>Minus</li><li>Sigmoid</li><li>Convolution</li></ul></li></ul></li><li><p>So to define neural network as a function:</p><ul><li>(Before) Linear score function: <code>f = Wx</code></li><li>(Now) 2-layer neural network:    <code>f = W2*max(0,W1*x)</code> <ul><li>Where max is the RELU non linear function</li></ul></li><li>(Now) 3-layer neural network:    <code>f = W3*max(0,W2*max(0,W1*x)</code></li><li>And so on..</li></ul></li><li><p>Neural networks is a stack of some simple operation that forms complex operations.</p></li></ul><h2 id="05-Convolutional-neural-networks-CNNs"><a href="#05-Convolutional-neural-networks-CNNs" class="headerlink" title="05. Convolutional neural networks (CNNs)"></a>05. Convolutional neural networks (CNNs)</h2><ul><li>Neural networks history:<ul><li>First perceptron machine was developed by Frank Rosenblatt in 1957. It was used to recognize letters of the alphabet. Back propagation wasn’t developed yet.</li><li>Multilayer perceptron was developed in 1960 by Adaline/Madaline. Back propagation wasn’t developed yet.</li><li>Back propagation was developed in 1986 by Rumeelhart.</li><li>There was a period which nothing new was happening with NN. Cause of the limited computing resources and data.</li><li>In <a href="www.cs.toronto.edu/~fritz/absps/netflix.pdf">2006</a> Hinton released a paper that shows that we can train a deep neural network using Restricted Boltzmann machines to initialize the weights then back propagation.</li><li>The first strong results was in 2012 by Hinton in <a href="http://ieeexplore.ieee.org/document/6296526/" target="_blank" rel="noopener">speech recognition</a>. And the <a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">Alexnet</a> “Convolutional neural networks” that wins the image net in 2012 also by Hinton’s team.</li><li>After that NN is widely used in various applications.</li></ul></li><li>Convolutional neural networks history:<ul><li>Hubel &amp; Wisel in 1959 to 1968 experiments on cats cortex found that there are a topographical mapping in the cortex and that the neurons has hireical organization from simple to complex.</li><li>In 1998, Yann Lecun gives the paper <a href="http://ieeexplore.ieee.org/document/726791/" target="_blank" rel="noopener">Gradient-based learning applied to document recognition</a> that introduced the Convolutional neural networks. It was good for recognizing zip letters but couldn’t run on a more complex examples.</li><li>In 2012 <a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">AlexNet</a> used the same Yan Lecun architecture and won the image net challenge. The difference from 1998 that now we have a large data sets that can be used also the power of the GPUs solved a lot of performance problems.</li><li>Starting from 2012 there are CNN that are used for various tasks (Here are some applications):<ul><li>Image classification.</li><li>Image retrieval.<ul><li>Extracting features using a NN and then do a similarity matching.</li></ul></li><li>Object detection.</li><li>Segmentation.<ul><li>Each pixel in an image takes a label.</li></ul></li><li>Face recognition.</li><li>Pose recognition.</li><li>Medical images.</li><li>Playing Atari games with reinforcement learning.</li><li>Galaxies classification.</li><li>Street signs recognition.</li><li>Image captioning.</li><li>Deep dream.</li></ul></li></ul></li><li>ConvNet architectures make the explicit assumption that the inputs are images, which allows us to encode certain properties into the architecture.</li><li>There are a few distinct types of Layers in ConvNet (e.g. CONV/FC/RELU/POOL are by far the most popular)</li><li>Each Layer may or may not have parameters (e.g. CONV/FC do, RELU/POOL don’t)</li><li>Each Layer may or may not have additional hyperparameters (e.g. CONV/FC/POOL do, RELU doesn’t)</li><li>How Convolutional neural networks works?<ul><li>A fully connected layer is a layer in which all the neurons is connected. Sometimes we call it a dense layer.<ul><li>If input shape is <code>(X, M)</code> the weighs shape for this will be <code>(NoOfHiddenNeurons, X)</code></li></ul></li><li>Convolution layer is a layer in which we will keep the structure of the input by a filter that goes through all the image.<ul><li>We do this with dot product: <code>W.T*X + b</code>. This equation uses the broadcasting technique.</li><li>So we need to get the values of <code>W</code> and <code>b</code></li><li>We usually deal with the filter (<code>W</code>) as a vector not a matrix.</li></ul></li><li>We call output of the convolution activation map. We need to have multiple activation map.<ul><li>Example if we have 6 filters, here are the shapes:<ul><li>Input image                        <code>(32,32,3)</code></li><li>filter size                              <code>(5,5,3)</code><ul><li>We apply 6 filters. The depth must be three because the input map has depth of three.</li></ul></li><li>Output of Conv.                 <code>(28,28,6)</code> <ul><li>if one filter it will be   <code>(28,28,1)</code></li></ul></li><li>After RELU                          <code>(28,28,6)</code> </li><li>Another filter                     <code>(5,5,6)</code></li><li>Output of Conv.                 <code>(24,24,10)</code></li></ul></li></ul></li><li>It turns out that convNets learns in the first layers the low features and then the mid-level features and then the high level features.</li><li>After the Convnets we can have a linear classifier for a classification task.</li><li>In Convolutional neural networks usually we have some (Conv ==&gt; Relu)s and then we apply a pool operation to downsample the size of the activation.</li></ul></li><li><p>What is stride when we are doing convolution:</p><ul><li>While doing a conv layer we have many choices to make regarding the stride of which we will take. I will explain this by examples.</li><li>Stride is skipping while sliding. By default its 1.</li><li>Given a matrix with shape of <code>(7,7)</code> and a filter with shape <code>(3,3)</code>:<ul><li>If stride is <code>1</code> then the output shape will be <code>(5,5)</code>              <code># 2 are dropped</code></li><li>If stride is <code>2</code> then the output shape will be <code>(3,3)</code>             <code># 4 are dropped</code></li><li>If stride is <code>3</code> it doesn’t work.</li></ul></li><li>A general formula would be <code>((N-F)/stride +1)</code><ul><li>If stride is <code>1</code> then <code>O = ((7-3)/1)+1 = 4 + 1 = 5</code></li><li>If stride is <code>2</code> then <code>O = ((7-3)/2)+1 = 2 + 1 = 3</code></li><li>If stride is <code>3</code> then <code>O = ((7-3)/3)+1 = 1.33 + 1 = 2.33</code>        <code># doesn&#39;t work</code></li></ul></li></ul></li><li><p>In practice its common to zero pad the border.   <code># Padding from both sides.</code></p><ul><li>Give a stride of <code>1</code> its common to pad to this equation:  <code>(F-1)/2</code> where F is the filter size<ul><li>Example <code>F = 3</code> ==&gt; Zero pad with <code>1</code></li><li>Example <code>F = 5</code> ==&gt; Zero pad with <code>2</code></li></ul></li><li>If we pad this way we call this same convolution.</li><li>Adding zeros gives another features to the edges thats why there are different padding techniques like padding the corners not zeros but in practice zeros works!</li><li>We do this to maintain our full size of the input. If we didn’t do that the input will be shrinking too fast and we will lose a lot of data.</li></ul></li><li>Example:<ul><li>If we have input of shape <code>(32,32,3)</code> and ten filters with shape is <code>(5,5)</code> with stride <code>1</code> and pad <code>2</code><ul><li>Output size will be <code>(32,32,10)</code>                       <code># We maintain the size.</code></li></ul></li><li>Size of parameters per filter <code>= 5*5*3 + 1 = 76</code></li><li>All parameters <code>= 76 * 10 = 76</code></li></ul></li><li>Number of filters is usually common to be to the power of 2.           <code># To vectorize well.</code></li><li>So here are the parameters for the Conv layer:<ul><li>Number of filters K.<ul><li>Usually a power of 2.</li></ul></li><li>Spatial content size F.<ul><li>3,5,7 ….</li></ul></li><li>The stride S. <ul><li>Usually 1 or 2        (If the stride is big there will be a downsampling but different of pooling) </li></ul></li><li>Amount of Padding<ul><li>If we want the input shape to be as the output shape, based on the F if 3 its 1, if F is 5 the 2 and so on.</li></ul></li></ul></li><li>Pooling makes the representation smaller and more manageable.</li><li>Pooling Operates over each activation map independently.</li><li>Example of pooling is the maxpooling.<ul><li>Parameters of max pooling is the size of the filter and the stride”<ul><li>Example <code>2x2</code> with stride <code>2</code>                     <code># Usually the two parameters are the same 2 , 2</code></li></ul></li></ul></li><li>Also example of pooling is average pooling.<ul><li>In this case it might be learnable.</li></ul></li></ul><h2 id="06-Training-neural-networks-I"><a href="#06-Training-neural-networks-I" class="headerlink" title="06. Training neural networks I"></a>06. Training neural networks I</h2><ul><li><p>As a revision here are the Mini batch stochastic gradient descent algorithm steps:</p><ul><li>Loop:<ol><li>Sample a batch of data.</li><li>Forward prop it through the graph (network) and get loss.</li><li>Backprop to calculate the gradients.</li><li>Update the parameters using the gradients.</li></ol></li></ul></li><li><p>Activation functions:</p><ul><li><p>Different choices for activation function includes Sigmoid, tanh, RELU, Leaky RELU, Maxout, and ELU.</p></li><li><p><img src="/2020/07/29/CS231N/42.png" alt></p></li><li><p>Sigmoid:</p><ul><li>Squashes the numbers between [0,1]</li><li>Used as a firing rate like human brains.</li><li><code>Sigmoid(x) = 1 / (1 + e^-x)</code></li><li>Problems with sigmoid:<ul><li>big values neurons <strong><em>kill</em></strong> the gradients.<ul><li>Gradients are in most cases near 0 (Big values/small values), that kills the updates if the graph/network are large.</li></ul></li><li>Not Zero-centered.<ul><li>Didn’t produce zero-mean data.</li></ul></li><li><code>exp()</code> is a bit compute expensive.<ul><li>just to mention. We have a more complex operations in deep learning like convolution.</li></ul></li></ul></li></ul></li><li><p>Tanh:</p><ul><li>Squashes the numbers between [-1,1]</li><li>Zero centered.</li><li>Still big values neurons “kill” the gradients.</li><li><code>Tanh(x)</code> is the equation.</li><li>Proposed by Yann Lecun in 1991.</li></ul></li><li><p>RELU (Rectified linear unit):</p><ul><li><code>RELU(x) = max(0,x)</code></li><li>Doesn’t kill the gradients.<ul><li>Only small values that are killed. Killed the gradient in the half</li></ul></li><li>Computationally efficient.</li><li>Converges much faster than Sigmoid and Tanh <code>(6x)</code></li><li>More biologically plausible than sigmoid.</li><li>Proposed by Alex Krizhevsky in 2012 Toronto university. (AlexNet)</li><li>Problems:<ul><li>Not zero centered.</li></ul></li><li>If weights aren’t initialized good, maybe 75% of the neurons will be dead and thats a waste computation. But its still works. This is an active area of research to optimize this.</li><li>To solve the issue mentioned above, people might initialize all the biases by 0.01</li></ul></li><li><p>Leaky RELU:</p><ul><li><code>leaky_RELU(x) = max(0.01x,x)</code></li><li>Doesn’t kill the gradients from both sides.</li><li>Computationally efficient.</li><li>Converges much faster than Sigmoid and Tanh (6x)</li><li>Will not die.</li><li>PRELU is placing the 0.01 by a variable alpha which is learned as a parameter.</li></ul></li><li><p>Exponential linear units (ELU):</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ELU(x) &#x3D; &#123; x if x &gt; 0</span><br><span class="line">   alpah *(exp(x) -1)if x &lt;&#x3D; 0</span><br><span class="line">       # alpah are a learning parameter</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><ul><li><p>It has all the benefits of RELU</p></li><li><p>Closer to zero mean outputs and adds some robustness to noise.</p></li><li><p>problems</p><ul><li><code>exp()</code> is a bit compute expensive. </li></ul></li></ul></li><li><p>Maxout activations:</p><ul><li><code>maxout(x) = max(w1.T*x + b1, w2.T*x + b2)</code></li><li>Generalizes RELU and Leaky RELU</li><li>Doesn’t die!</li><li>Problems:<ul><li>doubles the number of parameters per neuron</li></ul></li></ul></li><li><p>In practice:</p><ul><li>Use RELU. Be careful for your learning rates.</li><li>Try out Leaky RELU/Maxout/ELU</li><li>Try out tanh but don’t expect much.</li><li>Don’t use sigmoid!</li></ul></li></ul></li><li><p><strong>Data preprocessing</strong>:</p><ul><li><p>Normalize the data:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Zero centered data. (Calculate the mean for every input).</span></span><br><span class="line"><span class="comment"># On of the reasons we do this is because we need data to be between </span></span><br><span class="line"><span class="comment"># positive and negative and not all the be negative or positive. </span></span><br><span class="line">X -= np.mean(X, axis = <span class="number">1</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Then apply the standard deviation. Hint: in images we don't do this.</span></span><br><span class="line">X /= np.std(X, axis = <span class="number">1</span>)</span><br></pre></td></tr></table></figure></li><li><p>To normalize images:</p><ul><li>Subtract the mean image (E.g. Alexnet)<ul><li>Mean image shape is the same as the input images.</li></ul></li><li>Or Subtract per-channel mean <ul><li>Means calculate the mean for each channel of all images. Shape is 3 (3 channels)</li></ul></li></ul></li></ul></li><li><p><strong>Weight initialization</strong>:</p><ul><li><p>What happened when initialize all Ws with zeros?</p><ul><li>All the neurons will do exactly the same thing. They will have the same gradient and they will have the same update.</li><li>So if W’s of a specific layer is equal the thing described happened</li></ul></li><li><p>First idea is to initialize the w’s with small random numbers:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">W = <span class="number">0.01</span> * np.random.rand(D, H)</span><br><span class="line"><span class="comment"># Works OK for small networks but it makes problems with deeper networks!</span></span><br></pre></td></tr></table></figure><ul><li><p>The standard deviations is going to zero in deeper networks. and the gradient will vanish sooner in deep networks.</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">W = <span class="number">1</span> * np.random.rand(D, H) </span><br><span class="line"><span class="comment"># Works OK for small networks but it makes problems with deeper networks!</span></span><br></pre></td></tr></table></figure></li><li><p>The network will explode with big numbers!</p></li></ul></li><li><p><strong><em>Xavier initialization</em></strong>:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W = np.random.rand(<span class="keyword">in</span>, out) / np.sqrt(<span class="keyword">in</span>)</span><br></pre></td></tr></table></figure><ul><li><p>It works because we want the variance of the input to be as the variance of the output.</p></li><li><p>But it has an issue, It breaks when you are using RELU.</p></li></ul></li><li><p><strong><em>He initialization</em></strong> (Solution for the RELU issue):</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">W = np.random.rand(<span class="keyword">in</span>, out) / np.sqrt(<span class="keyword">in</span>/<span class="number">2</span>)</span><br></pre></td></tr></table></figure><ul><li>Solves the issue with RELU. Its recommended when you are using RELU</li></ul></li><li><p>Proper initialization is an active area of research.</p></li></ul></li><li><p><strong>Batch normalization</strong>:</p><ul><li>is a technique to provide any layer in a Neural Network with inputs that are zero mean/unit variance.</li><li>It speeds up the training. You want to do this a lot.<ul><li>Made by Sergey Ioffe and Christian Szegedy at 2015.</li></ul></li><li>We make a Gaussian activations in each layer. by calculating the mean and the variance.</li><li>Usually inserted after (fully connected or Convolutional layers) and (before nonlinearity).</li><li>Steps (For each output of a layer)<ol><li>First we compute the mean and variance^2 of the batch for each feature.</li><li>We normalize by subtracting the mean and dividing by square root of (variance^2 + epsilon)<ul><li>epsilon to not divide by zero</li></ul></li><li>Then we make a scale and shift variables: <code>Result = gamma * normalizedX + beta</code>  <ul><li>gamma and beta are learnable parameters.</li><li>it basically possible to say “Hey!! I don’t want zero mean/unit variance input, give me back the raw input - it’s better for me.”</li><li>Hey shift and scale by what you want not just the mean and variance!</li></ul></li></ol></li><li>The algorithm makes each layer flexible (It chooses which distribution it wants)</li><li>We initialize the BatchNorm Parameters to transform the input to zero mean/unit variance distributions but during training they can learn that any other distribution might be better.</li><li>During the running of the training we need to calculate the globalMean and globalVariance for each layer by using weighted average.</li><li><u>Benefits of Batch Normalization</u>:<ul><li>Networks train faster.</li><li>Allows higher learning rates.</li><li>helps reduce the sensitivity to the initial starting weights.</li><li>Makes more activation functions viable.</li><li>Provides some regularization.<ul><li>Because we are calculating mean and variance for each batch that gives a slight regularization effect.</li></ul></li></ul></li><li>In conv layers, we will have one variance and one mean per activation map.</li><li>Batch normalization have worked best for CONV and regular deep NN, But for recurrent NN and reinforcement learning its still an active research area.<ul><li>Its challengey in reinforcement learning because the batch is small.</li></ul></li></ul></li><li><p><strong>Baby sitting the learning process</strong></p><ol><li>Preprocessing of data.</li><li>Choose the architecture.</li><li>Make a forward pass and check the loss (Disable regularization). Check if the loss is reasonable.</li><li>Add regularization, the loss should go up!</li><li>Disable the regularization again and take a small number of data and try to train the loss and reach zero loss.<ul><li>You should overfit perfectly for small datasets.</li></ul></li><li>Take your full training data, and small regularization then try some value of learning rate.<ul><li>If loss is barely changing, then the learning rate is small.</li><li>If you got <code>NAN</code> then your NN exploded and your learning rate is high.</li><li>Get your learning rate range by trying the min value (That can change) and the max value that doesn’t explode the network.</li></ul></li><li>Do Hyperparameters optimization to get the best hyperparameters values.</li></ol></li><li><p>Hyperparameter Optimization</p><ul><li>Try Cross validation strategy.<ul><li>Run with a few ephocs, and try to optimize the ranges.</li></ul></li><li>Its best to optimize in log space.</li><li>Adjust your ranges and try again.</li><li>Its better to try random search instead of grid searches (In log space)</li></ul></li></ul><h2 id="07-Training-neural-networks-II"><a href="#07-Training-neural-networks-II" class="headerlink" title="07. Training neural networks II"></a>07. Training neural networks II</h2><ul><li><p><strong>Optimization algorithms</strong>:</p><ul><li><p>Problems with stochastic gradient descent:</p><ul><li>if loss quickly in one direction and slowly in another (For only two variables), you will get very slow progress along shallow dimension, jitter along steep direction. Our NN will have a lot of parameters then the problem will be more.</li><li>Local minimum or saddle points<ul><li>If SGD went into local minimum we will stuck at this point because the gradient is zero.</li><li>Also in saddle points the gradient will be zero so we will stuck.</li><li>Saddle points says that at some point:<ul><li>Some gradients will get the loss up.</li><li>Some gradients will get the loss down.</li><li>And that happens more in high dimensional (100 million dimension for example)</li></ul></li><li>The problem of deep NN is more about saddle points than about local minimum because deep NN has high dimensions (Parameters)</li><li>Mini batches are noisy because the gradient is not taken for the whole batch.</li></ul></li></ul></li><li><p><strong>SGD + momentum</strong>:</p><ul><li><p>Build up velocity as a running mean of gradients:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Computing weighted average. rho best is in range [0.9 - 0.99]</span></span><br><span class="line">V[t+<span class="number">1</span>] = rho * v[t] + dx</span><br><span class="line">x[t+<span class="number">1</span>] = x[t] - learningRate * V[t+<span class="number">1</span>]</span><br></pre></td></tr></table></figure></li><li><p><code>V[0]</code> is zero.</p></li><li><p>Solves the saddle point and local minimum problems.</p></li><li><p>It overshoots the problem and returns to it back.</p></li></ul></li><li><p><strong>Nestrov momentum</strong>:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">dx = compute_gradient(x)</span><br><span class="line">old_v = v</span><br><span class="line">v = rho * v - learning_rate * dx</span><br><span class="line">x+= -rho * old_v + (<span class="number">1</span>+rho) * v</span><br></pre></td></tr></table></figure><ul><li>Doesn’t overshoot the problem but slower than SGD + momentum</li></ul></li><li><p><strong>AdaGrad</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grad_squared = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">  dx = compute_gradient(x)</span><br><span class="line">  </span><br><span class="line">  <span class="comment"># here is a problem, the grad_squared isn't decayed (gets so large)</span></span><br><span class="line">  grad_squared += dx * dx</span><br><span class="line">  </span><br><span class="line">  x -= (learning_rate*dx) / (np.sqrt(grad_squared) + <span class="number">1e-7</span>)</span><br></pre></td></tr></table></figure></li><li><p><strong>RMSProp</strong></p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">grad_squared = <span class="number">0</span></span><br><span class="line"><span class="keyword">while</span>(<span class="literal">True</span>):</span><br><span class="line">  dx = compute_gradient(x)</span><br><span class="line">  </span><br><span class="line">  <span class="comment">#Solved ADAgra</span></span><br><span class="line">  grad_squared = decay_rate * grad_squared + (<span class="number">1</span>-grad_squared) * dx * dx  </span><br><span class="line">  </span><br><span class="line">  x -= (learning_rate*dx) / (np.sqrt(grad_squared) + <span class="number">1e-7</span>)</span><br></pre></td></tr></table></figure><ul><li>People uses this instead of AdaGrad</li></ul></li><li><p><strong>Adam</strong></p><ul><li>Calculates the momentum and RMSProp as the gradients.</li><li>It need a Fixing bias to fix starts of gradients.</li><li>Is the best technique so far runs best on a lot of problems.</li><li>With <code>beta1 = 0.9</code> and <code>beta2 = 0.999</code> and <code>learning_rate = 1e-3</code> or <code>5e-4</code> is a great starting point for many models!</li></ul></li><li><p><strong>Learning decay</strong></p><ul><li>Ex. decay learning rate by half every few epochs.</li><li>To help the learning rate not to bounce out.</li><li>Learning decay is common with SGD+momentum but not common with Adam.</li><li>Dont use learning decay from the start at choosing your hyperparameters. Try first and check if you need decay or not.</li></ul></li><li><p>All the above algorithms we have discussed is a first order optimization.</p></li><li><p><strong>Second order optimization</strong></p><ul><li>Use gradient and Hessian to from quadratic approximation.</li><li>Step to the minima of the approximation.</li><li>What is nice about this update?<ul><li>It doesn’t has a learning rate in some of the versions.</li></ul></li><li>But its unpractical for deep learning<ul><li>Has O(N^2) elements.</li><li>Inverting takes O(N^3).</li></ul></li><li><strong>L-BFGS</strong> is a version of second order optimization<ul><li>Works with batch optimization but not with mini-batches.</li></ul></li></ul></li><li><p>In practice first use ADAM and if it didn’t work try L-BFGS.</p></li><li><p>Some says all the famous deep architectures uses <strong>SGS + Nestrov momentum</strong></p></li></ul></li><li><p><strong>Regularization</strong></p><ul><li>So far we have talked about reducing the training error, but we care about most is how our model will handle unseen data!</li><li>What if the gab of the error between training data and validation data are too large?</li><li>This error is called high variance.</li><li><strong>Model Ensembles</strong>:<ul><li>Algorithm:<ul><li>Train multiple independent models of the same architecture with different initializations.</li><li>At test time average their results.</li></ul></li><li>It can get you extra 2% performance.</li><li>It reduces the generalization error.</li><li>You can use some snapshots of your NN at the training ensembles them and take the results.</li></ul></li><li>Regularization solves the high variance problem. We have talked about L1, L2 Regularization.</li><li>Some Regularization techniques are designed for only NN and can do better.</li><li><strong>Drop out</strong>:<ul><li>In each forward pass, randomly set some of the neurons to zero. Probability of dropping is a hyperparameter that are 0.5 for almost cases.</li><li>So you will chooses some activation and makes them zero.</li><li>It works because:<ul><li>It forces the network to have redundant representation; prevent co-adaption of features!</li><li>If you think about this, It ensemble some of the models in the same model!</li></ul></li><li>At test time we might multiply each dropout layer by the probability of the dropout.</li><li>Sometimes at test time we don’t multiply anything and leave it as it is.</li><li>With drop out it takes more time to train.</li></ul></li><li><strong>Data augmentation</strong>:<ul><li>Another technique that makes Regularization.</li><li>Change the data!</li><li>For example flip the image, or rotate it.</li><li>Example in ResNet:<ul><li>Training: Sample random crops and scales:<ol><li>Pick random L in range [256,480]</li><li>Resize training image, short side = L</li><li>Sample random 224x244 patch.</li></ol></li><li>Testing: average a fixed set of crops<ol><li>Resize image at 5 scales: {224, 256, 384, 480, 640}</li><li>For each size, use 10 224x224 crops: 4 corners + center + flips</li></ol></li><li>Apply Color jitter or PCA</li><li>Translation, rotation, stretching.</li></ul></li></ul></li><li>Drop connect<ul><li>Like drop out idea it makes a regularization.</li><li>Instead of dropping the activation, we randomly zeroing the weights.</li></ul></li><li>Fractional Max Pooling<ul><li>Cool regularization idea. Not commonly used.</li><li>Randomize the regions in which we pool.</li></ul></li><li>Stochastic depth<ul><li>New idea.</li><li>Eliminate layers, instead on neurons.</li><li>Has the similar effect of drop out but its a new idea.</li></ul></li></ul></li><li><p><strong>Transfer learning</strong>:</p><ul><li><p>Some times your data is overfitted by your model because the data is small not because of regularization.</p></li><li><p>You need a lot of data if you want to train/use CNNs.</p></li><li><p>Steps of transfer learning</p><ol><li>Train on a big dataset that has common features with your dataset. Called pretraining.</li><li>Freeze the layers except the last layer and feed your small dataset to learn only the last layer.</li><li>Not only the last layer maybe trained again, you can fine tune any number of layers you want based on the number of data you have</li></ol></li><li><p>Guide to use transfer learning:</p></li></ul></li></ul><div class="table-container"><table><thead><tr><th></th><th>Very Similar dataset</th><th>very different dataset</th></tr></thead><tbody><tr><td><strong>very little dataset</strong></td><td>Use Linear classifier on top layer</td><td>You’re in trouble.. Try linear classifier from different stages</td></tr><tr><td><strong>quite a lot of data</strong></td><td>Finetune a few layers</td><td>Finetune a large layers</td></tr></tbody></table></div><ul><li>Transfer learning is the normal not an exception.</li></ul><h2 id="08-Deep-learning-software"><a href="#08-Deep-learning-software" class="headerlink" title="08. Deep learning software"></a>08. Deep learning software</h2><ul><li>This section changes a lot every year in CS231n due to rabid changes in the deep learning softwares.</li><li>CPU vs GPU<ul><li>GPU The graphics card was developed to render graphics to play games or make 3D media,. etc.<ul><li>NVIDIA vs AMD<ul><li>Deep learning choose NVIDIA over AMD GPU because NVIDIA is pushing research forward deep learning also makes it architecture more suitable for deep learning.</li></ul></li></ul></li><li>CPU has fewer cores but each core is much faster and much more capable; great at sequential tasks. While GPUs has more cores but each core is much slower “dumber”; great for parallel tasks.</li><li>GPU cores needs to work together. and has its own memory.</li><li>Matrix multiplication is from the operations that are suited for GPUs. It has MxN independent operations that can be done on parallel.</li><li>Convolution operation also can be paralyzed because it has independent operations.</li><li>Programming GPUs frameworks:<ul><li><strong>CUDA</strong> (NVIDIA only)<ul><li>Write c-like code that runs directly on the GPU.</li><li>Its hard to build a good optimized code that runs on GPU. Thats why they provided high level APIs.</li><li>Higher level APIs: cuBLAS, cuDNN, etc</li><li><strong>CuDNN</strong> has implemented back prop. , convolution, recurrent and a lot more for you!</li><li>In practice you won’t write a parallel code. You will use the code implemented and optimized by others!</li></ul></li><li><strong>OpenCl</strong><ul><li>Similar to CUDA, but runs on any GPU.</li><li>Usually Slower .</li><li>Haven’t much support yet from all deep learning softwares.</li></ul></li></ul></li><li>There are a lot of courses for learning parallel programming.</li><li>If you aren’t careful, training can bottleneck on reading data and transferring to GPU. So the solutions are:<ul><li>Read all the data into RAM. # If possible</li><li>Use SSD instead of HDD</li><li>Use multiple CPU threads to prefetch data!<ul><li>While the GPU are computing, a CPU thread will fetch the data for you.</li><li>A lot of frameworks implemented that for you because its a little bit painful!</li></ul></li></ul></li></ul></li><li><strong>Deep learning Frameworks</strong><ul><li>Its super fast moving!</li><li>Currently available frameworks:<ul><li>Tensorflow (Google)</li><li>Caffe (UC Berkeley)</li><li>Caffe2 (Facebook)</li><li>Torch (NYU / Facebook)</li><li>PyTorch (Facebook)</li><li>Theano (U monteral) </li><li>Paddle (Baidu)</li><li>CNTK (Microsoft)</li><li>MXNet (Amazon)</li></ul></li><li>The instructor thinks that you should focus on Tensorflow and PyTorch.</li><li>The point of deep learning frameworks:<ul><li>Easily build big computational graphs.</li><li>Easily compute gradients in computational graphs.</li><li>Run it efficiently on GPU (cuDNN - cuBLAS)</li></ul></li><li>Numpy doesn’t run on GPU.</li><li>Most of the frameworks tries to be like NUMPY in the forward pass and then they compute the gradients for you.</li></ul></li><li><strong>Tensorflow (Google)</strong><ul><li>Code are two parts:<ol><li>Define computational graph.</li><li>Run the graph and reuse it many times.</li></ol></li><li>Tensorflow uses a static graph architecture.</li><li>Tensorflow variables live in the graph. while the placeholders are feed each run.</li><li>Global initializer function initializes the variables that lives in the graph.</li><li>Use predefined optimizers and losses.</li><li>You can make a full layers with layers.dense function.</li><li><strong>Keras</strong> (High level wrapper):<ul><li>Keras is a layer on top pf Tensorflow, makes common things easy to do.</li><li>So popular!</li><li>Trains a full deep NN in a few lines of codes.</li></ul></li><li>There are a lot high level wrappers:<ul><li>Keras</li><li>TFLearn</li><li>TensorLayer</li><li>tf.layers   <code>#Ships with tensorflow</code></li><li>tf-Slim   <code>#Ships with tensorflow</code></li><li>tf.contrib.learn   <code>#Ships with tensorflow</code></li><li>Sonnet <code># New from deep mind</code></li></ul></li><li>Tensorflow has pretrained models that you can use while you are using transfer learning.</li><li>Tensorboard adds logging to record loss, stats. Run server and get pretty graphs!</li><li>It has distributed code if you want to split your graph on some nodes.</li><li>Tensorflow is actually inspired from Theano. It has the same inspirations and structure.</li></ul></li></ul><ul><li><p><strong>PyTorch (Facebook)</strong></p><ul><li>Has three layers of abstraction:<ul><li>Tensor: <code>ndarray</code> but runs on GPU     <code>#Like numpy arrays in tensorflow</code><ul><li>Variable: Node in a computational graphs; stores data and gradient <code>#Like Tensor, Variable, Placeholders</code></li></ul></li><li>Module: A NN layer; may store state or learnable weights<code>#Like tf.layers in tensorflow</code></li></ul></li><li>In PyTorch the graphs runs in the same loop you are executing which makes it easier for debugging. This is called a dynamic graph.</li><li>In PyTorch you can define your own autograd functions by writing forward and backward for tensors. Most of the times it will implemented for you.</li><li>Torch.nn is a high level api like keras in tensorflow. You can create the models and go on and on.<ul><li>You can define your own nn module!</li></ul></li><li>Also Pytorch contains optimizers like tensorflow.</li><li>It contains a data loader that wraps a Dataset and provides minbatches, shuffling and multithreading.</li><li>PyTorch contains the best and super easy to use pretrained models</li><li>PyTorch contains Visdom that are like tensorboard. but Tensorboard seems to be more powerful.</li><li>PyTorch is new and still evolving compared to Torch. Its still in beta state.</li><li>PyTorch is best for research.</li></ul></li><li><p>Tensorflow builds the graph once, then run them many times (Called static graph)</p></li><li><p>In each PyTorch iteration we build a new graph (Called dynamic graph)</p></li><li><p><strong>Static vs dynamic graphs</strong>:</p><ul><li><p>Optimization:</p><ul><li>With static graphs, framework can optimize the graph for you before it runs.</li></ul></li><li><p>Serialization</p><ul><li><strong>Static</strong>: Once graph is built, can serialize it and run it without the code that built the graph. Ex use the graph in c++</li><li><strong>Dynamic</strong>: Always need to keep the code around.</li></ul></li><li><p>Conditional</p><ul><li>Is easier in dynamic graphs. And more complicated in static graphs.</li></ul></li><li><p>Loops:</p><ul><li>Is easier in dynamic graphs. And more complicated in static graphs.</li></ul></li></ul></li><li><p>Tensorflow fold make dynamic graphs easier in Tensorflow through dynamic batching.</p></li><li><p>Dynamic graph applications include: recurrent networks and recursive networks.</p></li><li><p>Caffe2 uses static graphs and can train model in python also works on IOS and Android</p></li><li><p>Tensorflow/Caffe2 are used a lot in production especially on mobile.</p></li></ul><h2 id="09-CNN-architectures"><a href="#09-CNN-architectures" class="headerlink" title="09. CNN architectures"></a>09. CNN architectures</h2><ul><li><p>This section talks about the famous CNN architectures. Focuses on CNN architectures that won <a href="www.image-net.org/">ImageNet</a> competition since 2012.</p><ul><li><img src="/2020/07/29/CS231N/43.png" alt></li></ul></li><li><p>These architectures includes: <a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener">AlexNet</a>, <a href="https://arxiv.org/abs/1409.1556" target="_blank" rel="noopener">VGG</a>, <a href="https://research.google.com/pubs/pub43022.html" target="_blank" rel="noopener">GoogLeNet</a>, and <a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="noopener">ResNet</a>.</p></li><li><p>Also we will discuss some interesting architectures as we go.</p></li><li><p>The first ConvNet that was made was <a href="http://ieeexplore.ieee.org/document/726791/" target="_blank" rel="noopener">LeNet-5</a> architectures are:by Yann Lecun at 1998.</p><ul><li>Architecture are: <code>CONV-POOL-CONV-POOL-FC-FC-FC</code><ul><li><img src="/2020/07/29/CS231N/02.jpg" alt></li></ul></li><li>Each conv filters was <code>5x5</code> applied at stride 1</li><li>Each pool was <code>2x2</code> applied at stride <code>2</code></li><li>It was useful in Digit recognition.</li><li>In particular the insight that image features are distributed across the entire image, and convolutions with learnable parameters are an effective way to extract similar features at multiple location with few parameters.</li><li>It contains exactly <strong><u>5 </u></strong> layers</li></ul></li><li><p>In <a href="https://arxiv.org/abs/1003.0358" target="_blank" rel="noopener">2010</a> Dan Claudiu Ciresan and Jurgen Schmidhuber published one of the very fist implementations of GPU Neural nets. This implementation had both forward and backward implemented on a a NVIDIA GTX 280 graphic processor of an up to 9 layers neural network.</p></li><li><p><a href="https://papers.nips.cc/paper/4824-imagenet-classification-with-deep-convolutional-neural-networks.pdf" target="_blank" rel="noopener"><strong>AlexNet</strong></a> (2012):</p><ul><li>ConvNet that started the evolution and wins the ImageNet at 2012.</li><li>Architecture are: <code>CONV1-MAXPOOL1-NORM1-CONV2-MAXPOOL2-NORM2-CONV3-CONV4-CONV5-MAXPOOL3-FC6-FC7-FC8</code></li><li>Contains exactly <strong><u>8</u></strong> layers the first 5 are Convolutional and the last 3 are fully connected layers.</li><li>AlexNet accuracy error was <code>16.4%</code></li><li>For example if the input is 227 x 227 x3 then these are the shapes of the of the outputs at each layer:<ul><li>CONV1    (96 11 x 11 filters at stride 4, pad 0)<ul><li>Output shape <code>(55,55,96)</code>,   Number of weights are <code>(11*11*3*96)+96 = 34944</code></li></ul></li><li>MAXPOOL1 (3 x 3 filters applied at stride 2)<ul><li>Output shape <code>(27,27,96)</code>,   No Weights</li></ul></li><li>NORM1<ul><li>Output shape <code>(27,27,96)</code>,     We don’t do this any more</li></ul></li><li>CONV2 (256 5 x 5 filters at stride 1, pad 2)</li><li>MAXPOOL2 (3 x 3 filters at stride 2)</li><li>NORM2</li><li>CONV3 (384 3 x 3 filters ar stride 1, pad 1)</li><li>CONV4 (384 3 x 3 filters ar stride 1, pad 1)</li><li>CONV5 (256 3 x 3 filters ar stride 1, pad 1)</li><li>MAXPOOL3 (3 x 3 filters at stride 2)<ul><li>Output shape <code>(6,6,256)</code></li></ul></li><li>FC6 (4096)</li><li>FC7 (4096)</li><li>FC8 (1000 neurons for class score)</li></ul></li><li>Some other details:<ul><li>First use of RELU.</li><li>Norm layers but not used any more.</li><li>heavy data augmentation</li><li>Dropout <code>0.5</code></li><li>batch size <code>128</code></li><li>SGD momentum <code>0.9</code></li><li>Learning rate <code>1e-2</code> reduce by 10 at some iterations</li><li>7 CNN ensembles!</li></ul></li><li>AlexNet was trained on GTX 580 GPU with only 3 GB which wasn’t enough to train in one machine so they have spread the feature maps in half. The first AlexNet was distributed!</li><li>Its still used in transfer learning in a lot of tasks.</li><li>Total number of parameters are <code>60 million</code></li></ul></li><li><p><a href="https://arxiv.org/abs/1311.2901" target="_blank" rel="noopener"><strong>ZFNet</strong></a> (2013)</p><ul><li>Won in 2013 with error 11.7%</li><li>It has the same general structure but they changed a little in hyperparameters to get the best output.</li><li>Also contains <strong><u>8</u></strong> layers.</li><li>AlexNet but:<ul><li><code>CONV1</code>: change from (11 x 11 stride 4) to (7 x 7 stride 2)</li><li><code>CONV3,4,5</code>: instead of 384, 384, 256 filters use 512, 1024, 512</li></ul></li></ul></li><li><p><a href="https://arxiv.org/abs/1312.6229" target="_blank" rel="noopener">OverFeat</a> (2013)</p><ul><li>Won the localization in imageNet in 2013</li><li>We show how a multiscale and sliding window approach can be efficiently implemented within a ConvNet. We also introduce a novel deep learning approach to localization by learning to predict object boundaries.</li></ul></li><li><p><a href="https://arxiv.org/pdf/1409.1556" target="_blank" rel="noopener"><strong>VGGNet</strong></a> (2014) (Oxford)</p><ul><li>Deeper network with more layers.</li><li>Contains 19 layers.</li><li>Won on 2014 with GoogleNet with error 7.3%</li><li>Smaller filters with deeper layers.</li><li>The great advantage of VGG was the insight that multiple 3 × 3 convolution in sequence can emulate the effect of larger receptive fields, for examples 5 × 5 and 7 × 7.</li><li>Used the simple 3 x 3 Conv all through the network.<ul><li>3 (3 x 3) filters has the same effect as 7 x 7</li></ul></li><li><img src="/2020/07/29/CS231N/03.png" alt></li><li>The Architecture contains several CONV layers then POOL layer over 5 times and then the full connected layers.</li><li>It has a total memory of 96MB per image for only forward propagation!<ul><li>Most memory are in the earlier layers</li></ul></li><li>Total number of parameters are 138 million<ul><li>Most of the parameters are in the fully connected layers</li></ul></li><li>Has a similar details in training like AlexNet. Like using momentum and dropout.</li><li>VGG19 are an upgrade for VGG16 that are slightly better but with more memory<ul><li><img src="/2020/07/29/CS231N/04.png" alt></li></ul></li></ul></li><li><p><a href="https://research.google.com/pubs/pub43022.html" target="_blank" rel="noopener"><strong>GoogleNet</strong></a> (2014)</p><ul><li>Deeper network with more layers.</li><li>Contains 22 layers.</li><li>It has Efficient <strong><u>Inception</u></strong> module.</li><li>Only 5 million parameters! 12x less than AlexNet</li><li>Won on 2014 with VGGNet with error 6.7%</li><li>Inception module:<ul><li>Design a good local network topology (network within a network (NiN)) and then stack these modules on top of each other.</li><li>It consists of:<ul><li>Apply parallel filter operations on the input from previous layer<ul><li>Multiple convs of sizes (1 x 1, 3 x 3, 5 x 5) <ul><li>Adds padding to maintain the sizes.</li></ul></li><li>Pooling operation. (Max Pooling)<ul><li>Adds padding to maintain the sizes.</li></ul></li></ul></li><li>Concatenate all filter outputs together depth-wise.</li></ul></li><li>For example:<ul><li>Input for inception module is 28 x 28 x 256</li><li>Then the parallel filters applied:<ul><li>(1 x 1), 128 filter               <code># output shape (28,28,128)</code></li><li>(3 x 3), 192 filter                 <code># output shape (28,28,192)</code></li><li>(5 x 5), 96 filter                   <code># output shape (28,28,96)</code></li><li>(3 x 3) Max pooling            <code># output shape (28,28,256)</code></li></ul></li><li>After concatenation this will be <code>(28,28,672)</code></li></ul></li><li>By this design -We call Naive- it has a big computation complexity.<ul><li>The last example will make:<ul><li>[1 x 1 conv, 128] ==&gt; 28 <em> 28 </em> 128 <em> 1 </em> 1 * 256 = 25 Million approx</li><li>[3 x 3 conv, 192] ==&gt; 28 <em> 28 </em> 192 <em>3 </em>3 * 256 = 346 Million approx</li><li>[5 x 5 conv, 96] ==&gt; 28 <em> 28 </em> 96 <em> 5 </em> 5 * 256 = 482 Million approx</li><li>In total around 854 Million operation!</li></ul></li></ul></li><li>Solution: <strong>bottleneck</strong> layers that use 1x1 convolutions to reduce feature depth.<ul><li>Inspired from NiN (<a href="https://arxiv.org/abs/1312.4400" target="_blank" rel="noopener">Network in network</a>)</li></ul></li><li><img src="/2020/07/29/CS231N/05.png" alt></li><li>The bottleneck solution will make a total operations of 358M on this example which is good compared with the naive implementation.</li></ul></li><li>So GoogleNet stacks this Inception module multiple times to get a full architecture of a network that can solve a problem without the Fully connected layers.</li><li>Just to mention, it uses an average pooling layer at the end before the classification step.</li><li>Full architecture:<ul><li><img src="/2020/07/29/CS231N/44.png" alt></li></ul></li><li>In February 2015 Batch-normalized Inception was introduced as Inception V2. Batch-normalization computes the mean and standard-deviation of all feature maps at the output of a layer, and normalizes their responses with these values.</li><li>In December <a href="https://arxiv.org/abs/1512.00567" target="_blank" rel="noopener">2015</a> they introduced a paper “Rethinking the Inception Architecture for Computer Vision” which explains the older inception models well also introducing a new version V3.</li></ul></li><li><p>The first GoogleNet and VGG was before batch normalization invented so they had some hacks to train the NN and converge well.</p></li><li><p><a href="https://arxiv.org/abs/1512.03385" target="_blank" rel="noopener"><strong>ResNet</strong></a> (2015) (Microsoft Research)</p><ul><li><p>152-layer model for ImageNet. Winner by 3.57% which is more than human level error.</p></li><li><p>This is also the very first time that a network of &gt; hundred, even 1000 layers was trained.</p></li><li><p>Swept all classification and detection competitions in ILSVRC’15 and COCO’15!</p></li><li><p>What happens when we continue stacking deeper layers on a “plain” Convolutional neural network?</p><ul><li>The deeper model performs worse, but it’s not caused by overfitting!</li><li>The learning stops performs well somehow because deeper NN are harder to optimize!</li></ul></li><li><p>The deeper model should be able to perform at least as well as the shallower model.</p></li><li><p>A solution by construction is copying the learned layers from the shallower model and setting additional layers to identity mapping.</p></li><li><p>Residual block:</p><ul><li><p>Microsoft came with the Residual block which has this architecture:</p><ul><li><img src="/2020/07/29/CS231N/45.png" alt></li></ul><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Instead of us trying To learn a new representation, We learn only Residual</span></span><br><span class="line">Y = (W2* RELU(W1x+b1) + b2) + X</span><br></pre></td></tr></table></figure></li><li><p>Say you have a network till a depth of N layers. You only want to add a new layer if you get something extra out of adding that layer.</p></li><li><p>One way to ensure this new (N+1)th layer learns something new about your network is to also provide the input(x) without any transformation to the output of the (N+1)th layer. This essentially drives the new layer to learn something different from what the input has already encoded.</p></li><li><p>The other advantage is such connections help in handling the Vanishing gradient problem in very deep networks.</p></li></ul></li><li><p>With the Residual block we can now have a deep NN of any depth without the fearing that we can’t optimize the network.</p></li><li><p>ResNet with a large number of layers started to use a bottleneck layer similar to the Inception bottleneck to reduce the dimensions.</p><ul><li><img src="/2020/07/29/CS231N/07.jpg" alt></li></ul></li><li><p><strong><u>Full ResNet architecture</u></strong>:</p><ul><li>Stack residual blocks.<ul><li><img src="/2020/07/29/CS231N/08.png" alt></li></ul></li><li>Every residual block has two 3 x 3 conv layers.</li><li>Additional conv layer at the beginning.</li><li>No FC layers at the end (only FC 1000 to output classes)</li><li>Periodically, double number of filters and downsample spatially using stride 2 (/2 in each dimension)</li><li>Training ResNet in practice:<ul><li>Batch Normalization after every CONV layer.</li><li>Xavier/2 initialization from He et al.</li><li>SGD + Momentum (<code>0.9</code>) </li><li>Learning rate: 0.1, divided by 10 when validation error plateaus</li><li>Mini-batch size <code>256</code></li><li>Weight decay of <code>1e-5</code></li><li>No dropout used.</li></ul></li></ul></li></ul></li><li><p><a href="https://arxiv.org/abs/1602.07261" target="_blank" rel="noopener">Inception-v4</a>: Resnet + Inception and was founded in 2016.</p></li><li><p>The complexity comparing over all the architectures:</p><ul><li><img src="/2020/07/29/CS231N/09.png" alt></li><li>VGG: Highest memory, most operations.</li><li>GoogLeNet: most efficient.</li></ul></li><li><p><strong>ResNets Improvements</strong>:</p><ul><li>(<a href="https://arxiv.org/abs/1603.05027" target="_blank" rel="noopener">2016</a>) <u>Identity Mappings in Deep Residual Networks</u><ul><li>From the creators of ResNet.</li><li>Gives better performance.</li></ul></li><li>(<a href="https://arxiv.org/abs/1605.07146" target="_blank" rel="noopener">2016</a>) <u>Wide Residual Networks</u><ul><li>Argues that residuals are the important factor, not depth</li><li>50-layer wide ResNet outperforms 152-layer original ResNet</li><li>Increasing width instead of depth more computationally efficient (parallelizable)</li></ul></li><li>(<a href="https://arxiv.org/abs/1603.09382" target="_blank" rel="noopener">2016</a>) Deep Networks with Stochastic Depth<ul><li>Motivation: reduce vanishing gradients and training time through short networks during training.</li><li>Randomly drop a subset of layers during each training pass</li><li>Use full deep network at test time.</li></ul></li></ul></li><li><p><strong>Beyond ResNets</strong>:</p><ul><li>(<a href="https://arxiv.org/abs/1605.07648" target="_blank" rel="noopener">2017</a>) <u>FractalNet: Ultra-Deep Neural Networks without Residuals</u><ul><li>Argues that key is transitioning effectively from shallow to deep and residual representations are not necessary.</li><li>Trained with dropping out sub-paths</li><li>Full network at test time.</li></ul></li><li>(<a href="https://arxiv.org/abs/1608.06993" target="_blank" rel="noopener">2017</a>) <u>Densely Connected Convolutional Networks</u></li><li>(<a href="https://arxiv.org/abs/1602.07360" target="_blank" rel="noopener">2017</a>) SqueezeNet: AlexNet-level Accuracy With 50x Fewer Parameters and &lt;0.5Mb Model Size<ul><li>Good for production.</li><li>It is a re-hash of many concepts from ResNet and Inception, and show that after all, a better design of architecture will deliver small network sizes and parameters without needing complex compression algorithms.</li></ul></li></ul></li><li><p>Conclusion:</p><ul><li>ResNet current best default.</li><li>Trend towards extremely deep networks</li><li>In the last couple of years, some models all using the shortcuts like “ResNet” to eaisly flow the gradients.</li></ul></li></ul><h2 id="10-Recurrent-Neural-networks"><a href="#10-Recurrent-Neural-networks" class="headerlink" title="10. Recurrent Neural networks"></a>10. Recurrent Neural networks</h2><ul><li><p>Vanilla Neural Networks “Feed neural networks”, input of fixed size goes through some hidden units and then go to output. We call it a one to one network.</p></li><li><p>Recurrent Neural Networks RNN Models:</p><ul><li><img src="/2020/07/29/CS231N/46.png" alt></li><li>One to many<ul><li>Example: Image Captioning<ul><li>image ==&gt; sequence of words</li></ul></li></ul></li><li>Many to One<ul><li>Example: Sentiment Classification<ul><li>sequence of words ==&gt; sentiment</li></ul></li></ul></li><li>Many to many<ul><li>Example: Machine Translation<ul><li>seq of words in one language ==&gt; seq of words in another language</li></ul></li><li>Example: Video classification on frame level</li></ul></li></ul></li><li><p>RNNs can also work for Non-Sequence Data (One to One problems)</p><ul><li>It worked in Digit classification through taking a series of “glimpses”<ul><li>“<a href="https://arxiv.org/abs/1412.7755" target="_blank" rel="noopener">Multiple Object Recognition with Visual Attention</a>”, ICLR 2015.</li></ul></li><li>It worked on generating images one piece at a time<ul><li>i.e generating a <a href="http://ieeexplore.ieee.org/document/7966808/" target="_blank" rel="noopener">captcha</a></li></ul></li></ul></li><li><p>So what is a recurrent neural network?</p><ul><li><p>Recurrent core cell that take an input x and that cell has an internal state that are updated each time it reads an input.</p></li><li><p><img src="/2020/07/29/CS231N/47.png" alt></p></li><li><p>The RNN block should return a vector.</p></li><li><p>We can process a sequence of vectors x by applying a recurrence formula at every time step:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[t] = fw (h[t<span class="number">-1</span>], x[t])</span><br><span class="line"><span class="comment"># Where fw is some function with parameters W</span></span><br></pre></td></tr></table></figure><ul><li>The same function and the same set of parameters are used at every time step.</li></ul></li><li><p>(Vanilla) Recurrent Neural Network:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">h[t] &#x3D; tanh (W[h,h]*h[t-1] + W[x,h]*x[t])    # Then we save h[t]</span><br><span class="line">y[t] &#x3D; W[h,y]*h[t]</span><br></pre></td></tr></table></figure><ul><li>This is the simplest example of a RNN.</li></ul></li><li><p>RNN works on a sequence of related data.</p></li></ul></li><li><p>Recurrent NN Computational graph:</p><ul><li><img src="/2020/07/29/CS231N/10.png" alt></li><li><code>h0</code> are initialized to zero.</li><li>Gradient of <code>W</code> is the sum of all the <code>W</code> gradients that has been calculated!</li><li>A many to many graph:<ul><li><img src="/2020/07/29/CS231N/11.png" alt></li><li>Also the last is the sum of all losses and the weights of Y is one and is updated through summing all the gradients!</li></ul></li><li>A many to one graph:<ul><li><img src="/2020/07/29/CS231N/12.png" alt></li></ul></li><li>A one to many graph:<ul><li><img src="/2020/07/29/CS231N/13.png" alt></li></ul></li><li>sequence to sequence graph:<ul><li><img src="/2020/07/29/CS231N/14.png" alt></li><li>Encoder and decoder philosophy.</li></ul></li></ul></li><li><p>Examples:</p><ul><li>Suppose we are building words using characters. We want a model to predict the next character of a sequence. Lets say that the characters are only <code>[h, e, l, o]</code> and the words are [hello]<ul><li>Training:<ul><li><img src="/2020/07/29/CS231N/15.png" alt></li><li>Only the third prediction here is true. The loss needs to be optimized.</li><li>We can train the network by feeding the whole word(s).</li></ul></li><li>Testing time:<ul><li><img src="/2020/07/29/CS231N/16.png" alt></li><li>At test time we work with a character by character. The output character will be the next input with the other saved hidden activations.</li><li>This <a href="https://gist.github.com/karpathy/d4dee566867f8291f086" target="_blank" rel="noopener">link</a> contains all the code but uses Truncated Backpropagation through time as we will discuss.</li></ul></li></ul></li></ul></li><li><p>Backpropagation through time Forward through entire sequence to compute loss, then backward through entire sequence to compute gradient.</p><ul><li>But if we choose the whole sequence it will be so slow and take so much memory and will never converge!</li></ul></li><li><p>So in practice people are doing “Truncated Backpropagation through time” as we go on we Run forward and backward through chunks of the sequence instead of whole sequence</p><ul><li>Then Carry hidden states forward in time forever, but only backpropagate for some smaller number of steps.</li></ul></li><li><p>Example on image captioning:</p><ul><li><img src="/2020/07/29/CS231N/17.png" alt></li><li>They use <End> token to finish running.</End></li><li>The biggest dataset for image captioning is Microsoft COCO.</li></ul></li><li><p>Image Captioning with Attention is a project in which when the RNN is generating captions, it looks at a specific part of the image not the whole image.</p><ul><li>Image Captioning with Attention technique is also used in “Visual Question Answering” problem</li></ul></li><li><p>Multilayer RNNs is generally using some layers as the hidden layer that are feed into again. <strong>LSTM</strong> is a multilayer RNNs.</p></li><li><p>Backward flow of gradients in RNN can explode or vanish. Exploding is controlled with gradient clipping. Vanishing is controlled with additive interactions (LSTM)</p></li><li><p>LSTM stands for Long Short Term Memory. It was designed to help the vanishing gradient problem on RNNs.</p><ul><li>It consists of:<ul><li>f: Forget gate, Whether to erase cell</li><li>i: Input gate, whether to write to cell</li><li>g: Gate gate (?), How much to write to cell</li><li>o: Output gate, How much to reveal cell</li></ul></li><li><img src="/2020/07/29/CS231N/18.png" alt></li><li><img src="/2020/07/29/CS231N/18.1.png" alt></li><li>The LSTM gradients are easily computed like ResNet</li><li>The LSTM is keeping data on the long or short memory as it trains means it can remember not just the things from last layer but layers.</li></ul></li><li><p>Highway networks is something between ResNet and LSTM that is still in research.</p></li><li><p>Better/simpler architectures are a hot topic of current research</p></li><li><p>Better understanding (both theoretical and empirical) is needed.</p></li><li><p>RNN is used for problems that uses sequences of related inputs more. Like NLP and Speech recognition.</p></li></ul><h2 id="11-Detection-and-Segmentation"><a href="#11-Detection-and-Segmentation" class="headerlink" title="11. Detection and Segmentation"></a>11. Detection and Segmentation</h2><ul><li><p>So far we are talking about image classification problem. In this section we will talk about Segmentation, Localization, Detection.</p></li><li><p><strong><u>Semantic Segmentation</u></strong></p><ul><li><p>We want to Label each pixel in the image with a category label.</p></li><li><p><img src="/2020/07/29/CS231N/19.png" alt></p></li><li><p>As you see the cows in the image, Semantic Segmentation Don’t differentiate instances, only care about pixels.</p></li><li><p>The first idea is to use a <strong>sliding window</strong>. We take a small window size and slide it all over the picture. For each window we want to label the center pixel.</p><ul><li>It will work but its not a good idea because it will be computational expensive!</li><li>Very inefficient! Not reusing shared features between overlapping patches.</li><li>In practice nobody uses this.</li></ul></li><li><p>The second idea is designing a network as a bunch of Convolutional layers to make predictions for pixels all at once!</p><ul><li>Input is the whole image. Output is the image with each pixel labeled.</li><li>We need a lot of labeled data. And its very expensive data.</li><li>It needs a deep Conv. layers.</li><li>The loss is cross entropy between each pixel provided.</li><li>Data augmentation are good here.</li><li>The problem with this implementation that convolutions at original image resolution will be very expensive.</li><li>So in practice we don’t see something like this right now.</li></ul></li><li><p>The third idea is based on the last idea. The difference is that we are downsampling and upsampling inside the network.</p><ul><li><p>We downsample because using the whole image as it is very expensive. So we go on multiple layers downsampling and then upsampling in the end.</p></li><li><p>Downsampling is an operation like Pooling and strided convolution.</p></li><li><p>Upsampling is like “Nearest Neighbor” or “Bed of Nails” or “Max unpooling”</p><ul><li><p><strong>Nearest Neighbor</strong> example:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:   1  2               Output:   1  1  2  2</span><br><span class="line">         3  4                         1  1  2  2</span><br><span class="line">                                      3  3  4  4</span><br><span class="line">                                      3  3  4  4</span><br></pre></td></tr></table></figure></li><li><p><strong>Bed of Nails</strong> example:</p>  <figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Input:   1  2               Output:   1  0  2  0</span><br><span class="line">         3  4                         0  0  0  0</span><br><span class="line">                                      3  0  4  0</span><br><span class="line">                                      0  0  0  0</span><br></pre></td></tr></table></figure></li><li><p><strong>Max unpooling</strong> is depending on the earlier steps that was made by max pooling. You fill the pixel where max pooling took place and then fill other pixels by zero.</p></li></ul></li><li><p>Max unpooling seems to be the best idea for upsampling.</p></li><li><p>There are an idea of Learnable Upsampling called “<strong>Transpose Convolution</strong>“</p><ul><li>Rather than making a convolution we make the reverse. </li><li>Also called:<ul><li>Upconvolution.</li><li>Fractionally strided convolution</li><li>Backward strided convolution</li></ul></li><li>Learn the artimitic of the upsampling please refer to chapter 4 in this <a href="https://arxiv.org/abs/1603.07285" target="_blank" rel="noopener">paper</a>.</li></ul></li></ul></li></ul></li><li><p><strong><u>Classification + Localization</u></strong>:</p><ul><li>In this problem we want to classify the main object in the image and its location as a rectangle.</li><li>We assume there are one object.</li><li>We will create a multi task NN. The architecture are as following:<ul><li>Convolution network layers connected to:<ul><li>FC layers that classify the object. <code># The plain classification problem we know</code></li><li>FC layers that connects to a four numbers <code>(x,y,w,h)</code><ul><li>We treat Localization as a regression problem.</li></ul></li></ul></li></ul></li><li>This problem will have two losses:<ul><li>Softmax loss for classification</li><li>Regression (Linear loss) for the localization (L2 loss)</li></ul></li><li>Loss = SoftmaxLoss + L2 loss</li><li>Often the first Conv layers are pretrained NNs like AlexNet!</li><li>This technique can be used in so many other problems like:  Human Pose Estimation.</li></ul></li><li><p><strong><u>Object Detection</u></strong></p><ul><li>A core idea of computer vision. We will talk by details in this problem.</li><li>The difference between “Classification + Localization” and this problem is that here we want to detect one or mode different objects and its locations!</li><li>First idea is to use a sliding window<ul><li>Worked well and long time.</li><li>The steps are:<ul><li>Apply a CNN to many different crops of the image, CNN classifies each crop as object or background.</li></ul></li><li>The problem is we need  to apply CNN to huge number of locations and scales, very computationally expensive!</li><li>The brute force sliding window will make us take thousands of thousands of time.</li></ul></li><li>Region Proposals will help us deciding which region we should run our NN at:<ul><li>Find <strong>blobby</strong> image regions that are likely to contain objects.</li><li>Relatively fast to run; e.g. Selective Search gives 1000 region proposals in a few seconds on CPU</li></ul></li><li>So now we can apply one of the Region proposals networks and then apply the first idea.</li><li>There is another idea which is called R-CNN<ul><li><img src="/2020/07/29/CS231N/20.png" alt></li><li>The idea is bad because its taking parts of the image -With Region Proposals- if different sizes and feed it to CNN after scaling them all to one size. Scaling is bad</li><li>Also its very slow.</li></ul></li><li>Fast R-CNN is another idea that developed on R-CNN<ul><li><img src="/2020/07/29/CS231N/48.png" alt></li><li>It uses one CNN to do everything.</li></ul></li><li>Faster R-CNN does its own region proposals by Inserting Region Proposal Network (RPN) to predict proposals from features.<ul><li>The fastest of the R-CNNs.</li></ul></li><li>Another idea is Detection without Proposals: YOLO / SSD<ul><li>YOLO stands for you only look once.</li><li>YOLO/SDD is two separate algorithms.</li><li>Faster but not as accurate.</li></ul></li><li>Takeaways<ul><li>Faster R-CNN is slower but more accurate.</li><li>SSD/YOLO is much faster but not as accurate.</li></ul></li></ul></li><li><p><strong><u>Denese Captioning</u></strong></p><ul><li>Denese Captioning is “Object Detection + Captioning”</li><li>Paper that covers this idea can be found <a href="https://arxiv.org/abs/1511.07571" target="_blank" rel="noopener">here</a>.</li></ul></li><li><p><strong><u>Instance Segmentation</u></strong></p><ul><li>This is like the full problem.</li><li><img src="/2020/07/29/CS231N/49.png" alt></li><li>Rather than we want to predict the bounding box, we want to know which pixel label but also distinguish them.</li><li>There are a lot of ideas.</li><li>There are a new idea “Mask R-CNN”<ul><li>Like R-CNN but inside it we apply the Semantic Segmentation</li><li>There are a lot of good results out of this paper.</li><li>It sums all the things that we have discussed in this lecture.</li><li>Performance of this seems good.</li></ul></li></ul></li></ul><h2 id="12-Visualizing-and-Understanding"><a href="#12-Visualizing-and-Understanding" class="headerlink" title="12. Visualizing and Understanding"></a>12. Visualizing and Understanding</h2><ul><li><p>We want to know what’s going on inside ConvNets?</p></li><li><p>People want to trust the black box (CNN) and know how it exactly works and give and good decisions.</p></li><li><p>A first approach is to visualize filters of the first layer.</p><ul><li>Maybe the shape of the first layer filter is 5 x 5 x 3, and the number of filters are 16. Then we will have 16 different “colored” filter images.</li><li>It turns out that these filters learns primitive shapes and oriented edges like the human brain does.</li><li>These filters really looks the same on each Conv net you will train, Ex if you tried to get it out of AlexNet, VGG, GoogleNet, or ResNet.</li><li>This will tell you what is the first convolution layer is looking for in the image.</li></ul></li><li><p>We can visualize filters from the next layers but they won’t tell us anything.</p><ul><li>Maybe the shape of the first layer filter is 5 x 5 x 20, and the number of filters are 16. Then we will have 16*20 different “gray” filter images.</li></ul></li><li><p>In AlexNet, there was some FC layers in the end. If we took the 4096-dimensional feature vector for an image, and collecting these feature vectors.</p><ul><li>If we made a nearest neighbors between these feature vectors and get the real images of these features we will get something very good compared with running the KNN on the images directly!</li><li><img src="/2020/07/29/CS231N/21.png" alt></li><li>This similarity tells us that these CNNs are really getting the semantic meaning of these images instead of on the pixels level!</li><li>We can make a dimensionality reduction on the 4096 dimensional feature and compress it to 2 dimensions.<ul><li>This can be made by PCA, or t-SNE.</li><li>t-SNE are used more with deep learning to visualize the data. Example can be found <a href="http://cs.stanford.edu/people/karpathy/cnnembed/" target="_blank" rel="noopener">here</a>.</li></ul></li></ul></li><li><p>We can Visualize the activation maps.</p><ul><li>For example if CONV5 feature map is 128 x 13 x 13, We can visualize it as 128 13 x 13 gray-scale images.</li><li><img src="/2020/07/29/CS231N/50.png" alt></li><li>One of these features are activated corresponding to the input, so now we know that this particular map are looking for something.</li><li>Its done by Yosinski et. More info are <a href="http://yosinski.com/deepvis#toolbox" target="_blank" rel="noopener">here</a>.</li></ul></li><li><p>There are something called <strong>Maximally Activating Patches</strong> that can help us visualize the intermediate features in Convnets</p><ul><li>The steps of doing this is as following:<ul><li>We choose a layer then a neuron<ul><li>Ex. We choose Conv5 in AlexNet which is 128 x 13 x 13 then pick channel (Neuron) 17/128</li></ul></li><li>Run many images through the network, record values of chosen channel.</li><li>Visualize image patches that correspond to maximal activations.<ul><li>We will find that each neuron is looking into a specific part of the image.</li><li>Extracted images are extracted using receptive field.</li></ul></li></ul></li></ul></li><li><p>Another idea is <strong>Occlusion Experiments</strong></p><ul><li>We mask part of the image before feeding to CNN, draw heat-map of probability (Output is true) at each mask location</li><li>It will give you the most important parts of the image in which the Conv. Network has learned from.</li><li><img src="/2020/07/29/CS231N/51.png" alt></li></ul></li><li><p><strong>Saliency Maps</strong> tells which pixels matter for classification</p><ul><li>Like Occlusion Experiments but with a completely different approach</li><li>We Compute gradient of (unnormalized) class score with respect to image pixels, take absolute value and max over RGB channels. It will get us a gray image that represents the most important areas in the image.</li><li>This can be used for Semantic Segmentation sometimes.</li></ul></li><li><p>(guided) backprop Makes something like <strong>Maximally Activating Patches</strong> but unlike it gets the pixels in which we are caring of.</p><ul><li>In this technique choose a channel like Maximally Activating Patches and then compute gradient of neuron value with respect to image pixels</li><li>Images come out nicer if you only backprop positive gradients through each RELU (guided backprop)</li></ul></li><li><p><strong>Gradient Ascent</strong></p><ul><li><p>Generate a synthetic image that maximally activates a neuron.</p></li><li><p>Reverse of gradient decent. Instead of taking the minimum it takes the maximum.</p></li><li><p>We want to maximize the neuron with the input image. So here instead we are trying to learn the image that maximize the activation:</p>  <figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># R(I) is Natural image regularizer, f(I) is the neuron value.</span></span><br><span class="line">I *= argmax(f(I)) + R(I)</span><br></pre></td></tr></table></figure></li><li><p>Steps of gradient ascent</p><ul><li>Initialize image to zeros.</li><li>Forward image to compute current scores.</li><li>Backprop to get gradient of neuron value with respect to image pixels.</li><li>Make a small update to the image</li></ul></li><li><p><code>R(I)</code> may equal to L2 of generated image.</p></li><li><p>To get a better results we use a better regularizer:</p><ul><li>penalize L2 norm of image; also during optimization periodically:<ul><li>Gaussian blur image</li><li>Clip pixels with small values to 0</li><li>Clip pixels with small gradients to 0</li></ul></li></ul></li><li><p>A better regularizer makes out images cleaner!</p></li><li><p><img src="/2020/07/29/CS231N/22.png" alt></p></li><li><p>The results in the latter layers seems to mean something more than the other layers.</p></li></ul></li><li><p>We can fool CNN by using this procedure:</p><ul><li>Start from an arbitrary image.            <code># Random picture based on nothing.</code></li><li>Pick an arbitrary class. <code># Random class</code></li><li>Modify the image to maximize the class.</li><li>Repeat until network is fooled.</li></ul></li><li><p>Results on fooling the network is pretty surprising!</p><ul><li><img src="/2020/07/29/CS231N/23.png" alt></li><li>For human eyes they are the same, but it fooled the network by adding just some noise!</li></ul></li><li><p><strong>DeepDream</strong>: Amplify existing features</p><ul><li>Google released deep dream on their website.</li><li>What its actually doing is the same procedure as fooling the NN that we discussed, but rather than synthesizing an image to maximize a specific neuron, instead try to amplify the neuron activations at some layer in the network.</li><li>Steps:<ul><li>Forward: compute activations at chosen layer.        <code># form an input image (Any image)</code></li><li>Set gradient of chosen layer equal to its activation.<ul><li>Equivalent to <code>I* = arg max[I] sum(f(I)^2)</code></li></ul></li><li>Backward: Compute gradient on image.</li><li>Update image.</li></ul></li><li>The code of deep dream is online you can download and check it yourself.</li></ul></li><li><p><strong>Feature Inversion</strong></p><ul><li>Gives us to know what types of elements parts of the image are captured at different layers in the network.</li><li>Given a CNN feature vector for an image, find a new image that: <ul><li>Matches the given feature vector.</li><li><em>looks natural</em> (image prior regularization) </li></ul></li></ul></li><li><p><strong>Texture Synthesis</strong></p><ul><li>Old problem in computer graphics.</li><li>Given a sample patch of some texture, can we generate a bigger image of the same texture?</li><li>There is an algorithm which doesn’t depend on NN:<ul><li>Wei and Levoy, Fast Texture Synthesis using Tree-structured Vector Quantization, SIGGRAPH 2000</li><li>Its a really simple algorithm</li></ul></li><li>The idea here is that this is an old problem and there are a lot of algorithms that has already solved it but simple algorithms doesn’t work well on complex textures!</li><li>An idea of using NN has been proposed on 2015 based on gradient ascent and called it “Neural Texture Synthesis”<ul><li>It depends on something called Gram matrix.</li></ul></li></ul></li><li><p>Neural Style Transfer =  Feature + Gram Reconstruction</p><ul><li>Gatys, Ecker, and Bethge, Image style transfer using Convolutional neural networks, CVPR 2016</li><li>Implementation by pytorch <a href="https://github.com/jcjohnson/neural-style" target="_blank" rel="noopener">here</a>.</li></ul></li><li><p>Style transfer requires many forward / backward passes through VGG; very slow!</p><ul><li>Train another neural network to perform style transfer for us!</li><li>Fast Style Transfer is the solution.</li><li>Johnson, Alahi, and Fei-Fei, Perceptual Losses for Real-Time Style Transfer and Super-Resolution, ECCV 2016</li><li><a href="https://github.com/jcjohnson/fast-neural-style" target="_blank" rel="noopener">https://github.com/jcjohnson/fast-neural-style</a></li></ul></li><li><p>There are a lot of work on these style transfer and it continues till now!</p></li><li><p>Summary:</p><ul><li>Activations: Nearest neighbors, Dimensionality reduction, maximal patches, occlusion</li><li>Gradients: Saliency maps, class visualization, fooling images, feature inversion</li><li>Fun: DeepDream, Style Transfer</li></ul></li></ul><h2 id="13-Generative-models"><a href="#13-Generative-models" class="headerlink" title="13. Generative models"></a>13. Generative models</h2><ul><li><p>Generative models are type of Unsupervised learning.</p></li><li><p>Supervised vs Unsupervised Learning:</p></li></ul><div class="table-container"><table><thead><tr><th></th><th>Supervised Learning</th><th>Unsupervised Learning</th></tr></thead><tbody><tr><td>Data structure</td><td>Data: (x, y), and x is data, y is label</td><td>Data: x, Just data, no labels!</td></tr><tr><td>Data price</td><td>Training data is expensive in a lot of cases.</td><td>Training data are cheap!</td></tr><tr><td>Goal</td><td>Learn a function to map x -&gt; y</td><td>Learn some underlying hidden structure of the data</td></tr><tr><td>Examples</td><td>Classification, regression, object detection, semantic segmentation, image captioning</td><td>Clustering, dimensionality reduction, feature learning, density estimation</td></tr></tbody></table></div><ul><li><p>Autoencoders are a Feature learning technique.</p><ul><li><img src="/2020/07/29/CS231N/24.png" alt></li><li>It contains an encoder and a decoder. The encoder downsamples the image while the decoder upsamples the features.</li><li>The loss are L2 loss.</li></ul></li><li><p>Density estimation is where we want to learn/estimate the underlaying distribution for the data!</p></li><li><p>There are a lot of research open problems in unsupervised learning compared with supervised learning!</p></li><li><p><strong>Generative Models</strong></p><ul><li>Given training data, generate new samples from same distribution.</li><li>Addresses density estimation, a core problem in unsupervised learning.</li><li>We have different ways to do this:<ul><li>Explicit density estimation: explicitly define and solve for the learning model.</li><li>Learn model that can sample from the learning model without explicitly defining it.</li></ul></li><li>Why Generative Models?<ul><li>Realistic samples for artwork, super-resolution, colorization, etc</li><li>Generative models of time-series data can be used for simulation and planning (reinforcement learning applications!)</li><li>Training generative models can also enable inference of latent representations that can be useful as general features</li></ul></li><li>Taxonomy of Generative Models:<ul><li><img src="/2020/07/29/CS231N/52.png" alt></li></ul></li><li>In this lecture we will discuss: PixelRNN/CNN, Variational Autoencoder, and GANs as they are the popular models in research now.</li></ul></li><li><p><strong>PixelRNN</strong> and <strong>PixelCNN</strong></p><ul><li>In a full visible belief network we use the chain rule to decompose likelihood of an image x into product of 1-d distributions<ul><li><code>p(x) = sum(p(x[i]| x[1]x[2]....x[i-1]))</code></li><li>Where p(x) is the Likelihood of image x and x[i] is Probability of i’th pixel value given all previous pixels.</li></ul></li><li>To solve the problem we need to maximize the likelihood of training data but the distribution is so complex over pixel values.</li><li>Also we will need to define ordering of <u>previous pixels</u>.</li><li>PixelRNN<ul><li>Founded by [van der Oord et al. 2016]</li><li>Dependency on previous pixels modeled using an RNN (LSTM)</li><li>Generate image pixels starting from corner</li><li>Drawback: sequential generation is slow! because you have to generate pixel by pixel!</li></ul></li><li>PixelCNN<ul><li>Also Founded by [van der Oord et al. 2016]</li><li>Still generate image pixels starting from corner.</li><li>Dependency on previous pixels now modeled using a CNN over context region</li><li>Training is faster than PixelRNN (can parallelize convolutions since context region values known from training images)</li><li>Generation must still proceed sequentially still slow.</li></ul></li><li>There are some tricks to improve PixelRNN &amp; PixelCNN.</li><li>PixelRNN and PixelCNN can generate good samples and are still active area of research.</li></ul></li><li><p><strong>Autoencoders</strong></p><ul><li>Unsupervised approach for learning a lower-dimensional feature representation from unlabeled training data.</li><li>Consists of Encoder and decoder.</li><li>The encoder:<ul><li>Converts the input x to the features z. z should be smaller than x to get only the important values out of the input. We can call this dimensionality reduction.</li><li>The encoder can be made with:<ul><li>Linear or non linear layers (earlier days days)</li><li>Deep fully connected NN (Then)</li><li>RELU CNN (Currently we use this on images)</li></ul></li></ul></li><li>The decoder:<ul><li>We want the encoder to map the features we have produced to output something similar to x or the same x.</li><li>The decoder can be made with the same techniques we made the encoder and currently it uses a RELU CNN.</li></ul></li><li>The encoder is a conv layer while the decoder is deconv layer! Means Decreasing and then increasing.</li><li>The loss function is L2 loss function:<ul><li><code>L[i] = |y[i] - y&#39;[i]|^2</code><ul><li>After training we though away the decoder.<code># Now we have the features we need</code></li></ul></li></ul></li><li>We can use this encoder we have to make a supervised model.<ul><li>The value of this it can learn a good feature representation to the input you have.</li><li>A lot of times we will have a small amount of data to solve problem. One way to tackle this is to use an Autoencoder that learns how to get features from images and train your small dataset on top of that model.</li></ul></li><li>The question is can we generate data (Images) from this Autoencoder?</li></ul></li><li><p><strong>Variational Autoencoders (VAE)</strong></p><ul><li>Probabilistic spin on Autoencoders - will let us sample from the model to generate data!</li><li>We have z as the features vector that has been formed using the encoder.</li><li>We then choose prior p(z) to be simple, e.g. Gaussian. <ul><li>Reasonable for hidden attributes: e.g. pose, how much smile.</li></ul></li><li>Conditional p(x|z) is complex (generates image) =&gt; represent with neural network</li><li>But we cant compute integral for P(z)p(x|z)dz as the following equation:<ul><li><img src="/2020/07/29/CS231N/25.png" alt></li></ul></li><li>After resolving all the equations that solves the last equation we should get this:<ul><li><img src="/2020/07/29/CS231N/26.png" alt></li></ul></li><li>Variational Autoencoder are an approach to generative models but Samples blurrier and lower quality compared to state-of-the-art (GANs)</li><li>Active areas of research:<ul><li>More flexible approximations, e.g. richer approximate posterior instead of diagonal Gaussian</li><li>Incorporating structure in latent variables</li></ul></li></ul></li><li><p><strong>Generative Adversarial Networks (GANs)</strong></p><ul><li><p>GANs don’t work with any explicit density function!</p></li><li><p>Instead, take game-theoretic approach: learn to generate from training distribution through 2-player game.</p></li><li><p>Yann LeCun, who oversees AI research at Facebook, has called GANs:</p><ul><li><blockquote><p>The coolest idea in deep learning in the last 20 years</p></blockquote></li></ul></li><li><p>Problem: Want to sample from complex, high-dimensional training distribution. No direct way to do this as we have discussed!</p></li><li><p>Solution: Sample from a simple distribution, e.g. random noise. Learn transformation to training distribution.</p></li><li><p>So we create a noise image which are drawn from simple distribution feed it to NN we will call it a generator network that should learn to transform this into the distribution we want.</p></li><li><p>Training GANs: Two-player game:</p><ul><li><strong>Generator network</strong>: try to fool the discriminator by generating real-looking images.</li><li><strong>Discriminator network</strong>: try to distinguish between real and fake images.</li></ul></li><li><p>If we are able to train the Discriminator well then we can train the generator to generate the right images.</p></li><li><p>The loss function of GANs as minimax game are here:</p><ul><li><img src="/2020/07/29/CS231N/27.png" alt></li></ul></li><li><p>The label of the generator network will be 0 and the real images are 1.</p></li><li><p>To train the network we will do:</p><ul><li>Gradient ascent on discriminator.</li><li>Gradient ascent on generator but with different loss.</li></ul></li><li><p>You can read the full algorithm with the equations here:</p><ul><li><img src="/2020/07/29/CS231N/28.png" alt></li></ul></li><li><p>Aside: Jointly training two networks is challenging, can be unstable. Choosing objectives with better loss landscapes helps training is an active area of research.</p></li><li><p>Convolutional Architectures:</p><ul><li>Generator is an upsampling network with fractionally-strided convolutions Discriminator is a Convolutional network.</li><li>Guidelines for stable deep Conv GANs:<ul><li>Replace any pooling layers with strided convs (discriminator) and fractional-strided convs with (Generator).</li><li>Use batch norm for both networks.</li><li>Remove fully connected hidden layers for deeper architectures.</li><li>Use RELU activation in generator for all layers except the output which uses Tanh</li><li>Use leaky RELU in discriminator for all the layers.</li></ul></li></ul></li><li><p>2017 is the year of the GANs! it has exploded and there are some really good results.</p></li><li><p>Active areas of research also is GANs for all kinds of applications.</p></li><li><p>The GAN zoo can be found here: <a href="https://github.com/hindupuravinash/the-gan-zoo" target="_blank" rel="noopener">https://github.com/hindupuravinash/the-gan-zoo</a></p></li><li><p>Tips and tricks for using GANs: <a href="https://github.com/soumith/ganhacks" target="_blank" rel="noopener">https://github.com/soumith/ganhacks</a></p></li><li><p>NIPS 2016 Tutorial GANs: <a href="https://www.youtube.com/watch?v=AJVyzd0rqdc" target="_blank" rel="noopener">https://www.youtube.com/watch?v=AJVyzd0rqdc</a></p></li></ul></li></ul><h2 id="14-Deep-reinforcement-learning"><a href="#14-Deep-reinforcement-learning" class="headerlink" title="14. Deep reinforcement learning"></a>14. Deep reinforcement learning</h2><ul><li>This section contains a lot of math.</li><li>Reinforcement learning problems are involving an agent interacting with an environment, which provides numeric reward signals.</li><li>Steps are:<ul><li>Environment —&gt; State <code>s[t]</code> —&gt; Agent —&gt; Action <code>a[t]</code> —&gt; Environment —&gt; <code>Reward r[t]</code> + Next state <code>s[t+1]</code> —&gt; Agent —&gt; and so on..</li></ul></li><li>Our goal is learn how to take actions in order to maximize reward.</li><li>An example is Robot Locomotion:<ul><li>Objective: Make the robot move forward</li><li>State: Angle and position of the joints</li><li>Action: Torques applied on joints</li><li>1 at each time step upright + forward movement</li></ul></li><li>Another example is Atari Games:<ul><li>Deep learning has a good state of art in this problem.</li><li>Objective: Complete the game with the highest score.</li><li>State: Raw pixel inputs of the game state.</li><li>Action: Game controls e.g. Left, Right, Up, Down</li><li>Reward: Score increase/decrease at each time step</li></ul></li><li>Go game is another example which AlphaGo team won in the last year (2016) was a big achievement for AI and deep learning because the problem was so hard.</li><li>We can mathematically formulate the RL (reinforcement learning) by using <u><strong>Markov Decision Process</strong></u></li><li><strong>Markov Decision Process</strong><ul><li>Defined by (<code>S</code>, <code>A</code>, <code>R</code>, <code>P</code>, <code>Y</code>) where:<ul><li><code>S</code>: set of possible states.</li><li><code>A</code>: set of possible actions</li><li><code>R</code>: distribution of reward given (state, action) pair</li><li><code>P</code>: transition probability i.e. distribution over next state given (state, action) pair</li><li><code>Y</code>: discount factor    <code># How much we value rewards coming up soon verses later on.</code></li></ul></li><li>Algorithm:<ul><li>At time step <code>t=0</code>, environment samples initial state <code>s[0]</code></li><li>Then, for t=0 until done:<ul><li>Agent selects action <code>a[t]</code></li><li>Environment samples reward from <code>R</code> with (<code>s[t]</code>, <code>a[t]</code>)</li><li>Environment samples next state from <code>P</code> with (<code>s[t]</code>, <code>a[t]</code>)</li><li>Agent receives reward <code>r[t]</code> and next state <code>s[t+1]</code></li></ul></li></ul></li><li>A policy <code>pi</code>  is a function from S to A that specifies what action to take in each state.</li><li>Objective: find policy <code>pi*</code> that maximizes cumulative discounted reward: <code>Sum(Y^t * r[t], t&gt;0)</code></li><li>For example:<ul><li><img src="/2020/07/29/CS231N/29.png" alt></li></ul></li><li>Solution would be:<ul><li><img src="/2020/07/29/CS231N/30.png" alt></li></ul></li></ul></li><li>The value function at state <code>s</code>, is the expected cumulative reward from following the policy from state <code>s</code>:<ul><li><code>V[pi](s) = Sum(Y^t * r[t], t&gt;0) given s0 = s, pi</code></li></ul></li><li>The Q-value function at state s and action <code>a</code>, is the expected cumulative reward from taking action <code>a</code> in state <code>s</code> and then following the policy:<ul><li><code>Q[pi](s,a) = Sum(Y^t * r[t], t&gt;0) given s0 = s,a0 = a, pi</code></li></ul></li><li>The optimal Q-value function <code>Q*</code> is the maximum expected cumulative reward achievable from a given (state, action) pair:<ul><li><code>Q*[s,a] = Max(for all of pi on (Sum(Y^t * r[t], t&gt;0) given s0 = s,a0 = a, pi))</code></li></ul></li><li>Bellman equation<ul><li>Important thing is RL.</li><li>Given any state action pair (s,a) the value of this pair is going to be the reward that you are going to get r plus the value of the state that you end in.</li><li><code>Q*[s,a] = r + Y * max Q*(s&#39;,a&#39;) given s,a  # Hint there is no policy in the equation</code></li><li>The optimal policy <code>pi*</code> corresponds to taking the best action in any state as specified by <code>Q*</code></li></ul></li><li>We can get the optimal policy using the value iteration algorithm that uses the Bellman equation as an iterative update<ul><li><img src="/2020/07/29/CS231N/31.png" alt></li></ul></li><li>Due to the huge space dimensions in real world applications we will use a function approximator to estimate <code>Q(s,a)</code>. E.g. a neural network! this is called <strong>Q-learning</strong><ul><li>Any time we have a complex function that we cannot represent we use Neural networks!</li></ul></li><li><strong>Q-learning</strong><ul><li>The first deep learning algorithm that solves the RL.</li><li>Use a function approximator to estimate the action-value function</li><li>If the function approximator is a deep neural network =&gt; deep q-learning</li><li>The loss function:<ul><li><img src="/2020/07/29/CS231N/32.png" alt></li></ul></li></ul></li><li>Now lets consider the “Playing Atari Games” problem:<ul><li>Our total reward are usually the reward we are seeing in the top of the screen.</li><li>Q-network Architecture:<ul><li><img src="/2020/07/29/CS231N/33.png" alt></li></ul></li><li>Learning from batches of consecutive samples is a problem. If we recorded a training data and set the NN to work with it, if the data aren’t enough we will go to a high bias error. so we should use “experience replay” instead of consecutive samples where the NN will try the game again and again until it masters it.</li><li>Continually update a replay memory table of transitions (<code>s[t]</code> , <code>a[t]</code> , <code>r[t]</code> , <code>s[t+1]</code>) as game (experience) episodes are played.</li><li>Train Q-network on random minibatches of transitions from the replay memory, instead of consecutive samples.</li><li>The full algorithm:<ul><li><img src="/2020/07/29/CS231N/34.png" alt></li></ul></li><li>A video that demonstrate the algorithm on Atari game can be found here: “<a href="https://www.youtube.com/watch?v=V1eYniJ0Rnk" target="_blank" rel="noopener">https://www.youtube.com/watch?v=V1eYniJ0Rnk</a>“</li></ul></li><li><strong>Policy Gradients</strong><ul><li>The second deep learning algorithm that solves the RL.</li><li>The problem with Q-function is that the Q-function can be very complicated.<ul><li>Example: a robot grasping an object has a very high-dimensional state.</li><li>But the policy can be much simpler: just close your hand.</li></ul></li><li>Can we learn a policy directly, e.g. finding the best policy from a collection of policies?</li><li>Policy Gradients equations:<ul><li><img src="/2020/07/29/CS231N/35.png" alt></li></ul></li><li>Converges to a local minima of <code>J(ceta)</code>, often good enough!</li><li>REINFORCE algorithm is the algorithm that will get/predict us the best policy</li><li>Equation and intuition of the Reinforce algorithm:<ul><li><img src="/2020/07/29/CS231N/36.png" alt></li><li>the problem was high variance with this equation can we solve this?</li><li>variance reduction is an active research area!</li></ul></li><li>Recurrent Attention Model (RAM) is an algorithm that are based on REINFORCE algorithm and is used for image classification problems:<ul><li>Take a sequence of “glimpses” selectively focusing on regions of the image, to predict class<ul><li>Inspiration from human perception and eye movements.</li><li>Saves computational resources =&gt; scalability<ul><li>If an image with high resolution you can save a lot of computations</li></ul></li><li>Able to ignore clutter / irrelevant parts of image</li></ul></li><li>RAM is used now in a lot of tasks: including fine-grained image recognition, image captioning, and visual question-answering</li></ul></li><li>AlphaGo are using a mix of supervised learning and reinforcement learning, It also using policy gradients.</li></ul></li><li>A good course from Standford on deep reinforcement learning<ul><li><a href="http://web.stanford.edu/class/cs234/index.html" target="_blank" rel="noopener">http://web.stanford.edu/class/cs234/index.html</a></li><li><a href="https://www.youtube.com/playlist?list=PLkFD6_40KJIwTmSbCv9OVJB3YaO4sFwkX" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLkFD6_40KJIwTmSbCv9OVJB3YaO4sFwkX</a></li></ul></li><li>A good course on deep reinforcement learning (2017)<ul><li><a href="http://rll.berkeley.edu/deeprlcourse/" target="_blank" rel="noopener">http://rll.berkeley.edu/deeprlcourse/</a></li><li><a href="https://www.youtube.com/playlist?list=PLkFD6_40KJIznC9CDbVTjAF2oyt8_VAe3" target="_blank" rel="noopener">https://www.youtube.com/playlist?list=PLkFD6_40KJIznC9CDbVTjAF2oyt8_VAe3</a></li></ul></li><li>A good article<ul><li><a href="https://www.kdnuggets.com/2017/09/5-ways-get-started-reinforcement-learning.html" target="_blank" rel="noopener">https://www.kdnuggets.com/2017/09/5-ways-get-started-reinforcement-learning.html</a></li></ul></li></ul><h2 id="15-Efficient-Methods-and-Hardware-for-Deep-Learning"><a href="#15-Efficient-Methods-and-Hardware-for-Deep-Learning" class="headerlink" title="15. Efficient Methods and Hardware for Deep Learning"></a>15. Efficient Methods and Hardware for Deep Learning</h2><ul><li>The original lecture was given by Song Han a PhD Candidate at standford.</li><li>Deep Conv nets, Recurrent nets, and deep reinforcement learning are shaping a lot of applications and changing a lot of our lives.<ul><li>Like self driving cars, machine translations, alphaGo and so on.</li></ul></li><li>But the trend now says that if we want a high accuracy we need a larger (Deeper) models.<ul><li>The model size in ImageNet competation from 2012 to 2015 has increased 16x to achieve a high accurecy.</li><li>Deep speech 2 has 10x training operations than deep speech 1 and thats in only one year! <code># At Baidu</code></li></ul></li><li>There are three challenges we got from this<ul><li><strong>Model Size</strong><ul><li>Its hard to deploy larger models on our PCs, mobiles, or cars.</li></ul></li><li><strong>Speed</strong><ul><li>ResNet152 took 1.5 weeks to train and give the 6.16% accurecy!</li><li>Long training time limits ML researcher’s productivity</li></ul></li><li><strong>Energy Efficiency</strong><ul><li>AlphaGo: 1920 CPUs and 280 GPUs. $3000 electric bill per game</li><li>If we use this on our mobile it will drain the battery.</li><li>Google mentioned in thier blog if all the users used google speech for 3 minutes, they have to double thier data-center!</li><li>Where is the Energy Consumed?<ul><li>larger model =&gt; more memory reference =&gt; more energy</li></ul></li></ul></li></ul></li><li>We can improve the Efficiency of Deep Learning by Algorithm-Hardware Co-Design.<ul><li>From both the hardware and the algorithm perspectives.</li></ul></li><li>Hardware 101: the Family<ul><li><strong>General Purpose</strong>            <code># Used for any hardware</code><ul><li>CPU                <code># Latency oriented, Single strong threaded like a single elepahnt</code></li><li>GPU            <code># Throughput oriented, So many small threads like a lot of ants</code></li><li>GPGPU<ul><li><strong>Specialized HW</strong>        <code>#Tuned for a domain of applications</code><ul><li>FPGA <code># Programmable logic, Its cheaper but less effiecnet</code></li><li>ASIC <code># Fixed logic, Designed for a certian applications (Can be designed for deep learning applications)</code></li></ul></li></ul></li></ul></li></ul></li><li>Hardware 101: Number Representation<ul><li>Numbers in computer are represented with a discrete memory.</li><li>Its very good and energy efficent for hardware to go from 32 bit to 16 bit in float point operations.</li></ul></li><li>Part 1: <strong><u>Algorithms for Efficient Inference</u></strong><ul><li><strong>Pruning neural networks</strong><ul><li>Idea is can we remove some of the weights/neurons and the NN still behave the same?</li><li>In 2015 Han made AlexNet parameters from 60 million to 6 Million! by using the idea of Pruning.</li><li>Pruning can be applied to CNN and RNN, iteratively it will reach the same accurecy as the original.</li><li>Pruning actually happends to humans:<ul><li>Newborn(50 Trillion Synapses) ==&gt; 1 year old(1000 Trillion Synapses) ==&gt; Adolescent(500 Trillion Synapses)</li></ul></li><li>Algorithm:<ol><li>Get Trained network.</li><li>Evaluate importance of neurons.</li><li>Remove the least important neuron.</li><li>Fine tune the network.</li><li>If we need to continue Pruning we go to step 2 again else we stop.</li></ol></li></ul></li><li><strong>Weight Sharing</strong><ul><li>The idea is that we want to make the numbers is our models less.</li><li>Trained Quantization:<ul><li>Example: all weight values that are 2.09, 2.12, 1.92, 1.87 will be replaced by 2</li><li>To do that we can make k means clustering on a filter for example and reduce the numbers in it. By using this we can also reduce the number of operations that are used from calculating the gradients.</li><li>After Trained Quantization the Weights are Discrete.</li><li>Trained Quantization can reduce the number of bits we need for a number in each layer significantly.</li></ul></li><li>Pruning + Trained Quantization can Work Together to reduce the size of the model.</li><li>Huffman Coding<ul><li>We can use Huffman Coding to reduce/compress the number of bits of the weight.</li><li>In-frequent weights: use more bits to represent.</li><li>Frequent weights: use less bits to represent.</li></ul></li><li>Using Pruning + Trained Quantization + Huffman Coding is called deep compression.<ul><li><img src="/2020/07/29/CS231N/37.png" alt></li><li><img src="/2020/07/29/CS231N/38.png" alt></li><li><strong>SqueezeNet</strong><ul><li>All the models we have talked about till now was using a pretrained models. Can we make a new arcitecutre that saves memory and computations?</li><li>SqueezeNet gets the alexnet accurecy with 50x fewer parameters and 0.5 model size.</li></ul></li><li>SqueezeNet can even be further compressed by applying deep compression on them.</li><li>Models are now more energy efficient and has speed up a lot.</li><li>Deep compression was applied in Industry through facebook and Baidu.</li></ul></li></ul></li><li><strong>Quantization</strong><ul><li>Algorithm (Quantizing the Weight and Activation):<ul><li>Train with float.</li><li>Quantizing the weight and activation:<ul><li>Gather the statistics for weight and activation.</li><li>Choose proper radix point position.</li></ul></li><li>Fine-tune in float format.</li><li>Convert to fixed-point format.</li></ul></li></ul></li><li><strong>Low Rank Approximation</strong><ul><li>Is another size reduction algorithm that are used for CNN.</li><li>Idea is decompose the conv layer and then try both of the composed layers.</li></ul></li><li><strong>Binary / Ternary Net</strong><ul><li>Can we only use three numbers to represent weights in NN?</li><li>The size will be much less with only -1, 0, 1.</li><li>This is a new idea that was published in 2017 “Zhu, Han, Mao, Dally. Trained Ternary Quantization, ICLR’17”</li><li>Works after training.</li><li>They have tried it on AlexNet and it has reached almost the same error as AlexNet.</li><li>Number of operation will increase per register: <a href="https://xnor.ai/" target="_blank" rel="noopener">https://xnor.ai/</a></li></ul></li><li><strong>Winograd Transformation</strong><ul><li>Based on 3x3 WINOGRAD Convolutions which makes less operations than the ordiany convolution</li><li>cuDNN 5 uses the WINOGRAD Convolutions which has improved the speed.</li></ul></li></ul></li><li>Part 2: <strong><u>Hardware for Efficient Inference</u></strong><ul><li>There are a lot of ASICs that we developed for deep learning. All in which has the same goal of minimize memory access.<ul><li>Eyeriss MIT</li><li>DaDiannao</li><li>TPU Google (Tensor processing unit)<ul><li>It can be put to replace the disk in the server.</li><li>Up to 4 cards per server.</li><li>Power consumed by this hardware is a lot less than a GPU and the size of the chip is less.</li></ul></li><li>EIE Standford<ul><li>By Han at 2016 [et al. ISCA’16]</li><li>We don’t save zero weights and make quantization for the numbers from the hardware.</li><li>He says that EIE has a better Throughput and energy efficient.</li></ul></li></ul></li></ul></li><li>Part 3: <strong><u>Algorithms for Efficient Training</u></strong><ul><li><strong>Parallelization</strong><ul><li><strong>Data Parallel</strong> – Run multiple inputs in parallel<ul><li>Ex. Run two images in the same time!</li><li>Run multiple training examples in parallel.</li><li>Limited by batch size.</li><li>Gradients have to be applied by a master node.</li></ul></li><li><strong>Model Parallel</strong><ul><li>Split up the Model – i.e. the network</li><li>Split model over multiple processors By layer.</li></ul></li><li>Hyper-Parameter Parallel<ul><li>Try many alternative networks in parallel.</li><li>Easy to get 16-64 GPUs training one model in parallel.</li></ul></li></ul></li><li><strong>Mixed Precision</strong> with FP16 and FP32<ul><li>We have discussed that if we use 16 bit real numbers all over the model the energy cost will be less by x4.</li><li>Can we use a model entirely with 16 bit number? We can partially do this with mixed FP16 and FP32. We use 16 bit everywhere but at some points we need the FP32.</li><li>By example in multiplying FP16 by FP16 we will need FP32.</li><li>After you train the model you can be a near accuracy of the famous models like AlexNet and ResNet.</li></ul></li><li><strong>Model Distillation</strong><ul><li>The question is can we use a senior (Good) trained neural network(s) and make them guide a student (New) neural network?</li><li>For more information look at Hinton et al. Dark knowledge / Distilling the Knowledge in a Neural Network</li></ul></li><li>DSD: Dense-Sparse-Dense Training<ul><li>Han et al. “DSD: Dense-Sparse-Dense Training for Deep Neural Networks”, ICLR 2017</li><li>Has a better regularization.</li><li>The idea is Train the model lets call this the Dense, we then apply Pruning to it lets call this sparse.</li><li>DSD produces same model architecture but can find better optimization solution arrives at better local minima, and achieves higher prediction accuracy.</li><li>After the above two steps we go connect the remain connection and learn them again (To dense again).</li><li>This improves the performace a lot in many deep learning models.</li></ul></li></ul></li><li>Part 4: <strong><u>Hardware for Efficient Training</u></strong><ul><li>GPUs for training:<ul><li>Nvidia PASCAL GP100 (2016)</li><li>Nvidia Volta GV100 (2017)<ul><li>Can make mixed precision operations!</li><li>So powerful.</li><li>The new neclar bomb!</li></ul></li></ul></li><li>Google Announced “Google Cloud TPU” on May 2017!<ul><li>Cloud TPU delivers up to 180 teraflops to train and run machine learning models.</li><li>One of our new large-scale translation models used to take a full day to train on 32 of the best commercially-available GPUs—now it trains to the same accuracy in an afternoon using just one eighth of a TPU pod.</li></ul></li></ul></li><li>We have moved from PC Era ==&gt; Mobile-First Era ==&gt; AI-First Era</li></ul><h2 id="16-Adversarial-Examples-and-Adversarial-Training"><a href="#16-Adversarial-Examples-and-Adversarial-Training" class="headerlink" title="16. Adversarial Examples and Adversarial Training"></a>16. Adversarial Examples and Adversarial Training</h2><ul><li><strong><u>What are adversarial examples?</u></strong><ul><li>Since 2013, deep neural networks have matched human performance at..<ul><li>Face recognition</li><li>Object recognition</li><li>Captcha recognition<ul><li>Because its accuracy was higher than humans, Websites tried to find another solution than Captcha.</li></ul></li><li>And other tasks..</li></ul></li><li>Before 2013 no body was surprised if they saw a computer made a mistake! But now the deep learning exists and its so important to know the problems and the causes.</li><li>Adversarial are problems and unusual mistake that deep learning make.</li><li>This topic wasn’t hot until deep learning can now do better and better than human!</li><li>An adversarial is an example that has been carefully computed to to be misclassified.</li><li>In a lot of cases the adversarial image isn’t changed much compared to the original image from the human perspective.</li><li>History of recent papers:<ul><li>Biggio <a href="https://link.springer.com/chapter/10.1007/978-3-642-40994-3_25" target="_blank" rel="noopener">2013</a>: fool neural nets.</li><li>Szegedy et al 2013: fool ImageNet classifiers imperceptibly</li><li>Goodfellow et al <a href="https://arxiv.org/abs/1412.6572" target="_blank" rel="noopener">2014</a>: cheap, closed form attack.</li></ul></li><li>So the first story was in 2013. When Szegedy had a CNN that can classify images very well.<ul><li>He wanted to understand more about how CNN works to improve it.</li><li>He give an image of an object and by using gradient ascent he tried to update the images so that it can be another object.</li><li>Strangely he found that the result image hasn’t changed much from the human perspective!</li><li>If you tried it you won’t notify any change and you will think that this is a bug! but it isn’t if you go for the image you will notice that they are completely different!</li></ul></li><li>These mistakes can be found in almost any deep learning algorithm we have studied!<ul><li>It turns out that RBF (Radial Basis Network) can resist this.</li><li>Deep Models for Density Estimation can resist this.</li></ul></li><li>Not just for neural nets can be fooled:<ul><li>Linear models<ul><li>Logistic regression</li><li>Softmax regression</li><li>SVMs</li></ul></li><li>Decision trees </li><li>Nearest neighbors</li></ul></li></ul></li><li><strong><u>Why do adversarial happen?</u></strong><ul><li>In the process in trying to understand what is happening, in 2016 they thought it was from overfitting models in the high dimensional data case.<ul><li>Because in such high dimensions we could have some random errors which can be found.</li><li>So if we trained a model with another parameters it should not make the same mistake?</li><li>They found that not right. Models are reaching to the same mistakes so it doesn’t mean its overfitting.</li></ul></li><li>In the previous mentioned experiment the found that the problem is caused by systematic thing not a random.<ul><li>If they add some vector to an example it would misclassified to any model.</li></ul></li><li>Maybe they are coming from underfitting not overfitting.</li><li>Modern deep nets are very piecewise linear<ul><li>Rectified linear unit</li><li>Carefully tuned sigmoid  <code># Most of the time we are inside the linear curve</code></li><li>Maxout</li><li>LSTM</li></ul></li><li>Relation between the parameter and the output are non linear because it’s multiplied together thats what make training NN difficult, while mapping from linear from input and output are linear and much easier.</li></ul></li><li><strong><u>How can adversarial be used to compromise machine learning systems?</u></strong><ul><li>If we are experimenting how easy a NN to fool, We want to make sure we are actually fooling it not just changing the output class, and if we are attackers we want to make this behavior to the NN (Get hole).</li><li>When we build Adversarial example we use the max norm constrain to perturbation.</li><li>The fast gradient sign method:<ul><li>This method comes from the fact that almost all NN are using a linear activations (Like RELU) the assumption we have told before.</li><li>No pixel can be changed more than some amount epsilon.</li><li>Fast way is to take the gradient of the cost you used to train the network with respect to the input and then take the sign of that gradient multiply this by epsilon.</li><li>Equation:<ul><li><code>Xdash = x + epslion * (sign of the gradient)</code></li><li>Where Xdash is the adversarial example and x is the normal example</li></ul></li><li>So it can be detected by just using the sign (direction) and some epsilon.</li></ul></li><li>Some attacks are based on ADAM optimizer.</li><li>Adversarial examples are not random noises!</li><li>NN are trained on some distribution and behaves well in that distribution. But if you shift this distribution the NN won’t answer the right answers. They will be so easy to fool.</li><li>deep RL can also be fooled.</li><li>Attack of the weights:<ul><li>In linear models, We can take the learned weights image, take the signs of the image and add it to any example to force the class of the weights to be true. Andrej Karpathy, “Breaking Linear Classifiers on ImageNet”</li></ul></li><li>It turns out that some of the linaer models performs well (We cant get advertisal from them easily)<ul><li>In particular Shallow RBFs network resist adversarial perturbation # By The fast gradient sign method<ul><li>The problem is RBFs doesn’t get so much accuracy on the datasets because its just a shallow model and if you tried to get this model deeper the gradients will become zero in almost all the layers.</li><li>RBFs are so difficult to train even with batch norm. algorithm.</li><li>Ian thinks if we have a better hyper parameters or a better optimization algorithm that gradient decent we will be able to train RBFs and solve the adversarial problem!</li></ul></li></ul></li><li>We also can use another model to fool current model. Ex use an SVM to fool a deep NN.<ul><li>For more details follow the paper: “Papernot 2016”</li></ul></li><li>Transferability Attack<ol><li>Target model with unknown weights, machine learning algorithm, training set; maybe non differentiable</li><li>Make your training set from this model using inputs from you, send them to the model and then get outputs from the model</li><li>Train you own model. “Following some table from Papernot 2016”</li><li>Create an Adversarial example on your model.</li><li>Use these examples against the model you are targeting.</li><li>You are almost likely to get good results and fool this target!</li></ol></li><li>In Transferability Attack to increase your probability by 100% of fooling a network, You can make more than just one model may be five models and then apply them. “(Liu et al, 2016)”</li><li>Adversarial Examples are works for human brain also! for example images that tricks your eyes. They are a lot over the Internet.</li><li>In practice some researches have fooled real models from (MetaMind, Amazon, Google)</li><li>Someone has uploaded some perturbation into facebook and facebook was fooled :D</li></ul></li><li><strong><u>What are the defenses?</u></strong><ul><li>A lot of defenses Ian tried failed really bad! Including:<ul><li>Ensembles</li><li>Weight decay</li><li>Dropout</li><li>Adding noise at train time or at test time</li><li>Removing perturbation with an autoencoder </li><li>Generative modeling</li></ul></li><li>Universal approximator theorem<ul><li>Whatever shape we would like our classification function to have a big enough NN can make it.</li><li>We could have train a NN that detects the Adversarial!</li></ul></li><li>Linear models &amp; KNN can be fooled easier than NN. Neural nets can actually become more secure than other models. Adversarial trained neural nets have the best empirical success rate on adversarial examples of any machine learning model.<ul><li>Deep NNs can be trained with non linear functions but we will just need a good optimization technique or solve the problem with using such linear activator like “RELU”</li></ul></li></ul></li><li><strong><u>How to use adversarial examples to improve machine learning, even when there is no adversary?</u></strong><ul><li>Universal engineering machine (model-based optimization)        <code>#Is called Universal engineering machine by Ian</code><ul><li>For example:<ul><li>Imagine that we want to design a car that are fast.</li><li>We trained a NN to look at the blueprints of a car and tell us if the blueprint will make us a fast car or not.</li><li>The idea here is to optimize the input to the network so that the output will max this could give us the best blueprint for a car!</li></ul></li><li>Make new inventions by finding input that maximizes model’s predicted performance.</li><li>Right now by using adversarial examples we are just getting the results we don’t like but if we have solve this problem we can have the fastest car, the best GPU, the best chair, new drugs…..</li></ul></li><li>The whole adversarial is an active area of research especially defending the network!</li></ul></li><li>Conclusion<ul><li>Attacking is easy</li><li>Defending is difficult</li><li>Adversarial training provides regularization and semi-supervised learning </li><li>The out-of-domain input problem is a bottleneck for model-based optimization generally</li></ul></li><li>There are a Github code that can make you learn everything about adversarial by code (Built above tensorflow):<ul><li>An adversarial example library for constructing attacks, building defenses, and benchmarking both: <a href="https://github.com/tensorflow/cleverhans" target="_blank" rel="noopener">https://github.com/tensorflow/cleverhans</a></li></ul></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;斯坦福大学深度学习课程笔记&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="CS231N" scheme="http://yoursite.com/tags/CS231N/"/>
    
  </entry>
  
  <entry>
    <title>动手实现卷积层和池化层</title>
    <link href="http://yoursite.com/2020/07/29/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E5%8D%B7%E7%A7%AF%E5%B1%82%E5%92%8C%E6%B1%A0%E5%8C%96%E5%B1%82/"/>
    <id>http://yoursite.com/2020/07/29/%E5%8A%A8%E6%89%8B%E5%AE%9E%E7%8E%B0%E5%8D%B7%E7%A7%AF%E5%B1%82%E5%92%8C%E6%B1%A0%E5%8C%96%E5%B1%82/</id>
    <published>2020-07-29T04:35:44.000Z</published>
    <updated>2020-07-29T04:36:23.698Z</updated>
    
    <content type="html"><![CDATA[<p>动手实现卷积层和池化层<br><a id="more"></a></p><h1 id="卷积层实现"><a href="#卷积层实现" class="headerlink" title="卷积层实现"></a>卷积层实现</h1><p>CNN中各层间传递的数据是4维数据。所谓4维数据，比如数据的形状是(10, 1, 28, 28)，<br>则它对应10个高为28、长为28、通道为1的数据。用Python来实现的话，如下所示。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x &#x3D; np.random.rand(10, 1, 28, 28) # 随机生成数据</span><br><span class="line">&gt;&gt;&gt; x.shape</span><br><span class="line">(10, 1, 28, 28)</span><br></pre></td></tr></table></figure><br>这里，如果要访问第1个数据，只要写x[0]就可以了（注意Python的索引是从0开始的）。同样地，用x[1]可以访问第2个数据<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x[0].shape # (1, 28, 28)</span><br><span class="line">&gt;&gt;&gt; x[1].shape # (1, 28, 28)</span><br></pre></td></tr></table></figure></p><p>如果要访问第1个数据的第1个通道的空间数据，可以写成下面这样。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; x[0, 0] # 或者x[0][0]</span><br></pre></td></tr></table></figure></p><p>像这样，CNN中处理的是4维数据，因此卷积运算的实现看上去会很复杂，但是通过使用下面要介绍的im2col这个技巧，问题就会变得很简单。</p><h2 id="基于-im2col的展开"><a href="#基于-im2col的展开" class="headerlink" title="基于 im2col的展开"></a>基于 im2col的展开</h2><p>如果老老实实地实现卷积运算，估计要重复好几层的for语句。<br>这样的实现有点麻烦，而且，NumPy中存在使用for语句后处理变慢的缺点（NumPy中，访问元素时最好不要用for语句）。</p><p>这里，我们不使用for语句，而是使用im2col这个便利的函数进行简单的实现。</p><p>im2col是一个函数，将输入数据展开以适合滤波器（权重）。</p><p>如图7-17所示，对3维的输入数据应用im2col后，数据转换为2维矩阵（正确地讲，是把包含批数量的4维数据转换成了2维数据）。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%AE%9E%E7%8E%B01.png" alt></p><p>im2col会把输入数据展开以适合滤波器（权重）。</p><p>具体地说，如图7-18所示，对于输入数据，将应用滤波器的区域（3维方块）横向展开为1列。</p><p>im2col会在所有应用滤波器的地方进行这个展开处理。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%AE%9E%E7%8E%B02.png" alt></p><p>在图7-18中，为了便于观察，将步幅设置得很大，以使滤波器的应用区域不重叠。</p><p>而在实际的卷积运算中，滤波器的应用区域几乎都是重叠的。</p><p>在滤波器的应用区域重叠的情况下，使用im2col展开后，展开后的元素个数会多于原方块的元素个数。</p><p>因此，使用im2col的实现存在比普通的实现消耗更多内存的缺点。</p><p>但是，汇总成一个大的矩阵进行计算，对计算机的计算颇有益处。</p><p>比如，在矩阵计算的库（线性代数库）等中，矩阵计算的实现已被高度最优化，可以高速地进行大矩阵的乘法运算。因此，通过归结到矩阵计算<br>上，可以有效地利用线性代数库。</p><p>im2col这个名称是“image to column”的缩写，翻译过来就是“从图像到矩阵”的意思。</p><p>Caffe、Chainer 等深度学习框架中有名为im2col的函数，并且在卷积层的实现中，都使用了im2col。</p><p>使用im2col展开输入数据后，之后就只需将卷积层的滤波器（权重）纵向展开为1列，并计算2个矩阵的乘积即可（参照图7-19）。</p><p>这和全连接层的Affi ne层进行的处理基本相同。<br>如图7-19所示，基于im2col方式的输出结果是2维矩阵。</p><p>因为CNN中数据会保存为4维数组，所以要将2维输出数据转换为合适的形状。</p><p>以上就是卷积层的实现流程。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%AE%9E%E7%8E%B03.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line">def im2col(input_data, filter_h, filter_w, stride&#x3D;1, pad&#x3D;0):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    Parameters</span><br><span class="line">    ----------</span><br><span class="line">    input_data : 由(数据量, 通道, 高, 长)的4维数组构成的输入数据</span><br><span class="line">    filter_h : 滤波器的高</span><br><span class="line">    filter_w : 滤波器的长</span><br><span class="line">    stride : 步幅</span><br><span class="line">    pad : 填充</span><br><span class="line"></span><br><span class="line">    Returns</span><br><span class="line">    -------</span><br><span class="line">    col : 2维数组</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    N, C, H, W &#x3D; input_data.shape</span><br><span class="line">    out_h &#x3D; (H + 2*pad - filter_h)&#x2F;&#x2F;stride + 1</span><br><span class="line">    out_w &#x3D; (W + 2*pad - filter_w)&#x2F;&#x2F;stride + 1</span><br><span class="line"></span><br><span class="line">    img &#x3D; np.pad(input_data, [(0,0), (0,0), (pad, pad), (pad, pad)], &#39;constant&#39;)</span><br><span class="line">    col &#x3D; np.zeros((N, C, filter_h, filter_w, out_h, out_w))</span><br><span class="line"></span><br><span class="line">    for y in range(filter_h):</span><br><span class="line">        y_max &#x3D; y + stride*out_h</span><br><span class="line">        for x in range(filter_w):</span><br><span class="line">            x_max &#x3D; x + stride*out_w</span><br><span class="line">            col[:, :, y, x, :, :] &#x3D; img[:, :, y:y_max:stride, x:x_max:stride]</span><br><span class="line"></span><br><span class="line">    col &#x3D; col.transpose(0, 4, 5, 1, 2, 3).reshape(N*out_h*out_w, -1)</span><br><span class="line">    return col</span><br></pre></td></tr></table></figure><p>im2col会考虑滤波器大小、步幅、填充，将输入数据展开为2维数组。<br>现在，我们来实际使用一下这个im2col。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">import sys, os</span><br><span class="line">sys.path.append(os.pardir)</span><br><span class="line">from common.util import im2col</span><br><span class="line">x1 &#x3D; np.random.rand(1, 3, 7, 7)</span><br><span class="line">col1 &#x3D; im2col(x1, 5, 5, stride&#x3D;1, pad&#x3D;0)</span><br><span class="line">print(col1.shape) # (9, 75)</span><br><span class="line">x2 &#x3D; np.random.rand(10, 3, 7, 7) # 10个数据</span><br><span class="line">col2 &#x3D; im2col(x2, 5, 5, stride&#x3D;1, pad&#x3D;0)</span><br><span class="line">print(col2.shape) # (90, 75)</span><br></pre></td></tr></table></figure></p><p>这里举了两个例子。第一个是批大小为1、通道为3的7 × 7的数据，第二个的批大小为10，数据形状和第一个相同。</p><p>分别对其应用im2col函数，在这两种情形下，第2维的元素个数均为75。这是滤波器（通道为3、大小为5 × 5）的元素个数的总和。批大小为1时，im2col的结果是(9, 75)。而第2个例子中批大小为10，所以保存了10倍的数据，即(90, 75)。现在使用im2col来实现卷积层。这里我们将卷积层实现为名为Convolution的类。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">class Convolution:</span><br><span class="line">    def __init__(self, W, b, stride&#x3D;1, pad&#x3D;0):</span><br><span class="line">        self.W &#x3D; W</span><br><span class="line">        self.b &#x3D; b</span><br><span class="line">        self.stride &#x3D; stride</span><br><span class="line">        self.pad &#x3D; pad</span><br><span class="line">        </span><br><span class="line">        # 中间数据（backward时使用）</span><br><span class="line">        self.x &#x3D; None   </span><br><span class="line">        self.col &#x3D; None</span><br><span class="line">        self.col_W &#x3D; None</span><br><span class="line">        </span><br><span class="line">        # 权重和偏置参数的梯度</span><br><span class="line">        self.dW &#x3D; None</span><br><span class="line">        self.db &#x3D; None</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        FN, C, FH, FW &#x3D; self.W.shape</span><br><span class="line">        N, C, H, W &#x3D; x.shape</span><br><span class="line">        out_h &#x3D; 1 + int((H + 2*self.pad - FH) &#x2F; self.stride)</span><br><span class="line">        out_w &#x3D; 1 + int((W + 2*self.pad - FW) &#x2F; self.stride)</span><br><span class="line"></span><br><span class="line">        col &#x3D; im2col(x, FH, FW, self.stride, self.pad)</span><br><span class="line">        col_W &#x3D; self.W.reshape(FN, -1).T</span><br><span class="line"></span><br><span class="line">        out &#x3D; np.dot(col, col_W) + self.b</span><br><span class="line">        out &#x3D; out.reshape(N, out_h, out_w, -1).transpose(0, 3, 1, 2)</span><br><span class="line"></span><br><span class="line">        self.x &#x3D; x</span><br><span class="line">        self.col &#x3D; col</span><br><span class="line">        self.col_W &#x3D; col_W</span><br><span class="line"></span><br><span class="line">        return out</span><br><span class="line"></span><br><span class="line">    def backward(self, dout):</span><br><span class="line">        FN, C, FH, FW &#x3D; self.W.shape</span><br><span class="line">        dout &#x3D; dout.transpose(0,2,3,1).reshape(-1, FN)</span><br><span class="line"></span><br><span class="line">        self.db &#x3D; np.sum(dout, axis&#x3D;0)</span><br><span class="line">        self.dW &#x3D; np.dot(self.col.T, dout)</span><br><span class="line">        self.dW &#x3D; self.dW.transpose(1, 0).reshape(FN, C, FH, FW)</span><br><span class="line"></span><br><span class="line">        dcol &#x3D; np.dot(dout, self.col_W.T)</span><br><span class="line">        dx &#x3D; col2im(dcol, self.x.shape, FH, FW, self.stride, self.pad)</span><br><span class="line"></span><br><span class="line">        return dx</span><br></pre></td></tr></table></figure><p>卷积层的初始化方法将滤波器（权重）、偏置、步幅、填充作为参数接收。</p><p>滤波器是 (FN, C, FH, FW)的 4 维形状。另外，FN、C、FH、FW分别是 Filter Number（滤波器数量）、Channel、Filter Height、Filter Width的缩写。</p><p>这里用粗体字表示Convolution层的实现中的重要部分。在这些粗体字部分，用im2col展开输入数据，并用reshape将滤波器展开为2维数组。然后，计算展开后的矩阵的乘积。</p><p>展开滤波器的部分（代码段中的粗体字）如图7-19所示，将各个滤波器的方块纵向展开为1列。这里通过reshape(FN,-1)将参数指定为-1，这是<br>reshape的一个便利的功能。通过在reshape时指定为-1，reshape函数会自动计算-1维度上的元素个数，以使多维数组的元素个数前后一致。比如，<br>(10, 3, 5, 5)形状的数组的元素个数共有750个，指定reshape(10,-1)后，就会转换成(10, 75)形状的数组。</p><p>forward的实现中，最后会将输出大小转换为合适的形状。转换时使用了NumPy的transpose函数。transpose会更改多维数组的轴的顺序。如图7-20<br>所示，通过指定从0开始的索引（编号）序列，就可以更改轴的顺序。</p><p><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%AE%9E%E7%8E%B04.png" alt></p><p>以上就是卷积层的forward处理的实现。</p><p>通过使用im2col进行展开，基本上可以像实现全连接层的Affine层一样来实现。</p><p>接下来是卷积层的反向传播的实现，因为和Affine层的实现有很多共通的地方，所以就不再介绍了。</p><p>但有一点需要注意，在进行卷积层的反向传播时，必须进行im2col的逆处理。这可以使用本书提供的col2im函数<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line">def col2im(col, input_shape, filter_h, filter_w, stride&#x3D;1, pad&#x3D;0):</span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    Parameters</span><br><span class="line">    ----------</span><br><span class="line">    col :</span><br><span class="line">    input_shape : 输入数据的形状（例：(10, 1, 28, 28)）</span><br><span class="line">    filter_h :</span><br><span class="line">    filter_w</span><br><span class="line">    stride</span><br><span class="line">    pad</span><br><span class="line"></span><br><span class="line">    Returns</span><br><span class="line">    -------</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;</span><br><span class="line">    N, C, H, W &#x3D; input_shape</span><br><span class="line">    out_h &#x3D; (H + 2*pad - filter_h)&#x2F;&#x2F;stride + 1</span><br><span class="line">    out_w &#x3D; (W + 2*pad - filter_w)&#x2F;&#x2F;stride + 1</span><br><span class="line">    col &#x3D; col.reshape(N, out_h, out_w, C, filter_h, filter_w).transpose(0, 3, 4, 5, 1, 2)</span><br><span class="line"></span><br><span class="line">    img &#x3D; np.zeros((N, C, H + 2*pad + stride - 1, W + 2*pad + stride - 1))</span><br><span class="line">    for y in range(filter_h):</span><br><span class="line">        y_max &#x3D; y + stride*out_h</span><br><span class="line">        for x in range(filter_w):</span><br><span class="line">            x_max &#x3D; x + stride*out_w</span><br><span class="line">            img[:, :, y:y_max:stride, x:x_max:stride] +&#x3D; col[:, :, y, x, :, :]</span><br><span class="line"></span><br><span class="line">    return img[:, :, pad:H + pad, pad:W + pad]</span><br></pre></td></tr></table></figure><br>来进行。除了使用col2im这一点，卷积层的反向传播和Affine层的实现方式都一样</p><h1 id="池化层实现"><a href="#池化层实现" class="headerlink" title="池化层实现"></a>池化层实现</h1><p>池化层的实现和卷积层相同，都使用im2col展开输入数据。</p><p>不过，池化的情况下，在通道方向上是独立的，这一点和卷积层不同。</p><p>具体地讲，如图7-21所示，池化的应用区域按通道单独展开。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%AE%9E%E7%8E%B05.png" alt></p><p>像这样展开之后，只需对展开的矩阵求各行的最大值，并转换为合适的形状即可（图7-22）。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%AE%9E%E7%8E%B06.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><span class="line">class Pooling:</span><br><span class="line">    def __init__(self, pool_h, pool_w, stride&#x3D;1, pad&#x3D;0):</span><br><span class="line">        self.pool_h &#x3D; pool_h</span><br><span class="line">        self.pool_w &#x3D; pool_w</span><br><span class="line">        self.stride &#x3D; stride</span><br><span class="line">        self.pad &#x3D; pad</span><br><span class="line">        </span><br><span class="line">        self.x &#x3D; None</span><br><span class="line">        self.arg_max &#x3D; None</span><br><span class="line"></span><br><span class="line">    def forward(self, x):</span><br><span class="line">        N, C, H, W &#x3D; x.shape</span><br><span class="line">        out_h &#x3D; int(1 + (H - self.pool_h) &#x2F; self.stride)</span><br><span class="line">        out_w &#x3D; int(1 + (W - self.pool_w) &#x2F; self.stride)</span><br><span class="line"></span><br><span class="line">        col &#x3D; im2col(x, self.pool_h, self.pool_w, self.stride, self.pad)</span><br><span class="line">        col &#x3D; col.reshape(-1, self.pool_h*self.pool_w)</span><br><span class="line"></span><br><span class="line">        arg_max &#x3D; np.argmax(col, axis&#x3D;1)</span><br><span class="line">        out &#x3D; np.max(col, axis&#x3D;1)</span><br><span class="line">        out &#x3D; out.reshape(N, out_h, out_w, C).transpose(0, 3, 1, 2)</span><br><span class="line"></span><br><span class="line">        self.x &#x3D; x</span><br><span class="line">        self.arg_max &#x3D; arg_max</span><br><span class="line"></span><br><span class="line">        return out</span><br><span class="line"></span><br><span class="line">    def backward(self, dout):</span><br><span class="line">        dout &#x3D; dout.transpose(0, 2, 3, 1)</span><br><span class="line">        </span><br><span class="line">        pool_size &#x3D; self.pool_h * self.pool_w</span><br><span class="line">        dmax &#x3D; np.zeros((dout.size, pool_size))</span><br><span class="line">        dmax[np.arange(self.arg_max.size), self.arg_max.flatten()] &#x3D; dout.flatten()</span><br><span class="line">        dmax &#x3D; dmax.reshape(dout.shape + (pool_size,)) </span><br><span class="line">        </span><br><span class="line">        dcol &#x3D; dmax.reshape(dmax.shape[0] * dmax.shape[1] * dmax.shape[2], -1)</span><br><span class="line">        dx &#x3D; col2im(dcol, self.x.shape, self.pool_h, self.pool_w, self.stride, self.pad)</span><br><span class="line">        </span><br><span class="line">        return dx</span><br></pre></td></tr></table></figure><br>池化层的实现按下面3个阶段进行。</p><ul><li>1.展开输入数据。</li><li>2.求各行的最大值。</li><li>3.转换为合适的输出大小。</li></ul><p>各阶段的实现都很简单，只有一两行代码</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;动手实现卷积层和池化层&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="deep-learning-from-scratch笔记" scheme="http://yoursite.com/tags/deep-learning-from-scratch%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>deep-learning-from-scratch笔记</title>
    <link href="http://yoursite.com/2020/07/29/deep-learning-from-scratch%E7%AC%94%E8%AE%B0/"/>
    <id>http://yoursite.com/2020/07/29/deep-learning-from-scratch%E7%AC%94%E8%AE%B0/</id>
    <published>2020-07-29T03:07:01.000Z</published>
    <updated>2020-07-29T05:59:29.930Z</updated>
    
    <content type="html"><![CDATA[<p>deep-learning-from-scratch笔记<br><a id="more"></a></p><h1 id="sigmoid函数的平滑性对神经网络的学习具有重要意义。"><a href="#sigmoid函数的平滑性对神经网络的学习具有重要意义。" class="headerlink" title="sigmoid函数的平滑性对神经网络的学习具有重要意义。"></a>sigmoid函数的平滑性对神经网络的学习具有重要意义。</h1><p>识别精度对微小的参数变化基本上没有什么反应，即便有反应，它的值也是不连续地、突然地变化。作为激活函数的阶跃函数也有同样的情况。</p><p>出于相同的原因，如果使用阶跃函数作为激活函数，神经网络的学习将无法进行。</p><p>阶跃函数的导数在绝大多数地方（除了0以外的地方）均为0。</p><p>也就是说，如果使用了阶跃函数，那么即便将损失函数作为指标，参数的微<br>小变化也会被阶跃函数抹杀，导致损失函数的值不会产生任何变化。</p><p>sigmoid函数是一条平滑的曲线，输出随着输入发生连续性的变化。而阶跃函数以0为界，输出发生急剧性的变化。</p><p>另一个不同点是，相对于阶跃函数只能返回0或1，sigmoid函数可以返回0.731 …、0.880 …等实数（这一点和刚才的平滑性有关）。也就是说，感<br>知机中神经元之间流动的是0或1的二元信号，而神经网络中流动的是连续的实数值信号。</p><p>sigmoid函数的导数在任何地方都不为0。这对神经网络的学习非常重要。得益于这个斜率不会为0的性质，神经网络的学习得以正确进行</p><h1 id="神经网络的激活函数必须使用非线性函数。"><a href="#神经网络的激活函数必须使用非线性函数。" class="headerlink" title="神经网络的激活函数必须使用非线性函数。"></a>神经网络的激活函数必须使用非线性函数。</h1><p>换句话说，激活函数不能使用线性函数。为什么不能使用线性函数呢？因为使用线性函数的话，加深神经网络的层数就没有意义了。</p><p>线性函数的问题在于，不管如何加深层数，总是存在与之等效的“无隐藏层的神经网络”。</p><h1 id="实现-softmax函数时的注意事项"><a href="#实现-softmax函数时的注意事项" class="headerlink" title="实现 softmax函数时的注意事项"></a>实现 softmax函数时的注意事项</h1><p><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/softmax1.png" alt></p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">def softmax(a):</span><br><span class="line"> exp_a &#x3D; np.exp(a)</span><br><span class="line"> sum_exp_a &#x3D; np.sum(exp_a)</span><br><span class="line"> y &#x3D; exp_a &#x2F; sum_exp_a</span><br><span class="line"> return y</span><br></pre></td></tr></table></figure><p>上面的softmax函数的实现虽然正确描述了式，但在计算机的运算上有一定的缺陷。这个缺陷就是溢出问题。softmax函数的实现中要进行指<br>数函数的运算，但是此时指数函数的值很容易变得非常大。<br>比如，e的10次方的值会超过20000，e的1000次方会变成一个后面有40多个0的超大值，e的1000次方的结果会返回一个表示无穷大的inf。如果在这些超大值之间进行除法运算，结果会出现“不确定”的情况。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/softmax2.png" alt><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&gt;&gt;&gt; a &#x3D; np.array([1010, 1000, 990])</span><br><span class="line">&gt;&gt;&gt; np.exp(a) &#x2F; np.sum(np.exp(a)) # softmax函数的运算</span><br><span class="line">array([ nan, nan, nan]) # 没有被正确计算</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; c &#x3D; np.max(a) # 1010</span><br><span class="line">&gt;&gt;&gt; a - c</span><br><span class="line">array([ 0, -10, -20])</span><br><span class="line">&gt;&gt;&gt;</span><br><span class="line">&gt;&gt;&gt; np.exp(a - c) &#x2F; np.sum(np.exp(a - c))</span><br><span class="line">array([ 9.99954600e-01, 4.53978686e-05, 2.06106005e-09])</span><br></pre></td></tr></table></figure></p><p>如该例所示，通过减去输入信号中的最大值（上例中的c），我们发现原<br>本为nan（not a number，不确定）的地方，现在被正确计算了。综上，我们<br>可以像下面这样实现softmax函数。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">def softmax(a):</span><br><span class="line">    c &#x3D; np.max(a)</span><br><span class="line">    exp_a &#x3D; np.exp(a - c) # 溢出对策</span><br><span class="line">    sum_exp_a &#x3D; np.sum(exp_a)</span><br><span class="line">    y &#x3D; exp_a &#x2F; sum_exp_a</span><br><span class="line">    return y</span><br></pre></td></tr></table></figure></p><h1 id="获得泛化能力是机器学习的最终目标。"><a href="#获得泛化能力是机器学习的最终目标。" class="headerlink" title="获得泛化能力是机器学习的最终目标。"></a>获得泛化能力是机器学习的最终目标。</h1><p>如果让我们自己来设计一个能将5正确分类的程序，就会意外地发现这是一个很难的问题。人可以简单地识别出5，但却很难明确说出是基于何种规律而识别出了5。</p><p>因此，与其绞尽脑汁，从零开始想出一个可以识别5的算法，不如考虑通过有效利用数据来解决这个问题。</p><p>一种方案是，先从图像中提取特征量，再用机器学习技术学习这些特征量的模式。这里所说的“特征量”是指可以从输入数据（输入图像）中准确地提取本质数据（重要的数据）的转换器。</p><p>图像的特征量通常表示为向量的形式。在计算机视觉领域，常用的特征量包括SIFT、SURF和HOG等。使用这些特征量将图像数据转换为向量，然后对转换后的向量使用机器学习中的SVM、KNN等分类器进行学习。</p><p>机器学习的方法中，由机器从收集到的数据中找出规律性。与从零开始想出算法相比，这种方法可以更高效地解决问题，也能减轻人的负担。</p><p>但是需要注意的是，将图像转换为向量时使用的特征量仍是由人设计的。对于不同的问题，必须使用合适的特征量（必须设计专门的特征量），才能得到好的结果。</p><p>比如，为了区分狗的脸部，人们需要考虑与用于识别5的特征量不同的其他特征量。也就是说，即使使用特征量和机器学习的方法，也需要针对不同的问题人工考虑合适的特征量</p><p>神经网络的优点是对所有的问题都可以用同样的流程来解决。比如，不管要求解的问题是识别5，还是识别狗，抑或是识别人脸，神经网络都是通<br>过不断地学习所提供的数据，尝试发现待求解的问题的模式。也就是说，与待处理的问题无关，神经网络可以将数据直接作为原始数据，进行“端对端的学习。</p><p>泛化能力是指处理未被观察过的数据（不包含在训练数据中的数据）的<br>能力。获得泛化能力是机器学习的最终目标。</p><h1 id="计算图优点"><a href="#计算图优点" class="headerlink" title="计算图优点"></a>计算图优点</h1><p>计算图到底有什么优点呢？</p><p>一个优点就在于前面所说的局部计算。无论全局是多么复杂的计算，都可以通过局部计算使各个节点致力于简单的计算，从而简化问题。</p><p>另一个优点是，利用计算图可以将中间的计算结果全部保存起来（比如，计算进行到2个苹果时的金额是200日元、加上消费税之前的金额650日元等）。</p><p>但是只有这些理由可能还无法令人信服。实际上，使用计算图最大的原因是，可以通过反向传播高效计算导数。</p><p>计算图可以集中精力于局部计算。无论全局的计算有多么复杂，各个步骤所要做的就是对象节点的局部计算。虽然局部计算非常简单，但是通过传递它的计算结果，可以获得全局的复杂计算的结果。</p><h1 id="推理和学习"><a href="#推理和学习" class="headerlink" title="推理和学习"></a>推理和学习</h1><p>神经网络中进行的处理有推理（inference）和学习两个阶段。</p><p>神经网络的推理通常不使用 Softmax层。</p><p><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E6%8E%A8%E7%90%86%E4%B8%8E%E5%AD%A6%E4%B9%A0.png" alt></p><p>比如，用上图网络进行推理时，会将最后一个 Affine层的输出作为识别结果。神经网络中未被正规化的输出结果（Softmax层前面的 Affine层的输出）有时被称为“得分”。也就是说，当神经网络的推理只需要给出一个答案的情况下，因为此时只对得分最大值感兴趣，所以不需要 Softmax层。不过，神经网络的学习阶段则需要 Softmax层。</p><h1 id="Momentum"><a href="#Momentum" class="headerlink" title="Momentum"></a>Momentum</h1><p><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/Momentum.png" alt><br>式中有αv这一项。在物体不受任何力时，该项承担使物体逐渐减速的任务（α设定为0.9之类的值），对应物理上的地面摩擦或空气阻力。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">class Momentum:</span><br><span class="line">    def __init__(self, lr&#x3D;0.01, momentum&#x3D;0.9):</span><br><span class="line">        self.lr &#x3D; lr</span><br><span class="line">        self.momentum &#x3D; momentum</span><br><span class="line">        self.v &#x3D; None</span><br><span class="line">    def update(self, params, grads):</span><br><span class="line">        if self.v is None:</span><br><span class="line">            self.v &#x3D; &#123;&#125;</span><br><span class="line">            for key, val in params.items():</span><br><span class="line">                self.v[key] &#x3D; np.zeros_like(val)</span><br><span class="line">        for key in params.keys():</span><br><span class="line">            self.v[key] &#x3D; self.momentum*self.v[key] - self.lr*grads[key]</span><br><span class="line">            params[key] +&#x3D; self.v[key]</span><br></pre></td></tr></table></figure><br>实例变量v会保存物体的速度。初始化时，v中什么都不保存，但当第一次调用update()时，v会以字典型变量的形式保存与参数结构相同的数据。</p><h1 id="AdaGrad和RMSProp"><a href="#AdaGrad和RMSProp" class="headerlink" title="AdaGrad和RMSProp"></a>AdaGrad和RMSProp</h1><p>在神经网络的学习中，学习率（数学式中记为η）的值很重要。学习率过小，会导致学习花费过多时间；反过来，学习率过大，则会导致学习发散而不能正确进行。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/AdaGrad.png" alt><br>在关于学习率的有效技巧中，有一种被称为学习率衰减（learning rate decay）的方法，即随着学习的进行，使学习率逐渐减小。实际上，一开始“多”学，然后逐渐“少”学的方法，在神经网络的学习中经常被使用。逐渐减小学习率的想法，相当于将“全体”参数的学习率值一起降低。而AdaGrad进一步发展了这个想法，针对“一个一个”的参数，赋予其“定制”的值。</p><p>AdaGrad会记录过去所有梯度的平方和。因此，学习越深入，更新的幅度就越小。实际上，如果无止境地学习，更新量就会变为 0，完全不再更新。为了改善这个问题，可以使用 RMSProp方法。RMSProp方法并不是将过去所有的梯度一视同仁地相加，而是逐渐地遗忘过去的梯度，在做加法运算时将新梯度的信息更多地反映出来。这种操作从专业上讲，称为“指数移动平均”，呈指数函数式地减小过去的梯度的尺度。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class AdaGrad:</span><br><span class="line">    def __init__(self, lr&#x3D;0.01):</span><br><span class="line">        self.lr &#x3D; lr</span><br><span class="line">        self.h &#x3D; None</span><br><span class="line">    def update(self, params, grads):</span><br><span class="line">        if self.h is None:</span><br><span class="line">            self.h &#x3D; &#123;&#125;</span><br><span class="line">            for key, val in params.items():</span><br><span class="line">                self.h[key] &#x3D; np.zeros_like(val)</span><br><span class="line">        for key in params.keys():</span><br><span class="line">            self.h[key] +&#x3D; grads[key] * grads[key]</span><br><span class="line">            params[key] -&#x3D; self.lr * grads[key] &#x2F; (np.sqrt(self.h[key]) + 1e-7)</span><br></pre></td></tr></table></figure><p>这里需要注意的是，最后一行加上了微小值1e-7。这是为了防止当<br>self.h[key]中有0时，将0用作除数的情况。在很多深度学习的框架中，这<br>个微小值也可以设定为参数，但这里我们用的是1e-7这个固定值。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class RMSprop:</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;RMSprop&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, lr&#x3D;0.01, decay_rate &#x3D; 0.99):</span><br><span class="line">        self.lr &#x3D; lr</span><br><span class="line">        self.decay_rate &#x3D; decay_rate</span><br><span class="line">        self.h &#x3D; None</span><br><span class="line">        </span><br><span class="line">    def update(self, params, grads):</span><br><span class="line">        if self.h is None:</span><br><span class="line">            self.h &#x3D; &#123;&#125;</span><br><span class="line">            for key, val in params.items():</span><br><span class="line">                self.h[key] &#x3D; np.zeros_like(val)</span><br><span class="line">            </span><br><span class="line">        for key in params.keys():</span><br><span class="line">            self.h[key] *&#x3D; self.decay_rate</span><br><span class="line">            self.h[key] +&#x3D; (1 - self.decay_rate) * grads[key] * grads[key]</span><br><span class="line">            params[key] -&#x3D; self.lr * grads[key] &#x2F; (np.sqrt(self.h[key]) + 1e-7)</span><br></pre></td></tr></table></figure></p><h1 id="Adam"><a href="#Adam" class="headerlink" title="Adam"></a>Adam</h1><p>Adam是2015年提出的新方法。它的理论有些复杂，直观地讲，就是融合了Momentum和AdaGrad的方法。通过组合前面两个方法的优点，有望实现参数空间的高效搜索。<br>此外，进行超参数的“偏置校正”也是Adam的特征。<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">class Adam:</span><br><span class="line"></span><br><span class="line">    &quot;&quot;&quot;Adam (http:&#x2F;&#x2F;arxiv.org&#x2F;abs&#x2F;1412.6980v8)&quot;&quot;&quot;</span><br><span class="line"></span><br><span class="line">    def __init__(self, lr&#x3D;0.001, beta1&#x3D;0.9, beta2&#x3D;0.999):</span><br><span class="line">        self.lr &#x3D; lr</span><br><span class="line">        self.beta1 &#x3D; beta1</span><br><span class="line">        self.beta2 &#x3D; beta2</span><br><span class="line">        self.iter &#x3D; 0</span><br><span class="line">        self.m &#x3D; None</span><br><span class="line">        self.v &#x3D; None</span><br><span class="line">        </span><br><span class="line">    def update(self, params, grads):</span><br><span class="line">        if self.m is None:</span><br><span class="line">            self.m, self.v &#x3D; &#123;&#125;, &#123;&#125;</span><br><span class="line">            for key, val in params.items():</span><br><span class="line">                self.m[key] &#x3D; np.zeros_like(val)</span><br><span class="line">                self.v[key] &#x3D; np.zeros_like(val)</span><br><span class="line">        </span><br><span class="line">        self.iter +&#x3D; 1</span><br><span class="line">        lr_t  &#x3D; self.lr * np.sqrt(1.0 - self.beta2**self.iter) &#x2F; (1.0 - self.beta1**self.iter)         </span><br><span class="line">        </span><br><span class="line">        for key in params.keys():</span><br><span class="line">            #self.m[key] &#x3D; self.beta1*self.m[key] + (1-self.beta1)*grads[key]</span><br><span class="line">            #self.v[key] &#x3D; self.beta2*self.v[key] + (1-self.beta2)*(grads[key]**2)</span><br><span class="line">            self.m[key] +&#x3D; (1 - self.beta1) * (grads[key] - self.m[key])</span><br><span class="line">            self.v[key] +&#x3D; (1 - self.beta2) * (grads[key]**2 - self.v[key])</span><br><span class="line">            </span><br><span class="line">            params[key] -&#x3D; lr_t * self.m[key] &#x2F; (np.sqrt(self.v[key]) + 1e-7)</span><br><span class="line">            </span><br><span class="line">            #unbias_m +&#x3D; (1 - self.beta1) * (grads[key] - self.m[key]) # correct bias</span><br><span class="line">            #unbisa_b +&#x3D; (1 - self.beta2) * (grads[key]*grads[key] - self.v[key]) # correct bias</span><br><span class="line">            #params[key] +&#x3D; self.lr * unbias_m &#x2F; (np.sqrt(unbisa_b) + 1e-7)</span><br></pre></td></tr></table></figure></p><h1 id="可以将权重初始值设为0吗"><a href="#可以将权重初始值设为0吗" class="headerlink" title="可以将权重初始值设为0吗"></a>可以将权重初始值设为0吗</h1><p>为什么不能将权重初始值设为0呢？</p><p>严格地说，为什么不能将权重初始值设成一样的值呢？</p><p>这是因为在误差反向传播法中，所有的权重值都会进行相同的更新。</p><p>比如，在2层神经网络中，假设第1层和第2层的权重为0。这样一来，正向传播时，因为输入层的权重为0，所以第2层的神经元全部会<br>被传递相同的值。第2层的神经元中全部输入相同的值，这意味着反向传播时第2层的权重全部都会进行相同的更新（回忆一下“乘法节点的反向传播”的内容）。</p><p>因此，权重被更新为相同的值，并拥有了对称的值（重复的值）。这使得神经网络拥有许多不同的权重的意义丧失了。为了防止“权重均一化”（严格地讲，是为了瓦解权重的对称结构），必须随机生成初始值。</p><h1 id="各层的激活值的分布都要求有适当的广度"><a href="#各层的激活值的分布都要求有适当的广度" class="headerlink" title="各层的激活值的分布都要求有适当的广度"></a>各层的激活值的分布都要求有适当的广度</h1><p>各层的激活值的分布都要求有适当的广度。为什么呢？</p><p>因为通过在各层间传递多样性的数据，神经网络可以进行高效的学习。</p><p>反过来，如果传递的是有所偏向的数据，就会出现梯度消失或者“表现力受限”的问题，导致学习可能无法顺利进行。</p><p>激活值的分布有所偏向，说明在表现力上会有很大问题。为什么这么说呢？</p><p>因为如果有多个神经元都输出几乎相同的值，那它们就没有存在的意义了。</p><p>比如，如果100个神经元都输出几乎相同的值，那么也可以由1个神经元来表达基本相同的事情。</p><p>因此，激活值在分布上有所偏向会出现“表现力受限”的问题。</p><h1 id="Batch-Norm"><a href="#Batch-Norm" class="headerlink" title="Batch Norm"></a>Batch Norm</h1><p>为什么Batch Norm这么惹人注目呢？因为Batch Norm有以下优点。</p><ul><li>可以使学习快速进行（可以增大学习率）。</li><li>不那么依赖初始值（对于初始值不用那么神经质）。</li><li>抑制过拟合（降低Dropout等的必要性）。</li></ul><p>Batch Norm的思路是调整各层的激活值分布使其拥有适当的广度。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/Batch%20Norm.png" alt></p><h1 id="权值衰减"><a href="#权值衰减" class="headerlink" title="权值衰减"></a>权值衰减</h1><p>权值衰减是一直以来经常被使用的一种抑制过拟合的方法。</p><p>该方法通过在学习的过程中对大的权重进行惩罚，来抑制过拟合。</p><p>很多过拟合原本就是因为权重参数取值过大才发生的。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E6%9D%83%E5%80%BC%E8%A1%B0%E5%87%8F.png" alt></p><h1 id="Dropout"><a href="#Dropout" class="headerlink" title="Dropout"></a>Dropout</h1><p>作为抑制过拟合的方法，前面我们介绍了为损失函数加上权重的L2范数的权值衰减方法。</p><p>该方法可以简单地实现，在某种程度上能够抑制过拟合。但是，如果网络的模型变得很复杂，只用权值衰减就难以应对了。</p><p>在这种情况下，我们经常会使用Dropout方法。</p><p>Dropout是一种在学习的过程中随机删除神经元的方法。<br>训练时，随机选出隐藏层的神经元，然后将其删除。被删除的神经元不再进行信号的传递，</p><p><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/Dropout.png" alt><br>训练时，每传递一次数据，就会随机选择要删除的神经元。<br>然后，测试时，虽然会传递所有的神经元信号，但是对于各个神经元的输出，要乘上训练时的删除比例后再输出。</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">class Dropout:</span><br><span class="line">    def __init__(self, dropout_ratio&#x3D;0.5):</span><br><span class="line">        self.dropout_ratio &#x3D; dropout_ratio</span><br><span class="line">        self.mask &#x3D; None</span><br><span class="line">    def forward(self, x, train_flg&#x3D;True):</span><br><span class="line">        if train_flg:</span><br><span class="line">            self.mask &#x3D; np.random.rand(*x.shape) &gt; self.dropout_ratio</span><br><span class="line">            return x * self.mask</span><br><span class="line">        else:</span><br><span class="line">            return x * (1.0 - self.dropout_ratio)</span><br><span class="line">        def backward(self, dout):</span><br><span class="line">            return dout * self.mask</span><br></pre></td></tr></table></figure><p>这里的要点是，每次正向传播时，self.mask中都会以False的形式保存要删除的神经元。</p><p>self.mask会随机生成和x形状相同的数组，并将值比dropout_ratio大的元素设为True。反向传播时的行为和ReLU相同。</p><p>也就是说，正向传播时传递了信号的神经元，反向传播时按原样传递信号；正向传播时没有传递信号的神经元，反向传播时信号将停在那里。</p><h1 id="验证数据"><a href="#验证数据" class="headerlink" title="验证数据"></a>验证数据</h1><p>调整超参数时，必须使用超参数专用的确认数据。</p><p>用于调整超参数的数据，一般称为验证数据（validation data）。</p><p>我们使用这个验证数据来评估超参数的好坏。</p><h1 id="卷积层"><a href="#卷积层" class="headerlink" title="卷积层"></a>卷积层</h1><p><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%8D%B7%E7%A7%AF1.png" alt><br>卷积运算对输入数据应用滤波器。</p><p>在这个例子中，输入数据是有高长方向的形状的数据，滤波器也一样，有高长方向上的维度。</p><p>假设用（height, width）表示数据和滤波器的形状，则在本例中，输入大小是(4, 4)，滤波器大小是(3, 3)，输出大小是(2, 2)。</p><p>另外，有的文献中也会用“核”这个词来表示这里所说的“滤波器”。</p><p><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%8D%B7%E7%A7%AF2.png" alt><br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%8D%B7%E7%A7%AF3.png" alt></p><p>应用滤波器的位置间隔称为步幅（stride）。之前的例子中步幅都是1，如果将步幅设为2，则如下图所示，应用滤波器的窗口的间隔变为2个元素。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%8D%B7%E7%A7%AF4.png" alt></p><p><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%8D%B7%E7%A7%AF5.png" alt></p><p>之前的卷积运算的例子都是以有高、长方向的2维形状为对象的。</p><p>但是，图像是3维数据，除了高、长方向之外，还需要处理通道方向。</p><p>这里，我们按照与之前相同的顺序，看一下对加上了通道方向的3维数据进行卷积运算的例子。</p><p>图7-8是卷积运算的例子，图7-9是计算顺序。</p><p>这里以3通道的数据为例，展示了卷积运算的结果。和2维数据时（图7-3的例子）相比，可以发现纵深方向（通道方向）上特征图增加了。</p><p>通道方向上有多个特征图时，会按通道进行输入数据和滤波器的卷积运算，并将结果相加，从而得到输出。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%8D%B7%E7%A7%AF6.png" alt><br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%8D%B7%E7%A7%AF7.png" alt></p><p>将数据和滤波器结合长方体的方块来考虑，3维数据的卷积运算会很容易理解。</p><p>方块是如图7-10所示的3维长方体。把3维数据表示为多维数组时，书写顺序为（channel, height, width）。</p><p>比如，通道数为C、高度为H、长度为W的数据的形状可以写成（C, H, W）。</p><p>滤波器也一样，要按（channel, height, width）的顺序书写。</p><p>比如，通道数为C、滤波器高度为FH（Filter Height）、长度为FW（Filter Width）时，可以写成（C, FH, FW）。</p><p><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%8D%B7%E7%A7%AF8.png" alt><br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%8D%B7%E7%A7%AF9.png" alt></p><p>图7-11中，通过应用FN个滤波器，输出特征图也生成了FN个。</p><p>如果将这FN个特征图汇集在一起，就得到了形状为(FN, OH, OW)的方块。将这个方块传给下一层，就是CNN的处理流。</p><p>如图 7-11 所示，关于卷积运算的滤波器，也必须考虑滤波器的数量。</p><p>因此，作为4维数据，滤波器的权重数据要按(output_channel, input_channel, height, width)的顺序书写。</p><p>比如，通道数为3、大小为5 × 5的滤波器有20个时，可以写成(20, 3, 5, 5)。</p><p>卷积运算中（和全连接层一样）存在偏置。在图7-11的例子中，如果进一步追加偏置的加法运算处理，则结果如下面的图7-12所示。</p><p>图7-12中，每个通道只有一个偏置。这里，偏置的形状是(FN, 1, 1)，滤波器的输出结果的形状是(FN, OH, OW)。</p><p>这两个方块相加时，要对滤波器的输出结果(FN, OH, OW)按通道加上相同的偏置值。</p><p>另外，不同形状的方块相加时，可以基于NumPy的广播功能轻松实现<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%8D%B7%E7%A7%AF10.png" alt></p><p>神经网络的处理中进行了将输入数据打包的批处理。</p><p>之前的全连接神经网络的实现也对应了批处理，通过批处理，能够实现处理的高效化和学习时对mini-batch的对应。</p><p>我们希望卷积运算也同样对应批处理。为此，需要将在各层间传递的数据保存为4维数据。</p><p>具体地讲，就是按(batch_num, channel, height, width)的顺序保存数据。</p><p>比如，将图7-12中的处理改成对N个数据进行批处理时，数据的形状如图7-13所示。</p><p>图7-13的批处理版的数据流中，在各个数据的开头添加了批用的维度。像这样，数据作为4维的形状在各层间传递。</p><p>这里需要注意的是，网络间传递的是4维数据，对这N个数据进行了卷积运算。也就是说，批处理将N次的处理汇总成了1次进行。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E5%8D%B7%E7%A7%AF11.png" alt></p><h1 id="池化层"><a href="#池化层" class="headerlink" title="池化层"></a>池化层</h1><p><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E6%B1%A0%E5%8C%961.png" alt><br>图7-14的例子是按步幅2进行2 × 2的Max池化时的处理顺序。“Max池化”是获取最大值的运算，“2 × 2”表示目标区域的大小。</p><p>如图所示，从2 × 2的区域中取出最大的元素。此外，这个例子中将步幅设为了2，所以2 × 2的窗口的移动间隔为2个元素。</p><p>另外，一般来说，池化的窗口大小会和步幅设定成相同的值。比如，3 × 3的窗口的步幅会设为3，4 × 4的窗口的步幅会设为4等。</p><p>池化层有以下特征。</p><ul><li>没有要学习的参数。池化层和卷积层不同，没有要学习的参数。池化只是从目标区域中取最大值（或者平均值），所以不存在要学习的参数。<br>通道数不发生变化</li><li>经过池化运算，输入数据和输出数据的通道数不会发生变化。如图7-15<br>所示，计算是按通道独立进行的。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E6%B1%A0%E5%8C%962.png" alt><br>对微小的位置变化具有鲁棒性（健壮）</li></ul><p>输入数据发生微小偏差时，池化仍会返回相同的结果。因此，池化对输入数据的微小偏差具有鲁棒性。比如，3 × 3的池化的情况下，如图7-16所示，池化会吸收输入数据的偏差（根据数据的不同，结果有可能不一致）。<br><img src="http://zs-hexo-blog.oss-cn-beijing.aliyuncs.com/%E6%B1%A0%E5%8C%963.png" alt></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;deep-learning-from-scratch笔记&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="深度学习" scheme="http://yoursite.com/categories/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
    
      <category term="深度学习" scheme="http://yoursite.com/tags/%E6%B7%B1%E5%BA%A6%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="deep-learning-from-scratch笔记" scheme="http://yoursite.com/tags/deep-learning-from-scratch%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(17)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-27T09:20:38.000Z</published>
    <updated>2020-07-27T11:03:36.468Z</updated>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了概率图模型，首先从生成式模型与判别式模型的定义出发，引出了概率图模型的基本概念，即利用图结构来表达变量之间的依赖关系；接着分别介绍了隐马尔可夫模型、马尔可夫随机场、条件随机场、精确推断方法以及LDA话题模型：HMM主要围绕着评估/解码/学习这三个实际问题展开论述；MRF基于团和势函数的概念来定义联合概率分布；CRF引入两种特征函数对状态序列进行评价打分；变量消去与信念传播在给定联合概率分布后计算特定变量的边际分布；LDA话题模型则试图去推断给定文档所蕴含的话题分布。本篇将介绍最后一种学习算法—强化学习。<br><a id="more"></a><br>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:20px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="16、强化学习"><a href="#16、强化学习" class="headerlink" title="16、强化学习"></a><strong>16、强化学习</strong></h1><p><strong>强化学习</strong>（Reinforcement Learning，简称<strong>RL</strong>）是机器学习的一个重要分支，前段时间人机大战的主角AlphaGo正是以强化学习为核心技术。在强化学习中，包含两种基本的元素：<strong>状态</strong>与<strong>动作</strong>，<strong>在某个状态下执行某种动作，这便是一种策略</strong>，学习器要做的就是通过不断地探索学习，从而获得一个好的策略。例如：在围棋中，一种落棋的局面就是一种状态，若能知道每种局面下的最优落子动作，那就攻无不克/百战不殆了~</p><p>若将状态看作为属性，动作看作为标记，易知：<strong>监督学习和强化学习都是在试图寻找一个映射，从已知属性/状态推断出标记/动作</strong>，这样强化学习中的策略相当于监督学习中的分类/回归器。但在实际问题中，<strong>强化学习并没有监督学习那样的标记信息</strong>，通常都是在<strong>尝试动作后才能获得结果</strong>，因此强化学习是通过反馈的结果信息不断调整之前的策略，从而算法能够学习到：在什么样的状态下选择什么样的动作可以获得最好的结果。</p><h2 id="16-1-基本要素"><a href="#16-1-基本要素" class="headerlink" title="16.1 基本要素"></a><strong>16.1 基本要素</strong></h2><p>强化学习任务通常使用<strong>马尔可夫决策过程</strong>（Markov Decision Process，简称<strong>MDP</strong>）来描述，具体而言：机器处在一个环境中，每个状态为机器对当前环境的感知；机器只能通过动作来影响环境，当机器执行一个动作后，会使得环境按某种概率转移到另一个状态；同时，环境会根据潜在的奖赏函数反馈给机器一个奖赏。综合而言，强化学习主要包含四个要素：状态、动作、转移概率以及奖赏函数。</p><blockquote><p><strong>状态（X）</strong>：机器对环境的感知，所有可能的状态称为状态空间；<br><strong>动作（A）</strong>：机器所采取的动作，所有能采取的动作构成动作空间；<br><strong>转移概率（P）</strong>：当执行某个动作后，当前状态会以某种概率转移到另一个状态；<br><strong>奖赏函数（R）</strong>：在状态转移的同时，环境给反馈给机器一个奖赏。</p></blockquote><p><img src="https://s1.ax1x.com/2018/10/18/iwYOud.png" alt="iwYOud.png"></p><p>因此，<strong>强化学习的主要任务就是通过在环境中不断地尝试，根据尝试获得的反馈信息调整策略，最终生成一个较好的策略π，机器根据这个策略便能知道在什么状态下应该执行什么动作</strong>。常见的策略表示方法有以下两种：</p><blockquote><p><strong>确定性策略</strong>：π（x）=a，即在状态x下执行a动作；<br><strong>随机性策略</strong>：P=π（x,a），即在状态x下执行a动作的概率。</p></blockquote><p><strong>一个策略的优劣取决于长期执行这一策略后的累积奖赏</strong>，换句话说：可以使用累积奖赏来评估策略的好坏，最优策略则表示在初始状态下一直执行该策略后，最后的累积奖赏值最高。长期累积奖赏通常使用下述两种计算方法：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYH3D.png" alt="iwYH3D.png"></p><h2 id="16-2-K摇摆赌博机"><a href="#16-2-K摇摆赌博机" class="headerlink" title="16.2 K摇摆赌博机"></a><strong>16.2 K摇摆赌博机</strong></h2><p>首先我们考虑强化学习最简单的情形：仅考虑一步操作，即在状态x下只需执行一次动作a便能观察到奖赏结果。易知：欲最大化单步奖赏，我们需要知道每个动作带来的期望奖赏值，这样便能选择奖赏值最大的动作来执行。若每个动作的奖赏值为确定值，则只需要将每个动作尝试一遍即可，但大多数情形下，一个动作的奖赏值来源于一个概率分布，因此需要进行多次的尝试。</p><p>单步强化学习实质上是<strong>K-摇臂赌博机</strong>（K-armed bandit）的原型，一般我们<strong>尝试动作的次数是有限的</strong>，那如何利用有限的次数进行有效地探索呢？这里有两种基本的想法：</p><blockquote><p><strong>仅探索法</strong>：将尝试的机会平均分给每一个动作，即轮流执行，最终将每个动作的平均奖赏作为期望奖赏的近似值。<br><strong>仅利用法</strong>：将尝试的机会分给当前平均奖赏值最大的动作，隐含着让一部分人先富起来的思想。</p></blockquote><p>可以看出：上述<strong>两种方法是相互矛盾的</strong>，仅探索法能较好地估算每个动作的期望奖赏，但是没能根据当前的反馈结果调整尝试策略；仅利用法在每次尝试之后都更新尝试策略，符合强化学习的思（tao）维（lu），但容易找不到最优动作。因此需要在这两者之间进行折中。</p><h3 id="16-2-1-ε-贪心"><a href="#16-2-1-ε-贪心" class="headerlink" title="16.2.1 ε-贪心"></a><strong>16.2.1 ε-贪心</strong></h3><p><strong>ε-贪心法基于一个概率来对探索和利用进行折中</strong>，具体而言：在每次尝试时，以ε的概率进行探索，即以均匀概率随机选择一个动作；以1-ε的概率进行利用，即选择当前最优的动作。ε-贪心法只需记录每个动作的当前平均奖赏值与被选中的次数，便可以增量式更新。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYzUP.png" alt="iwYzUP.png"></p><h3 id="16-2-2-Softmax"><a href="#16-2-2-Softmax" class="headerlink" title="16.2.2 Softmax"></a><strong>16.2.2 Softmax</strong></h3><p><strong>Softmax算法则基于当前每个动作的平均奖赏值来对探索和利用进行折中，Softmax函数将一组值转化为一组概率</strong>，值越大对应的概率也越高，因此当前平均奖赏值越高的动作被选中的几率也越大。Softmax函数如下所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYbge.png" alt="iwYbge.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYqjH.png" alt="iwYqjH.png"></p><h2 id="16-3-有模型学习"><a href="#16-3-有模型学习" class="headerlink" title="16.3 有模型学习"></a><strong>16.3 有模型学习</strong></h2><p>若学习任务中的四个要素都已知，即状态空间、动作空间、转移概率以及奖赏函数都已经给出，这样的情形称为“<strong>有模型学习</strong>”。假设状态空间和动作空间均为有限，即均为离散值，这样我们不用通过尝试便可以对某个策略进行评估。</p><h3 id="16-3-1-策略评估"><a href="#16-3-1-策略评估" class="headerlink" title="16.3.1 策略评估"></a><strong>16.3.1 策略评估</strong></h3><p>前面提到：<strong>在模型已知的前提下，我们可以对任意策略的进行评估</strong>（后续会给出演算过程）。一般常使用以下两种值函数来评估某个策略的优劣：</p><blockquote><p><strong>状态值函数（V）</strong>：V（x），即从状态x出发，使用π策略所带来的累积奖赏；<br><strong>状态-动作值函数（Q）</strong>：Q（x,a），即从状态x出发，执行动作a后再使用π策略所带来的累积奖赏。</p></blockquote><p>根据累积奖赏的定义，我们可以引入T步累积奖赏与r折扣累积奖赏：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYjHI.png" alt="iwYjHI.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYXDA.png" alt="iwYXDA.png"></p><p>由于MDP具有马尔可夫性，即现在决定未来，将来和过去无关，我们很容易找到值函数的递归关系：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtS4f.png" alt="iwtS4f.png"></p><p>类似地，对于r折扣累积奖赏可以得到：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYxEt.png" alt="iwYxEt.png"></p><p>易知：<strong>当模型已知时，策略的评估问题转化为一种动态规划问题</strong>，即以填表格的形式自底向上，先求解每个状态的单步累积奖赏，再求解每个状态的两步累积奖赏，一直迭代逐步求解出每个状态的T步累积奖赏。算法流程如下所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwt9C8.png" alt="iwt9C8.png"></p><p>对于状态-动作值函数，只需通过简单的转化便可得到：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwt3r9.png" alt="iwt3r9.png"></p><h3 id="16-3-2-策略改进"><a href="#16-3-2-策略改进" class="headerlink" title="16.3.2 策略改进"></a><strong>16.3.2 策略改进</strong></h3><p>理想的策略应能使得每个状态的累积奖赏之和最大，简单来理解就是：不管处于什么状态，只要通过该策略执行动作，总能得到较好的结果。因此对于给定的某个策略，我们需要对其进行改进，从而得到<strong>最优的值函数</strong>。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtm5V.png" alt="iwtm5V.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwtZEq.png" alt="iwtZEq.png"></p><p>最优Bellman等式改进策略的方式为：<strong>将策略选择的动作改为当前最优的动作</strong>，而不是像之前那样对每种可能的动作进行求和。易知：选择当前最优动作相当于将所有的概率都赋给累积奖赏值最大的动作，因此每次改进都会使得值函数单调递增。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtEbn.png" alt="iwtEbn.png"></p><p>将策略评估与策略改进结合起来，我们便得到了生成最优策略的方法：先给定一个随机策略，现对该策略进行评估，然后再改进，接着再评估/改进一直到策略收敛、不再发生改变。这便是策略迭代算法，算法流程如下所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwteU0.png" alt="iwteU0.png"></p><p>可以看出：策略迭代法在每次改进策略后都要对策略进行重新评估，因此比较耗时。若从最优化值函数的角度出发，即先迭代得到最优的值函数，再来计算如何改变策略，这便是值迭代算法，算法流程如下所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtuCT.png" alt="iwtuCT.png"></p><h2 id="16-4-蒙特卡罗强化学习"><a href="#16-4-蒙特卡罗强化学习" class="headerlink" title="16.4 蒙特卡罗强化学习"></a><strong>16.4 蒙特卡罗强化学习</strong></h2><p>在现实的强化学习任务中，<strong>环境的转移函数与奖赏函数往往很难得知</strong>，因此我们需要考虑在不依赖于环境参数的条件下建立强化学习模型，这便是<strong>免模型学习</strong>。蒙特卡罗强化学习便是其中的一种经典方法。</p><p>由于模型参数未知，状态值函数不能像之前那样进行全概率展开，从而运用动态规划法求解。一种直接的方法便是通过采样来对策略进行评估/估算其值函数，<strong>蒙特卡罗强化学习正是基于采样来估计状态-动作值函数</strong>：对采样轨迹中的每一对状态-动作，记录其后的奖赏值之和，作为该状态-动作的一次累积奖赏，通过多次采样后，使用累积奖赏的平均作为状态-动作值的估计，并<strong>引入ε-贪心策略保证采样的多样性</strong>。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwt1KJ.png" alt="iwt1KJ.png"></p><p>在上面的算法流程中，被评估和被改进的都是同一个策略，因此称为<strong>同策略蒙特卡罗强化学习算法</strong>。引入ε-贪心仅是为了便于采样评估，而在使用策略时并不需要ε-贪心，那能否仅在评估时使用ε-贪心策略，而在改进时使用原始策略呢？这便是<strong>异策略蒙特卡罗强化学习算法</strong>。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtK8U.png" alt="iwtK8U.png"></p><h2 id="16-5-AlphaGo原理浅析"><a href="#16-5-AlphaGo原理浅析" class="headerlink" title="16.5 AlphaGo原理浅析"></a><strong>16.5 AlphaGo原理浅析</strong></h2><p>本篇一开始便提到强化学习是AlphaGo的核心技术之一，刚好借着这个东风将AlphaGo的工作原理了解一番。正如人类下棋那般“<strong>手下一步棋，心想三步棋</strong>”，Alphago也正是这个思想，<strong>当处于一个状态时，机器会暗地里进行多次的尝试/采样，并基于反馈回来的结果信息改进估值函数，从而最终通过增强版的估值函数来选择最优的落子动作。</strong></p><p>其中便涉及到了三个主要的问题：<strong>（1）如何确定估值函数（2）如何进行采样（3）如何基于反馈信息改进估值函数</strong>，这正对应着AlphaGo的三大核心模块：<strong>深度学习</strong>、<strong>蒙特卡罗搜索树</strong>、<strong>强化学习</strong>。</p><blockquote><p><strong>1.深度学习（拟合估值函数）</strong></p></blockquote><p>由于围棋的状态空间巨大，像蒙特卡罗强化学习那样通过采样来确定值函数就行不通了。在围棋中，<strong>状态值函数可以看作为一种局面函数，状态-动作值函数可以看作一种策略函数</strong>，若我们能获得这两个估值函数，便可以根据这两个函数来完成：(1)衡量当前局面的价值；(2)选择当前最优的动作。那如何精确地估计这两个估值函数呢？<strong>这就用到了深度学习，通过大量的对弈数据自动学习出特征，从而拟合出估值函数。</strong></p><blockquote><p><strong>2.蒙特卡罗搜索树（采样）</strong></p></blockquote><p>蒙特卡罗树是一种经典的搜索框架，它通过反复地采样模拟对局来探索状态空间。具体表现在：从当前状态开始，利用策略函数尽可能选择当前最优的动作，同时也引入随机性来减小估值错误带来的负面影响，从而模拟棋局运行，使得棋盘达到终局或一定步数后停止。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtM2F.png" alt="iwtM2F.png"></p><blockquote><p><strong>3.强化学习（调整估值函数）</strong></p></blockquote><p>在使用蒙特卡罗搜索树进行多次采样后，每次采样都会反馈后续的局面信息（利用局面函数进行评价），根据反馈回来的结果信息自动调整两个估值函数的参数，这便是强化学习的核心思想，最后基于改进后的策略函数选择出当前最优的落子动作。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwtQv4.png" alt="iwtQv4.png"></p><p>在此，强化学习就介绍完毕。同时也意味着大口小口地啃完了这个西瓜，十分记得去年双11之后立下这个Flag，现在回想起来，大半年的时间里在嚼瓜上还是花费了不少功夫。有人说：当你阐述的能让别人看懂才算是真的理解，有人说：在写的过程中能发现那些只看书发现不了的东西，自己最初的想法十分简单：当健忘症发作的时候，如果能看到之前按照自己思路写下的文字，回忆便会汹涌澎湃一些~</p><p>最后，感谢自己这大半年以来的坚持~Get busy living, or get busy dying!</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇主要介绍了概率图模型，首先从生成式模型与判别式模型的定义出发，引出了概率图模型的基本概念，即利用图结构来表达变量之间的依赖关系；接着分别介绍了隐马尔可夫模型、马尔可夫随机场、条件随机场、精确推断方法以及LDA话题模型：HMM主要围绕着评估/解码/学习这三个实际问题展开论述；MRF基于团和势函数的概念来定义联合概率分布；CRF引入两种特征函数对状态序列进行评价打分；变量消去与信念传播在给定联合概率分布后计算特定变量的边际分布；LDA话题模型则试图去推断给定文档所蕴含的话题分布。本篇将介绍最后一种学习算法—强化学习。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(16)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-07-27T08:20:38.000Z</published>
    <updated>2020-07-27T11:09:55.864Z</updated>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了半监督学习，首先从如何利用未标记样本所蕴含的分布信息出发，引入了半监督学习的基本概念，即训练数据同时包含有标记样本和未标记样本的学习方法；接着分别介绍了几种常见的半监督学习方法：生成式方法基于对数据分布的假设，利用未标记样本隐含的分布信息，使得对模型参数的估计更加准确；TSVM给未标记样本赋予伪标记，并通过不断调整易出错样本的标记得到最终输出；基于分歧的方法结合了集成学习的思想，通过多个学习器在不同视图上的协作，有效利用了未标记样本数据 ；最后半监督聚类则是借助已有的监督信息来辅助聚类的过程，带约束k-均值算法需检测当前样本划分是否满足约束关系，带标记k-均值算法则利用有标记样本指定初始类中心。本篇将讨论一种基于图的学习算法—概率图模型。<br><a id="more"></a></p><p>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:25px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="15、概率图模型"><a href="#15、概率图模型" class="headerlink" title="15、概率图模型"></a><strong>15、概率图模型</strong></h1><p>现在再来谈谈机器学习的核心价值观，可以更通俗地理解为：<strong>根据一些已观察到的证据来推断未知</strong>，更具哲学性地可以阐述为：未来的发展总是遵循着历史的规律。其中<strong>基于概率的模型将学习任务归结为计算变量的概率分布</strong>，正如之前已经提到的：生成式模型先对联合分布进行建模，从而再来求解后验概率，例如：贝叶斯分类器先对联合分布进行最大似然估计，从而便可以计算类条件概率；判别式模型则是直接对条件分布进行建模。</p><p><strong>概率图模型</strong>（probabilistic graphical model）是一类用<strong>图结构</strong>来表达各属性之间相关关系的概率模型，一般而言：<strong>图中的一个结点表示一个或一组随机变量，结点之间的边则表示变量间的相关关系</strong>，从而形成了一张“<strong>变量关系图</strong>”。若使用有向的边来表达变量之间的依赖关系，这样的有向关系图称为<strong>贝叶斯网</strong>（Bayesian nerwork）或有向图模型；若使用无向边，则称为<strong>马尔可夫网</strong>（Markov network）或无向图模型。</p><h2 id="15-1-隐马尔可夫模型-HMM"><a href="#15-1-隐马尔可夫模型-HMM" class="headerlink" title="15.1 隐马尔可夫模型(HMM)"></a><strong>15.1 隐马尔可夫模型(HMM)</strong></h2><p>隐马尔可夫模型（Hidden Markov Model，简称HMM）是结构最简单的一种贝叶斯网，在语音识别与自然语言处理领域上有着广泛的应用。HMM中的变量分为两组：<strong>状态变量</strong>与<strong>观测变量</strong>，其中状态变量一般是未知的，因此又称为“<strong>隐变量</strong>”，观测变量则是已知的输出值。在隐马尔可夫模型中，变量之间的依赖关系遵循如下两个规则：</p><blockquote><p><strong>1. 观测变量的取值仅依赖于状态变量</strong>；<br><strong>2. 下一个状态的取值仅依赖于当前状态</strong>，通俗来讲：<strong>现在决定未来，未来与过去无关</strong>，这就是著名的<strong>马尔可夫性</strong>。</p></blockquote><p><img src="https://s1.ax1x.com/2018/10/18/iwYPmR.png" alt="iwYPmR.png"></p><p>基于上述变量之间的依赖关系，我们很容易写出隐马尔可夫模型中所有变量的联合概率分布：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwY9X9.png" alt="iwY9X9.png"></p><p>易知：<strong>欲确定一个HMM模型需要以下三组参数</strong>：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYi01.png" alt="iwYi01.png"></p><p>当确定了一个HMM模型的三个参数后，便按照下面的规则来生成观测值序列：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYFTx.png" alt="iwYFTx.png"></p><p>在实际应用中，HMM模型的发力点主要体现在下述三个问题上：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYEtK.png" alt="iwYEtK.png"></p><h3 id="15-1-1-HMM评估问题"><a href="#15-1-1-HMM评估问题" class="headerlink" title="15.1.1 HMM评估问题"></a><strong>15.1.1 HMM评估问题</strong></h3><p>HMM评估问题指的是：<strong>给定了模型的三个参数与观测值序列，求该观测值序列出现的概率</strong>。例如：对于赌场问题，便可以依据骰子掷出的结果序列来计算该结果序列出现的可能性，若小概率的事件发生了则可认为赌场的骰子有作弊的可能。解决该问题使用的是<strong>前向算法</strong>，即步步为营，自底向上的方式逐步增加序列的长度，直到获得目标概率值。在前向算法中，定义了一个<strong>前向变量</strong>，即给定观察值序列且t时刻的状态为Si的概率：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYVfO.png" alt="iwYVfO.png"></p><p>基于前向变量，很容易得到该问题的递推关系及终止条件：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYAk6.png" alt="iwYAk6.png"></p><p>因此可使用动态规划法，从最小的子问题开始，通过填表格的形式一步一步计算出目标结果。</p><h3 id="15-1-2-HMM解码问题"><a href="#15-1-2-HMM解码问题" class="headerlink" title="15.1.2 HMM解码问题"></a><strong>15.1.2 HMM解码问题</strong></h3><p>HMM解码问题指的是：<strong>给定了模型的三个参数与观测值序列，求可能性最大的状态序列</strong>。例如：在语音识别问题中，人说话形成的数字信号对应着观测值序列，对应的具体文字则是状态序列，从数字信号转化为文字正是对应着根据观测值序列推断最有可能的状态值序列。解决该问题使用的是<strong>Viterbi算法</strong>，与前向算法十分类似地，Viterbi算法定义了一个<strong>Viterbi变量</strong>，也是采用动态规划的方法，自底向上逐步求解。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYepD.png" alt="iwYepD.png"></p><h3 id="15-1-3-HMM学习问题"><a href="#15-1-3-HMM学习问题" class="headerlink" title="15.1.3 HMM学习问题"></a><strong>15.1.3 HMM学习问题</strong></h3><p>HMM学习问题指的是：<strong>给定观测值序列，如何调整模型的参数使得该序列出现的概率最大</strong>。这便转化成了机器学习问题，即从给定的观测值序列中学习出一个HMM模型，<strong>该问题正是EM算法的经典案例之一</strong>。其思想也十分简单：对于给定的观测值序列，如果我们能够按照该序列潜在的规律来调整模型的三个参数，则可以使得该序列出现的可能性最大。假设状态值序列也已知，则很容易计算出与该序列最契合的模型参数：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYm1e.png" alt="iwYm1e.png"></p><p>但一般状态值序列都是不可观测的，且<strong>即使给定观测值序列与模型参数，状态序列仍然遭遇组合爆炸</strong>。因此上面这种简单的统计方法就行不通了，若将状态值序列看作为隐变量，这时便可以考虑使用EM算法来对该问题进行求解：</p><p>【1】首先对HMM模型的三个参数进行随机初始化；<br>【2】根据模型的参数与观测值序列，计算t时刻状态为i且t+1时刻状态为j的概率以及t时刻状态为i的概率。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYn6H.png" alt="iwYn6H.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYdns.png" alt="iwYdns.png"></p><p>【3】接着便可以对模型的三个参数进行重新估计：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYY9S.png" alt="iwYY9S.png"></p><p>【4】重复步骤2-3，直至三个参数值收敛，便得到了最终的HMM模型。</p><h2 id="15-2-马尔可夫随机场（MRF）"><a href="#15-2-马尔可夫随机场（MRF）" class="headerlink" title="15.2 马尔可夫随机场（MRF）"></a><strong>15.2 马尔可夫随机场（MRF）</strong></h2><p>马尔可夫随机场（Markov Random Field）是一种典型的马尔可夫网，即使用无向边来表达变量间的依赖关系。在马尔可夫随机场中，对于关系图中的一个子集，<strong>若任意两结点间都有边连接，则称该子集为一个团；若再加一个结点便不能形成团，则称该子集为极大团</strong>。MRF使用<strong>势函数</strong>来定义多个变量的概率分布函数，其中<strong>每个（极大）团对应一个势函数</strong>，一般团中的变量关系也体现在它所对应的极大团中，因此常常基于极大团来定义变量的联合概率分布函数。具体而言，若所有变量构成的极大团的集合为C，则MRF的联合概率函数可以定义为：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYGh8.png" alt="iwYGh8.png"></p><p>对于条件独立性，<strong>马尔可夫随机场通过分离集来实现条件独立</strong>，若A结点集必须经过C结点集才能到达B结点集，则称C为分离集。书上给出了一个简单情形下的条件独立证明过程，十分贴切易懂，此处不再展开。基于分离集的概念，得到了MRF的三个性质：</p><blockquote><p><strong>全局马尔可夫性</strong>：给定两个变量子集的分离集，则这两个变量子集条件独立。<br><strong>局部马尔可夫性</strong>：给定某变量的邻接变量，则该变量与其它变量条件独立。<br><strong>成对马尔可夫性</strong>：给定所有其他变量，两个非邻接变量条件独立。</p></blockquote><p><img src="https://s1.ax1x.com/2018/10/18/iwY07q.png" alt="iwY07q.png"></p><p>对于MRF中的势函数，势函数主要用于描述团中变量之间的相关关系，且要求为非负函数，直观来看：势函数需要在偏好的变量取值上函数值较大，例如：若x1与x2成正相关，则需要将这种关系反映在势函数的函数值中。一般我们常使用指数函数来定义势函数：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwY8tf.png" alt="iwY8tf.png"></p><h2 id="15-3-条件随机场（CRF）"><a href="#15-3-条件随机场（CRF）" class="headerlink" title="15.3 条件随机场（CRF）"></a><strong>15.3 条件随机场（CRF）</strong></h2><p>前面所讲到的<strong>隐马尔可夫模型和马尔可夫随机场都属于生成式模型，即对联合概率进行建模，条件随机场则是对条件分布进行建模</strong>。CRF试图在给定观测值序列后，对状态序列的概率分布进行建模，即P(y | x)。直观上看：CRF与HMM的解码问题十分类似，都是在给定观测值序列后，研究状态序列可能的取值。CRF可以有多种结构，只需保证状态序列满足马尔可夫性即可，一般我们常使用的是<strong>链式条件随机场</strong>：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYt1g.png" alt="iwYt1g.png"></p><p>与马尔可夫随机场定义联合概率类似地，CRF也通过团以及势函数的概念来定义条件概率P(y | x)。在给定观测值序列的条件下，链式条件随机场主要包含两种团结构：单个状态团及相邻状态团，通过引入两类特征函数便可以定义出目标条件概率：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYNcQ.png" alt="iwYNcQ.png"></p><p>以词性标注为例，如何判断给出的一个标注序列靠谱不靠谱呢？<strong>转移特征函数主要判定两个相邻的标注是否合理</strong>，例如：动词+动词显然语法不通；<strong>状态特征函数则判定观测值与对应的标注是否合理</strong>，例如： ly结尾的词—&gt;副词较合理。因此我们可以定义一个特征函数集合，用这个特征函数集合来为一个标注序列打分，并据此选出最靠谱的标注序列。也就是说，每一个特征函数（对应一种规则）都可以用来为一个标注序列评分，把集合中所有特征函数对同一个标注序列的评分综合起来，就是这个标注序列最终的评分值。可以看出：<strong>特征函数是一些经验的特性</strong>。</p><h2 id="15-4-学习与推断"><a href="#15-4-学习与推断" class="headerlink" title="15.4 学习与推断"></a><strong>15.4 学习与推断</strong></h2><p>对于生成式模型，通常我们都是先对变量的联合概率分布进行建模，接着再求出目标变量的<strong>边际分布</strong>（marginal distribution），那如何从联合概率得到边际分布呢？这便是学习与推断。下面主要介绍两种精确推断的方法：<strong>变量消去</strong>与<strong>信念传播</strong>。</p><h3 id="15-4-1-变量消去"><a href="#15-4-1-变量消去" class="headerlink" title="15.4.1 变量消去"></a><strong>15.4.1 变量消去</strong></h3><p>变量消去利用条件独立性来消减计算目标概率值所需的计算量，它通过运用<strong>乘法与加法的分配率</strong>，将对变量的积的求和问题转化为对部分变量交替进行求积与求和的问题，从而将每次的<strong>运算控制在局部</strong>，达到简化运算的目的。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYUXj.png" alt="iwYUXj.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYwBn.png" alt="iwYwBn.png"></p><h3 id="15-4-2-信念传播"><a href="#15-4-2-信念传播" class="headerlink" title="15.4.2 信念传播"></a><strong>15.4.2 信念传播</strong></h3><p>若将变量求和操作看作是一种消息的传递过程，信念传播可以理解成：<strong>一个节点在接收到所有其它节点的消息后才向另一个节点发送消息</strong>，同时当前节点的边际概率正比于他所接收的消息的乘积：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYDA0.png" alt="iwYDA0.png"></p><p>因此只需要经过下面两个步骤，便可以完成所有的消息传递过程。利用动态规划法的思想记录传递过程中的所有消息，当计算某个结点的边际概率分布时，只需直接取出传到该结点的消息即可，从而避免了计算多个边际分布时的冗余计算问题。</p><blockquote><p>1.指定一个根节点，从所有的叶节点开始向根节点传递消息，直到根节点收到所有邻接结点的消息<strong>（从叶到根）</strong>；<br>2.从根节点开始向叶节点传递消息，直到所有叶节点均收到消息<strong>（从根到叶）</strong>。</p></blockquote><p><img src="https://s1.ax1x.com/2018/10/18/iwYgc4.png" alt="iwYgc4.png"></p><h2 id="15-5-LDA话题模型"><a href="#15-5-LDA话题模型" class="headerlink" title="15.5 LDA话题模型"></a><strong>15.5 LDA话题模型</strong></h2><p>话题模型主要用于处理文本类数据，其中<strong>隐狄利克雷分配模型</strong>（Latent Dirichlet Allocation，简称LDA）是话题模型的杰出代表。在话题模型中，有以下几个基本概念：词（word）、文档（document）、话题（topic）。</p><blockquote><p><strong>词</strong>：最基本的离散单元；<br><strong>文档</strong>：由一组词组成，词在文档中不计顺序；<br><strong>话题</strong>：由一组特定的词组成，这组词具有较强的相关关系。</p></blockquote><p>在现实任务中，一般我们可以得出一个文档的词频分布，但不知道该文档对应着哪些话题，LDA话题模型正是为了解决这个问题。具体来说：<strong>LDA认为每篇文档包含多个话题，且其中每一个词都对应着一个话题</strong>。因此可以假设文档是通过如下方式生成：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwY2jJ.png" alt="iwY2jJ.png"></p><p>这样一个文档中的所有词都可以认为是通过话题模型来生成的，当已知一个文档的词频分布后（即一个N维向量，N为词库大小），则可以认为：<strong>每一个词频元素都对应着一个话题，而话题对应的词频分布则影响着该词频元素的大小</strong>。因此很容易写出LDA模型对应的联合概率函数：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwYc3F.png" alt="iwYc3F.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwYWu9.png" alt="iwYWu9.png"></p><p>从上图可以看出，LDA的三个表示层被三种颜色表示出来：</p><blockquote><p><strong>corpus-level（红色）：</strong> α和β表示语料级别的参数，也就是每个文档都一样，因此生成过程只采样一次。<br><strong>document-level（橙色）：</strong> θ是文档级别的变量，每个文档对应一个θ。<br><strong>word-level（绿色）：</strong> z和w都是单词级别变量，z由θ生成，w由z和β共同生成，一个单词w对应一个主题z。</p></blockquote><p>通过上面对LDA生成模型的讨论，可以知道<strong>LDA模型主要是想从给定的输入语料中学习训练出两个控制参数α和β</strong>，当学习出了这两个控制参数就确定了模型，便可以用来生成文档。其中α和β分别对应以下各个信息：</p><blockquote><p><strong>α</strong>：分布p(θ)需要一个向量参数，即Dirichlet分布的参数，用于生成一个主题θ向量；<br><strong>β</strong>：各个主题对应的单词概率分布矩阵p(w|z)。</p></blockquote><p>把w当做观察变量，θ和z当做隐藏变量，就可以通过EM算法学习出α和β，求解过程中遇到后验概率p(θ,z|w)无法直接求解，需要找一个似然函数下界来近似求解，原作者使用基于分解（factorization）假设的变分法（varialtional inference）进行计算，用到了EM算法。每次E-step输入α和β，计算似然函数，M-step最大化这个似然函数，算出α和β，不断迭代直到收敛。</p><p>在此，概率图模型就介绍完毕。上周受到协同训练的启发，让实验的小伙伴做了一个HMM的slides，结果扩充了好多知识，所以完成这篇笔记还是花费了不少功夫，还刚好赶上实验室没空调回到解放前的日子，可谓汗流之作…</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇主要介绍了半监督学习，首先从如何利用未标记样本所蕴含的分布信息出发，引入了半监督学习的基本概念，即训练数据同时包含有标记样本和未标记样本的学习方法；接着分别介绍了几种常见的半监督学习方法：生成式方法基于对数据分布的假设，利用未标记样本隐含的分布信息，使得对模型参数的估计更加准确；TSVM给未标记样本赋予伪标记，并通过不断调整易出错样本的标记得到最终输出；基于分歧的方法结合了集成学习的思想，通过多个学习器在不同视图上的协作，有效利用了未标记样本数据 ；最后半监督聚类则是借助已有的监督信息来辅助聚类的过程，带约束k-均值算法需检测当前样本划分是否满足约束关系，带标记k-均值算法则利用有标记样本指定初始类中心。本篇将讨论一种基于图的学习算法—概率图模型。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(15)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-27T07:20:38.000Z</published>
    <updated>2020-07-27T11:03:27.448Z</updated>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了机器学习的理论基础，首先从独立同分布引入泛化误差与经验误差，接着介绍了PAC可学习的基本概念，即以较大的概率学习出与目标概念近似的假设（泛化误差满足预设上限），对于有限假设空间：（1）可分情形时，假设空间都是PAC可学习的，即当样本满足一定的数量之后，总是可以在与训练集一致的假设中找出目标概念的近似；（2）不可分情形时，假设空间都是不可知PAC可学习的，即以较大概率学习出与当前假设空间中泛化误差最小的假设的有效近似（Hoeffding不等式）。对于无限假设空间，通过增长函数与VC维来描述其复杂度，若学习算法满足经验风险最小化原则，则任何VC维有限的假设空间都是（不可知）PAC可学习的，同时也给出了泛化误差界与样本复杂度。稳定性则考察的是输入发生变化时输出的波动，稳定性通过损失函数与假设空间的可学习理论联系在了一起。本篇将讨论一种介于监督与非监督学习之间的学习算法—半监督学习。<br><a id="more"></a></p><p>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:25px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="14、半监督学习"><a href="#14、半监督学习" class="headerlink" title="14、半监督学习"></a><strong>14、半监督学习</strong></h1><p>前面我们一直围绕的都是监督学习与无监督学习，监督学习指的是训练样本包含标记信息的学习任务，例如：常见的分类与回归算法；无监督学习则是训练样本不包含标记信息的学习任务，例如：聚类算法。在实际生活中，常常会出现一部分样本有标记和较多样本无标记的情形，例如：做网页推荐时需要让用户标记出感兴趣的网页，但是少有用户愿意花时间来提供标记。若直接丢弃掉无标记样本集，使用传统的监督学习方法，常常会由于训练样本的不充足，使得其刻画总体分布的能力减弱，从而影响了学习器泛化性能。那如何利用未标记的样本数据呢？</p><p>一种简单的做法是通过专家知识对这些未标记的样本进行打标，但随之而来的就是巨大的人力耗费。若我们先使用有标记的样本数据集训练出一个学习器，再基于该学习器对未标记的样本进行预测，从中<strong>挑选出不确定性高或分类置信度低的样本来咨询专家并进行打标</strong>，最后使用扩充后的训练集重新训练学习器，这样便能大幅度降低标记成本，这便是<strong>主动学习</strong>（active learning），其目标是<strong>使用尽量少的/有价值的咨询来获得更好的性能</strong>。</p><p>显然，<strong>主动学习需要与外界进行交互/查询/打标，其本质上仍然属于一种监督学习</strong>。事实上，无标记样本虽未包含标记信息，但它们与有标记样本一样都是从总体中独立同分布采样得到，因此<strong>它们所包含的数据分布信息对学习器的训练大有裨益</strong>。如何让学习过程不依赖外界的咨询交互，自动利用未标记样本所包含的分布信息的方法便是<strong>半监督学习</strong>（semi-supervised learning），<strong>即训练集同时包含有标记样本数据和未标记样本数据</strong>。</p><p><img src="https://i.loli.net/2018/10/18/5bc856e39801d.png" alt="1.png"></p><p>此外，半监督学习还可以进一步划分为<strong>纯半监督学习</strong>和<strong>直推学习</strong>，两者的区别在于：前者假定训练数据集中的未标记数据并非待预测数据，而后者假定学习过程中的未标记数据就是待预测数据。主动学习、纯半监督学习以及直推学习三者的概念如下图所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwJFJS.png" alt="iwJFJS.png"></p><h2 id="14-1-生成式方法"><a href="#14-1-生成式方法" class="headerlink" title="14.1 生成式方法"></a><strong>14.1 生成式方法</strong></h2><p><strong>生成式方法</strong>（generative methods）是基于生成式模型的方法，即先对联合分布P（x,c）建模，从而进一步求解 P（c | x），<strong>此类方法假定样本数据服从一个潜在的分布，因此需要充分可靠的先验知识</strong>。例如：前面已经接触到的贝叶斯分类器与高斯混合聚类，都属于生成式模型。现假定总体是一个高斯混合分布，即由多个高斯分布组合形成，从而一个子高斯分布就代表一个类簇（类别）。高斯混合分布的概率密度函数如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc856e3b82dc.png" alt="3.png"></p><p>不失一般性，假设类簇与真实的类别按照顺序一一对应，即第i个类簇对应第i个高斯混合成分。与高斯混合聚类类似地，这里的主要任务也是估计出各个高斯混合成分的参数以及混合系数，不同的是：对于有标记样本，不再是可能属于每一个类簇，而是只能属于真实类标对应的特定类簇。</p><p><img src="https://i.loli.net/2018/10/18/5bc856e431d30.png" alt="4.png"></p><p>直观上来看，<strong>基于半监督的高斯混合模型有机地整合了贝叶斯分类器与高斯混合聚类的核心思想</strong>，有效地利用了未标记样本数据隐含的分布信息，从而使得参数的估计更加准确。同样地，这里也要召唤出之前的EM大法进行求解，首先对各个高斯混合成分的参数及混合系数进行随机初始化，计算出各个PM（即γji，第i个样本属于j类，有标记样本则直接属于特定类），再最大化似然函数（即LL（D）分别对α、u和∑求偏导 ），对参数进行迭代更新。</p><p><img src="https://i.loli.net/2018/10/18/5bc856e43ff08.png" alt="5.png"></p><p>当参数迭代更新收敛后，对于待预测样本x，便可以像贝叶斯分类器那样计算出样本属于每个类簇的后验概率，接着找出概率最大的即可：</p><p><img src="https://i.loli.net/2018/10/18/5bc856e3dfb1c.png" alt="6.png"></p><p>可以看出：基于生成式模型的方法十分依赖于对潜在数据分布的假设，即假设的分布要能和真实分布相吻合，否则利用未标记的样本数据反倒会在错误的道路上渐行渐远，从而降低学习器的泛化性能。因此，<strong>此类方法要求极强的领域知识和掐指观天的本领</strong>。</p><h2 id="14-2-半监督SVM"><a href="#14-2-半监督SVM" class="headerlink" title="14.2 半监督SVM"></a><strong>14.2 半监督SVM</strong></h2><p>监督学习中的SVM试图找到一个划分超平面，使得两侧支持向量之间的间隔最大，即“<strong>最大划分间隔</strong>”思想。对于半监督学习，S3VM则考虑超平面需穿过数据低密度的区域。TSVM是半监督支持向量机中的最著名代表，其核心思想是：尝试为未标记样本找到合适的标记指派，使得超平面划分后的间隔最大化。TSVM采用局部搜索的策略来进行迭代求解，即首先使用有标记样本集训练出一个初始SVM，接着使用该学习器对未标记样本进行打标，这样所有样本都有了标记，并基于这些有标记的样本重新训练SVM，之后再寻找易出错样本不断调整。整个算法流程如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc856e427830.png" alt="7.png"></p><p><img src="https://s1.ax1x.com/2018/10/18/iwJZss.png" alt="iwJZss.png"></p><h2 id="14-3-基于分歧的方法"><a href="#14-3-基于分歧的方法" class="headerlink" title="14.3 基于分歧的方法"></a><strong>14.3 基于分歧的方法</strong></h2><p>基于分歧的方法通过多个学习器之间的<strong>分歧（disagreement）/多样性（diversity）</strong>来利用未标记样本数据，协同训练就是其中的一种经典方法。<strong>协同训练最初是针对于多视图（multi-view）数据而设计的，多视图数据指的是样本对象具有多个属性集，每个属性集则对应一个试图</strong>。例如：电影数据中就包含画面类属性和声音类属性，这样画面类属性的集合就对应着一个视图。首先引入两个关于视图的重要性质：</p><blockquote><p><strong>相容性</strong>：即使用单个视图数据训练出的学习器的输出空间是一致的。例如都是{好，坏}、{+1,-1}等。<br><strong>互补性</strong>：即不同视图所提供的信息是互补/相辅相成的，实质上这里体现的就是集成学习的思想。</p></blockquote><p>协同训练正是很好地利用了多视图数据的“<strong>相容互补性</strong>”，其基本的思想是：首先基于有标记样本数据在每个视图上都训练一个初始分类器，然后让每个分类器去挑选分类置信度最高的样本并赋予标记，并将带有伪标记的样本数据传给另一个分类器去学习，从而<strong>你依我侬/共同进步</strong>。</p><p><img src="https://s1.ax1x.com/2018/10/18/iwJVMj.png" alt="iwJVMj.png"><br><img src="https://s1.ax1x.com/2018/10/18/iwJeLn.png" alt="iwJeLn.png"></p><h2 id="14-4-半监督聚类"><a href="#14-4-半监督聚类" class="headerlink" title="14.4 半监督聚类"></a><strong>14.4 半监督聚类</strong></h2><p>前面提到的几种方法都是借助无标记样本数据来辅助监督学习的训练过程，从而使得学习更加充分/泛化性能得到提升；半监督聚类则是借助已有的监督信息来辅助聚类的过程。一般而言，监督信息大致有两种类型：</p><blockquote><p><strong>必连与勿连约束</strong>：必连指的是两个样本必须在同一个类簇，勿连则是必不在同一个类簇。<br><strong>标记信息</strong>：少量的样本带有真实的标记。</p></blockquote><p>下面主要介绍两种基于半监督的K-Means聚类算法：第一种是数据集包含一些必连与勿连关系，另外一种则是包含少量带有标记的样本。两种算法的基本思想都十分的简单：对于带有约束关系的k-均值算法，在迭代过程中对每个样本划分类簇时，需要<strong>检测当前划分是否满足约束关系</strong>，若不满足则会将该样本划分到距离次小对应的类簇中，再继续检测是否满足约束关系，直到完成所有样本的划分。算法流程如下图所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwJAzQ.png" alt="iwJAzQ.png"></p><p>对于带有少量标记样本的k-均值算法，则可以<strong>利用这些有标记样本进行类中心的指定，同时在对样本进行划分时，不需要改变这些有标记样本的簇隶属关系</strong>，直接将其划分到对应类簇即可。算法流程如下所示：</p><p><img src="https://s1.ax1x.com/2018/10/18/iwJkRg.png" alt="iwJkRg.png"></p><p>在此，半监督学习就介绍完毕。十分有趣的是：半监督学习将前面许多知识模块联系在了一起，足以体现了作者编排的用心。结合本篇的新知识再来回想之前自己做过的一些研究，发现还是蹚了一些浑水，也许越是觉得过去的自己傻，越就是好的兆头吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇主要介绍了机器学习的理论基础，首先从独立同分布引入泛化误差与经验误差，接着介绍了PAC可学习的基本概念，即以较大的概率学习出与目标概念近似的假设（泛化误差满足预设上限），对于有限假设空间：（1）可分情形时，假设空间都是PAC可学习的，即当样本满足一定的数量之后，总是可以在与训练集一致的假设中找出目标概念的近似；（2）不可分情形时，假设空间都是不可知PAC可学习的，即以较大概率学习出与当前假设空间中泛化误差最小的假设的有效近似（Hoeffding不等式）。对于无限假设空间，通过增长函数与VC维来描述其复杂度，若学习算法满足经验风险最小化原则，则任何VC维有限的假设空间都是（不可知）PAC可学习的，同时也给出了泛化误差界与样本复杂度。稳定性则考察的是输入发生变化时输出的波动，稳定性通过损失函数与假设空间的可学习理论联系在了一起。本篇将讨论一种介于监督与非监督学习之间的学习算法—半监督学习。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(14)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/</id>
    <published>2020-07-27T06:20:38.000Z</published>
    <updated>2020-07-27T11:03:20.664Z</updated>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了常用的特征选择方法及稀疏学习。首先从相关/无关特征出发引出了特征选择的基本概念，接着分别介绍了子集搜索与评价、过滤式、包裹式以及嵌入式四种类型的特征选择方法。子集搜索与评价使用的是一种优中生优的贪婪算法，即每次从候选特征子集中选出最优子集；过滤式方法计算一个相关统计量来评判特征的重要程度；包裹式方法将学习器作为特征选择的评价准则；嵌入式方法则是通过L1正则项将特征选择融入到学习器参数优化的过程中。最后介绍了稀疏表示与压缩感知的核心思想：稀疏表示利用稀疏矩阵的优良性质，试图通过某种方法找到原始稠密矩阵的合适稀疏表示；压缩感知则试图利用可稀疏表示的欠采样信息来恢复全部信息。本篇将讨论一种为机器学习提供理论保证的学习方法—计算学习理论。<br><a id="more"></a></p><p>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:25px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="13、计算学习理论"><a href="#13、计算学习理论" class="headerlink" title="13、计算学习理论"></a><strong>13、计算学习理论</strong></h1><p>计算学习理论（computational learning theory）是通过“计算”来研究机器学习的理论，简而言之，其目的是分析学习任务的本质，例如：<strong>在什么条件下可进行有效的学习，需要多少训练样本能获得较好的精度等，从而为机器学习算法提供理论保证</strong>。</p><p>首先我们回归初心，再来谈谈经验误差和泛化误差。假设给定训练集D，其中所有的训练样本都服从一个未知的分布T，且它们都是在总体分布T中独立采样得到，即<strong>独立同分布</strong>（independent and identically distributed，i.i.d.），在《贝叶斯分类器》中我们已经提到：独立同分布是很多统计学习算法的基础假设，例如最大似然法，贝叶斯分类器，高斯混合聚类等，简单来理解独立同分布：每个样本都是从总体分布中独立采样得到，而没有拖泥带水。例如现在要进行问卷调查，要从总体人群中随机采样，看到一个美女你高兴地走过去，结果她男票突然冒了出来，说道：you jump，i jump，于是你本来只想调查一个人结果被强行撒了一把狗粮得到两份问卷，这样这两份问卷就不能称为独立同分布了，因为它们的出现具有强相关性。</p><p>回归正题，<strong>泛化误差指的是学习器在总体上的预测误差，经验误差则是学习器在某个特定数据集D上的预测误差</strong>。在实际问题中，往往我们并不能得到总体且数据集D是通过独立同分布采样得到的，因此我们常常使用经验误差作为泛化误差的近似。</p><p><img src="https://i.loli.net/2018/10/18/5bc854f38d4fe.png" alt="1.png"></p><h2 id="13-1-PAC学习"><a href="#13-1-PAC学习" class="headerlink" title="13.1 PAC学习"></a><strong>13.1 PAC学习</strong></h2><p>在高中课本中，我们将<strong>函数定义为：从自变量到因变量的一种映射；对于机器学习算法，学习器也正是为了寻找合适的映射规则</strong>，即如何从条件属性得到目标属性。从样本空间到标记空间存在着很多的映射，我们将每个映射称之为<strong>概念</strong>（concept），定义：</p><blockquote><p>若概念c对任何样本x满足c(x)=y，则称c为<strong>目标概念</strong>，即最理想的映射，所有的目标概念构成的集合称为<strong>“概念类”</strong>；<br>给定学习算法，它所有可能映射/概念的集合称为<strong>“假设空间”</strong>，其中单个的概念称为<strong>“假设”</strong>（hypothesis）；<br>若一个算法的假设空间包含目标概念，则称该数据集对该算法是<strong>可分</strong>（separable）的，亦称<strong>一致</strong>（consistent）的；<br>若一个算法的假设空间不包含目标概念，则称该数据集对该算法是<strong>不可分</strong>（non-separable）的，或称<strong>不一致</strong>（non-consistent）的。</p></blockquote><p>举个简单的例子：对于非线性分布的数据集，若使用一个线性分类器，则该线性分类器对应的假设空间就是空间中所有可能的超平面，显然假设空间不包含该数据集的目标概念，所以称数据集对该学习器是不可分的。给定一个数据集D，我们希望模型学得的假设h尽可能地与目标概念一致，这便是<strong>概率近似正确</strong> (Probably Approximately Correct，简称PAC)的来源，即以较大的概率学得模型满足误差的预设上限。</p><p><img src="https://i.loli.net/2018/10/18/5bc854f446f97.png" alt="2.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc854f482d0b.png" alt="3.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc854f47d006.png" alt="4.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc854f46ad91.png" alt="5.png"></p><p>上述关于PAC的几个定义层层相扣：定义12.1表达的是对于某种学习算法，如果能以一个置信度学得假设满足泛化误差的预设上限，则称该算法能PAC辨识概念类，即该算法的输出假设已经十分地逼近目标概念。定义12.2则将样本数量考虑进来，当样本超过一定数量时，学习算法总是能PAC辨识概念类，则称概念类为PAC可学习的。定义12.3将学习器运行时间也考虑进来，若运行时间为多项式时间，则称PAC学习算法。</p><p>显然，PAC学习中的一个关键因素就是<strong>假设空间的复杂度</strong>，对于某个学习算法，<strong>若假设空间越大，则其中包含目标概念的可能性也越大，但同时找到某个具体概念的难度也越大</strong>，一般假设空间分为有限假设空间与无限假设空间。</p><h2 id="13-2-有限假设空间"><a href="#13-2-有限假设空间" class="headerlink" title="13.2 有限假设空间"></a><strong>13.2 有限假设空间</strong></h2><h3 id="13-2-1-可分情形"><a href="#13-2-1-可分情形" class="headerlink" title="13.2.1 可分情形"></a><strong>13.2.1 可分情形</strong></h3><p>可分或一致的情形指的是：<strong>目标概念包含在算法的假设空间中</strong>。对于目标概念，在训练集D中的经验误差一定为0，因此首先我们可以想到的是：不断地剔除那些出现预测错误的假设，直到找到经验误差为0的假设即为目标概念。但<strong>由于样本集有限，可能会出现多个假设在D上的经验误差都为0，因此问题转化为：需要多大规模的数据集D才能让学习算法以置信度的概率从这些经验误差都为0的假设中找到目标概念的有效近似</strong>。</p><p><img src="https://i.loli.net/2018/10/18/5bc854f484f30.png" alt="6.png"></p><p>通过上式可以得知：<strong>对于可分情形的有限假设空间，目标概念都是PAC可学习的，即当样本数量满足上述条件之后，在与训练集一致的假设中总是可以在1-σ概率下找到目标概念的有效近似。</strong></p><h3 id="13-2-2-不可分情形"><a href="#13-2-2-不可分情形" class="headerlink" title="13.2.2 不可分情形"></a><strong>13.2.2 不可分情形</strong></h3><p>不可分或不一致的情形指的是：<strong>目标概念不存在于假设空间中</strong>，这时我们就不能像可分情形时那样从假设空间中寻找目标概念的近似。但<strong>当假设空间给定时，必然存一个假设的泛化误差最小，若能找出此假设的有效近似也不失为一个好的目标，这便是不可知学习(agnostic learning)的来源。</strong></p><p><img src="https://i.loli.net/2018/10/18/5bc854f485f2e.png" alt="7.png"></p><p>这时候便要用到<strong>Hoeffding不等式</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc854f46970a.png" alt="8.png"></p><p>对于假设空间中的所有假设，出现泛化误差与经验误差之差大于e的概率和为：</p><p><img src="https://i.loli.net/2018/10/18/5bc854f4114fd.png" alt="9.png"></p><p>因此，可令不等式的右边小于（等于）σ，便可以求出满足泛化误差与经验误差相差小于e所需的最少样本数，同时也可以求出泛化误差界。</p><p><img src="https://i.loli.net/2018/10/18/5bc854f440a02.png" alt="10.png"></p><h2 id="13-3-VC维"><a href="#13-3-VC维" class="headerlink" title="13.3 VC维"></a><strong>13.3 VC维</strong></h2><p>现实中的学习任务通常都是无限假设空间，例如d维实数域空间中所有的超平面等，因此要对此种情形进行可学习研究，需要度量<strong>假设空间的复杂度</strong>。这便是<strong>VC维</strong>（Vapnik-Chervonenkis dimension）的来源。在介绍VC维之前，需要引入两个概念：</p><blockquote><p><strong>增长函数</strong>：对于给定数据集D，假设空间中的每个假设都能对数据集的样本赋予标记，因此一个假设对应着一种打标结果，不同假设对D的打标结果可能是相同的，也可能是不同的。随着样本数量m的增大，假设空间对样本集D的打标结果也会增多，增长函数则表示假设空间对m个样本的数据集D打标的最大可能结果数，因此<strong>增长函数描述了假设空间的表示能力与复杂度。</strong></p><p><img src="https://i.loli.net/2018/10/18/5bc855ba970cd.png" alt="11.png"></p><p><strong>打散</strong>：例如对二分类问题来说，m个样本最多有2^m个可能结果，每种可能结果称为一种<strong>“对分”</strong>，若假设空间能实现数据集D的所有对分，则称数据集能被该假设空间打散。</p></blockquote><p><strong>因此尽管假设空间是无限的，但它对特定数据集打标的不同结果数是有限的，假设空间的VC维正是它能打散的最大数据集大小</strong>。通常这样来计算假设空间的VC维：若存在大小为d的数据集能被假设空间打散，但不存在任何大小为d+1的数据集能被假设空间打散，则其VC维为d。</p><p><img src="https://i.loli.net/2018/10/18/5bc855bb20c1e.png" alt="12.png"></p><p>同时书中给出了假设空间VC维与增长函数的两个关系：</p><p><img src="https://i.loli.net/2018/10/18/5bc855ba83eb8.png" alt="13.png"></p><p>直观来理解（1）式也十分容易： 首先假设空间的VC维是d，说明当m&lt;=d时，增长函数与2^m相等，例如：当m=d时，右边的组合数求和刚好等于2^d；而当m=d+1时，右边等于2^(d+1)-1，十分符合VC维的定义，同时也可以使用数学归纳法证明；（2）式则是由（1）式直接推导得出。</p><p>在有限假设空间中，根据Hoeffding不等式便可以推导得出学习算法的泛化误差界；但在无限假设空间中，由于假设空间的大小无法计算，只能通过增长函数来描述其复杂度，因此无限假设空间中的泛化误差界需要引入增长函数。</p><p><img src="https://i.loli.net/2018/10/18/5bc855babc890.png" alt="14.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc855ba5b2c3.png" alt="15.png"></p><p>上式给出了基于VC维的泛化误差界，同时也可以计算出满足条件需要的样本数（样本复杂度）。若学习算法满足<strong>经验风险最小化原则（ERM）</strong>，即学习算法的输出假设h在数据集D上的经验误差最小，可证明：<strong>任何VC维有限的假设空间都是（不可知）PAC可学习的，换而言之：若假设空间的最小泛化误差为0即目标概念包含在假设空间中，则是PAC可学习，若最小泛化误差不为0，则称为不可知PAC可学习。</strong></p><h2 id="13-4-稳定性"><a href="#13-4-稳定性" class="headerlink" title="13.4 稳定性"></a><strong>13.4 稳定性</strong></h2><p>稳定性考察的是当算法的输入发生变化时，输出是否会随之发生较大的变化，输入的数据集D有以下两种变化：</p><p><img src="https://i.loli.net/2018/10/18/5bc855badc5a8.png" alt="16.png"></p><p>若对数据集中的任何样本z，满足：</p><p><img src="https://i.loli.net/2018/10/18/5bc855ba59b06.png" alt="17.png"></p><p>即原学习器和剔除一个样本后生成的学习器对z的损失之差保持β稳定，称学习器关于损失函数满足<strong>β-均匀稳定性</strong>。同时若损失函数有上界，即原学习器对任何样本的损失函数不超过M，则有如下定理：</p><p><img src="https://i.loli.net/2018/10/18/5bc855babe7c3.png" alt="18.png"></p><p>事实上，<strong>若学习算法符合经验风险最小化原则（ERM）且满足β-均匀稳定性，则假设空间是可学习的</strong>。稳定性通过损失函数与假设空间的可学习联系在了一起，区别在于：假设空间关注的是经验误差与泛化误差，需要考虑到所有可能的假设；而稳定性只关注当前的输出假设。</p><p>在此，计算学习理论就介绍完毕，一看这个名字就知道这一章比较偏底层理论了，最终还是咬着牙看完了它，这里引用一段小文字来梳理一下现在的心情：“孤岂欲卿治经为博士邪？但当涉猎，见往事耳”，就当扩充知识体系吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇主要介绍了常用的特征选择方法及稀疏学习。首先从相关/无关特征出发引出了特征选择的基本概念，接着分别介绍了子集搜索与评价、过滤式、包裹式以及嵌入式四种类型的特征选择方法。子集搜索与评价使用的是一种优中生优的贪婪算法，即每次从候选特征子集中选出最优子集；过滤式方法计算一个相关统计量来评判特征的重要程度；包裹式方法将学习器作为特征选择的评价准则；嵌入式方法则是通过L1正则项将特征选择融入到学习器参数优化的过程中。最后介绍了稀疏表示与压缩感知的核心思想：稀疏表示利用稀疏矩阵的优良性质，试图通过某种方法找到原始稠密矩阵的合适稀疏表示；压缩感知则试图利用可稀疏表示的欠采样信息来恢复全部信息。本篇将讨论一种为机器学习提供理论保证的学习方法—计算学习理论。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(13)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-27T05:20:38.000Z</published>
    <updated>2020-07-27T11:03:15.146Z</updated>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了经典的降维方法与度量学习，首先从“维数灾难”导致的样本稀疏以及距离难计算两大难题出发，引出了降维的概念，即通过某种数学变换将原始高维空间转变到一个低维的子空间，接着分别介绍了kNN、MDS、PCA、KPCA以及两种经典的流形学习方法，k近邻算法的核心在于k值的选取以及距离的度量，MDS要求原始空间样本之间的距离在降维后的低维空间中得以保持，主成分分析试图找到一个低维超平面来表出原空间样本点，核化主成分分析先将样本点映射到高维空间，再在高维空间中使用线性降维的方法，从而解决了原空间样本非线性分布的情形，基于流形学习的降维则是一种“邻域保持”的思想，最后度量学习试图去学习出一个距离度量来等效降维的效果。本篇将讨论另一种常用方法—特征选择与稀疏学习。<br><a id="more"></a></p><p>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:25px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="12、特征选择与稀疏学习"><a href="#12、特征选择与稀疏学习" class="headerlink" title="12、特征选择与稀疏学习"></a><strong>12、特征选择与稀疏学习</strong></h1><p>最近在看论文的过程中，发现对于数据集行和列的叫法颇有不同，故在介绍本篇之前，决定先将最常用的术语罗列一二，以后再见到了不管它脚扑朔还是眼迷离就能一眼识破真身了~对于数据集中的一个对象及组成对象的零件元素：</p><blockquote><p>统计学家常称它们为<strong>观测</strong>（<strong>observation</strong>）和<strong>变量</strong>（<strong>variable</strong>）；<br>数据库分析师则称其为<strong>记录</strong>（<strong>record</strong>）和<strong>字段</strong>（<strong>field</strong>）；<br>数据挖掘/机器学习学科的研究者则习惯把它们叫做<strong>样本</strong>/<strong>示例</strong>（<strong>example</strong>/<strong>instance</strong>）和<strong>属性</strong>/<strong>特征</strong>（<strong>attribute</strong>/<strong>feature</strong>）。</p></blockquote><p>回归正题，在机器学习中特征选择是一个重要的“<strong>数据预处理</strong>”（<strong>data</strong> <strong>preprocessing</strong>）过程，即试图从数据集的所有特征中挑选出与当前学习任务相关的特征子集，接着再利用数据子集来训练学习器；稀疏学习则是围绕着稀疏矩阵的优良性质，来完成相应的学习任务。</p><h2 id="12-1-子集搜索与评价"><a href="#12-1-子集搜索与评价" class="headerlink" title="12.1 子集搜索与评价"></a><strong>12.1 子集搜索与评价</strong></h2><p>一般地，我们可以用很多属性/特征来描述一个示例，例如对于一个人可以用性别、身高、体重、年龄、学历、专业、是否吃货等属性来描述，那现在想要训练出一个学习器来预测人的收入。根据生活经验易知：并不是所有的特征都与学习任务相关，例如年龄/学历/专业可能很大程度上影响了收入，身高/体重这些外貌属性也有较小的可能性影响收入，但像是否是一个地地道道的吃货这种属性就八杆子打不着了。因此我们只需要那些与学习任务紧密相关的特征，<strong>特征选择便是从给定的特征集合中选出相关特征子集的过程</strong>。</p><p>与上篇中降维技术有着异曲同工之处的是，特征选择也可以有效地解决维数灾难的难题。具体而言：<strong>降维从一定程度起到了提炼优质低维属性和降噪的效果，特征选择则是直接剔除那些与学习任务无关的属性而选择出最佳特征子集</strong>。若直接遍历所有特征子集，显然当维数过多时遭遇指数爆炸就行不通了；若采取从候选特征子集中不断迭代生成更优候选子集的方法，则时间复杂度大大减小。这时就涉及到了两个关键环节：<strong>1.如何生成候选子集；2.如何评价候选子集的好坏</strong>，这便是早期特征选择的常用方法。书本上介绍了贪心算法，分为三种策略：</p><blockquote><p><strong>前向搜索</strong>：初始将每个特征当做一个候选特征子集，然后从当前所有的候选子集中选择出最佳的特征子集；接着在上一轮选出的特征子集中添加一个新的特征，同样地选出最佳特征子集；最后直至选不出比上一轮更好的特征子集。<br><strong>后向搜索</strong>：初始将所有特征作为一个候选特征子集；接着尝试去掉上一轮特征子集中的一个特征并选出当前最优的特征子集；最后直到选不出比上一轮更好的特征子集。<br><strong>双向搜索</strong>：将前向搜索与后向搜索结合起来，即在每一轮中既有添加操作也有剔除操作。</p></blockquote><p>对于特征子集的评价，书中给出了一些想法及基于信息熵的方法。假设数据集的属性皆为离散属性，这样给定一个特征子集，便可以通过这个特征子集的取值将数据集合划分为V个子集。例如：A1={男,女}，A2={本科,硕士}就可以将原数据集划分为2*2=4个子集，其中每个子集的取值完全相同。这时我们就可以像决策树选择划分属性那样，通过计算信息增益来评价该属性子集的好坏。</p><p><img src="https://i.loli.net/2018/10/18/5bc853eca1a43.png" alt="1.png"></p><p>此时，信息增益越大表示该属性子集包含有助于分类的特征越多，使用上述这种<strong>子集搜索与子集评价相结合的机制，便可以得到特征选择方法</strong>。值得一提的是若将前向搜索策略与信息增益结合在一起，与前面我们讲到的ID3决策树十分地相似。事实上，决策树也可以用于特征选择，树节点划分属性组成的集合便是选择出的特征子集。</p><h2 id="12-2-过滤式选择（Relief）"><a href="#12-2-过滤式选择（Relief）" class="headerlink" title="12.2 过滤式选择（Relief）"></a><strong>12.2 过滤式选择（Relief）</strong></h2><p>过滤式方法是一种将特征选择与学习器训练相分离的特征选择技术，即首先将相关特征挑选出来，再使用选择出的数据子集来训练学习器。Relief是其中著名的代表性算法，它使用一个“<strong>相关统计量</strong>”来度量特征的重要性，该统计量是一个向量，其中每个分量代表着相应特征的重要性，因此我们最终可以根据这个统计量各个分量的大小来选择出合适的特征子集。</p><p>易知Relief算法的核心在于如何计算出该相关统计量。对于数据集中的每个样例xi，Relief首先找出与xi同类别的最近邻与不同类别的最近邻，分别称为<strong>猜中近邻（near-hit）</strong>与<strong>猜错近邻（near-miss）</strong>，接着便可以分别计算出相关统计量中的每个分量。对于j分量：</p><p><img src="https://i.loli.net/2018/10/18/5bc853ec70c88.png" alt="2.png"></p><p>直观上理解：对于猜中近邻，两者j属性的距离越小越好，对于猜错近邻，j属性距离越大越好。更一般地，若xi为离散属性，diff取海明距离，即相同取0，不同取1；若xi为连续属性，则diff为曼哈顿距离，即取差的绝对值。分别计算每个分量，最终取平均便得到了整个相关统计量。</p><p>标准的Relief算法只用于二分类问题，后续产生的拓展变体Relief-F则解决了多分类问题。对于j分量，新的计算公式如下：</p><p><img src="https://i.loli.net/2018/10/18/5bc853ec93042.png" alt="3.png"></p><p>其中pl表示第l类样本在数据集中所占的比例，易知两者的不同之处在于：<strong>标准Relief 只有一个猜错近邻，而Relief-F有多个猜错近邻</strong>。</p><h2 id="12-3-包裹式选择（LVW）"><a href="#12-3-包裹式选择（LVW）" class="headerlink" title="12.3 包裹式选择（LVW）"></a><strong>12.3 包裹式选择（LVW）</strong></h2><p>与过滤式选择不同的是，包裹式选择将后续的学习器也考虑进来作为特征选择的评价准则。因此包裹式选择可以看作是为某种学习器<strong>量身定做</strong>的特征选择方法，由于在每一轮迭代中，包裹式选择都需要训练学习器，因此在获得较好性能的同时也产生了较大的开销。下面主要介绍一种经典的包裹式特征选择方法 —LVW（Las Vegas Wrapper），它在拉斯维加斯框架下使用随机策略来进行特征子集的搜索。拉斯维加斯？怎么听起来那么耳熟，不是那个声名显赫的赌场吗？歪果仁真会玩。怀着好奇科普一下，结果又顺带了一个赌场：</p><blockquote><p><strong>蒙特卡罗算法</strong>：采样越多，越近似最优解，一定会给出解，但给出的解不一定是正确解；<br><strong>拉斯维加斯算法</strong>：采样越多，越有机会找到最优解，不一定会给出解，且给出的解一定是正确解。</p></blockquote><p>举个例子，假如筐里有100个苹果，让我每次闭眼拿1个，挑出最大的。于是我随机拿1个，再随机拿1个跟它比，留下大的，再随机拿1个……我每拿一次，留下的苹果都至少不比上次的小。拿的次数越多，挑出的苹果就越大，但我除非拿100次，否则无法肯定挑出了最大的。这个挑苹果的算法，就属于蒙特卡罗算法——尽量找较好的，但不保证是最好的。</p><p>而拉斯维加斯算法，则是另一种情况。假如有一把锁，给我100把钥匙，只有1把是对的。于是我每次随机拿1把钥匙去试，打不开就再换1把。我试的次数越多，打开（正确解）的机会就越大，但在打开之前，那些错的钥匙都是没有用的。这个试钥匙的算法，就是拉斯维加斯的——尽量找最好的，但不保证能找到。</p><p>LVW算法的具体流程如下所示，其中比较特别的是停止条件参数T的设置，即在每一轮寻找最优特征子集的过程中，若随机T次仍没找到，算法就会停止，从而保证了算法运行时间的可行性。</p><p><img src="https://i.loli.net/2018/10/18/5bc853ed5e08e.png" alt="4.png"></p><h2 id="12-4-嵌入式选择与正则化"><a href="#12-4-嵌入式选择与正则化" class="headerlink" title="12.4 嵌入式选择与正则化"></a><strong>12.4 嵌入式选择与正则化</strong></h2><p>前面提到了的两种特征选择方法：<strong>过滤式中特征选择与后续学习器完全分离，包裹式则是使用学习器作为特征选择的评价准则；嵌入式是一种将特征选择与学习器训练完全融合的特征选择方法，即将特征选择融入学习器的优化过程中</strong>。在之前《经验风险与结构风险》中已经提到：经验风险指的是模型与训练数据的契合度，结构风险则是模型的复杂程度，机器学习的核心任务就是：<strong>在模型简单的基础上保证模型的契合度</strong>。例如：岭回归就是加上了L2范数的最小二乘法，有效地解决了奇异矩阵、过拟合等诸多问题，下面的嵌入式特征选择则是在损失函数后加上了L1范数。</p><p><img src="https://i.loli.net/2018/10/18/5bc853ec8b203.png" alt="5.png"></p><p>L1范数美名又约<strong>Lasso Regularization</strong>，指的是向量中每个元素的绝对值之和，这样在优化目标函数的过程中，就会使得w尽可能地小，在一定程度上起到了防止过拟合的作用，同时与L2范数（Ridge Regularization ）不同的是，L1范数会使得部分w变为0， 从而达到了特征选择的效果。</p><p>总的来说：<strong>L1范数会趋向产生少量的特征，其他特征的权值都是0；L2会选择更多的特征，这些特征的权值都会接近于0</strong>。这样L1范数在特征选择上就十分有用，而L2范数则具备较强的控制过拟合能力。可以从下面两个方面来理解：</p><p>（1）<strong>下降速度</strong>：L1范数按照绝对值函数来下降，L2范数按照二次函数来下降。因此在0附近，L1范数的下降速度大于L2范数，故L1范数能很快地下降到0，而L2范数在0附近的下降速度非常慢，因此较大可能收敛在0的附近。</p><p><img src="https://i.loli.net/2018/10/18/5bc853ed0aaf5.png" alt="6.png"></p><p>（2）<strong>空间限制</strong>：L1范数与L2范数都试图在最小化损失函数的同时，让权值W也尽可能地小。我们可以将原优化问题看做为下面的问题，即让后面的规则则都小于某个阈值。这样从图中可以看出：L1范数相比L2范数更容易得到稀疏解。</p><p><img src="https://i.loli.net/2018/10/18/5bc853ecc223e.png" alt="7.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc853ed51aa1.png" alt="8.png"></p><h2 id="12-5-稀疏表示与字典学习"><a href="#12-5-稀疏表示与字典学习" class="headerlink" title="12.5 稀疏表示与字典学习"></a><strong>12.5 稀疏表示与字典学习</strong></h2><p>当样本数据是一个稀疏矩阵时，对学习任务来说会有不少的好处，例如很多问题变得线性可分，储存更为高效等。这便是稀疏表示与字典学习的基本出发点。稀疏矩阵即矩阵的每一行/列中都包含了大量的零元素，且这些零元素没有出现在同一行/列，对于一个给定的稠密矩阵，若我们能<strong>通过某种方法找到其合适的稀疏表示</strong>，则可以使得学习任务更加简单高效，我们称之为<strong>稀疏编码（sparse coding）</strong>或<strong>字典学习（dictionary learning）</strong>。</p><p>给定一个数据集，字典学习/稀疏编码指的便是通过一个字典将原数据转化为稀疏表示，因此最终的目标就是求得字典矩阵B及稀疏表示α，书中使用变量交替优化的策略能较好地求得解，深感陷进去短时间无法自拔，故先不进行深入…</p><p><img src="https://i.loli.net/2018/10/18/5bc853ed0ca43.png" alt="9.png"></p><h2 id="12-6-压缩感知"><a href="#12-6-压缩感知" class="headerlink" title="12.6 压缩感知"></a><strong>12.6 压缩感知</strong></h2><p>压缩感知在前些年也是风风火火，与特征选择、稀疏表示不同的是：它关注的是通过欠采样信息来恢复全部信息。在实际问题中，为了方便传输和存储，我们一般将数字信息进行压缩，这样就有可能损失部分信息，如何根据已有的信息来重构出全部信号，这便是压缩感知的来历，压缩感知的前提是已知的信息具有稀疏表示。下面是关于压缩感知的一些背景：</p><p><img src="https://i.loli.net/2018/10/18/5bc853ed431c6.png" alt="10.png"></p><p>在此，特征选择与稀疏学习就介绍完毕。在很多实际情形中，选了好的特征比选了好的模型更为重要，这也是为什么厉害的大牛能够很快地得出一些结论的原因，谓：吾昨晚夜观天象，星象云是否吃货乃无用也~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇主要介绍了经典的降维方法与度量学习，首先从“维数灾难”导致的样本稀疏以及距离难计算两大难题出发，引出了降维的概念，即通过某种数学变换将原始高维空间转变到一个低维的子空间，接着分别介绍了kNN、MDS、PCA、KPCA以及两种经典的流形学习方法，k近邻算法的核心在于k值的选取以及距离的度量，MDS要求原始空间样本之间的距离在降维后的低维空间中得以保持，主成分分析试图找到一个低维超平面来表出原空间样本点，核化主成分分析先将样本点映射到高维空间，再在高维空间中使用线性降维的方法，从而解决了原空间样本非线性分布的情形，基于流形学习的降维则是一种“邻域保持”的思想，最后度量学习试图去学习出一个距离度量来等效降维的效果。本篇将讨论另一种常用方法—特征选择与稀疏学习。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(12)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-27T04:20:38.000Z</published>
    <updated>2020-07-27T11:03:08.270Z</updated>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了几种常用的聚类算法，首先从距离度量与性能评估出发，列举了常见的距离计算公式与聚类评价指标，接着分别讨论了K-Means、LVQ、高斯混合聚类、密度聚类以及层次聚类算法。K-Means与LVQ都试图以类簇中心作为原型指导聚类，其中K-Means通过EM算法不断迭代直至收敛，LVQ使用真实类标辅助聚类；高斯混合聚类采用高斯分布来描述类簇原型；密度聚类则是将一个核心对象所有密度可达的样本形成类簇，直到所有核心对象都遍历完；最后层次聚类是一种自底向上的树形聚类方法，不断合并最相近的两个小类簇。本篇将讨论机器学习常用的方法—降维与度量学习。<br><a id="more"></a></p><p>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:25px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="11、降维与度量学习"><a href="#11、降维与度量学习" class="headerlink" title="11、降维与度量学习"></a><strong>11、降维与度量学习</strong></h1><p>样本的特征数称为<strong>维数</strong>（dimensionality），当维数非常大时，也就是现在所说的“<strong>维数灾难</strong>”，具体表现在：在高维情形下，<strong>数据样本将变得十分稀疏</strong>，因为此时要满足训练样本为“<strong>密采样</strong>”的总体样本数目是一个触不可及的天文数字，谓可远观而不可亵玩焉…<strong>训练样本的稀疏使得其代表总体分布的能力大大减弱，从而消减了学习器的泛化能力</strong>；同时当维数很高时，<strong>计算距离也变得十分复杂</strong>，甚至连计算内积都不再容易，这也是为什么支持向量机（SVM）使用核函数<strong>“低维计算，高维表现”</strong>的原因。</p><p>缓解维数灾难的一个重要途径就是<strong>降维，即通过某种数学变换将原始高维空间转变到一个低维的子空间</strong>。在这个子空间中，样本的密度将大幅提高，同时距离计算也变得容易。这时也许会有疑问，这样降维之后不是会丢失原始数据的一部分信息吗？这是因为在很多实际的问题中，虽然训练数据是高维的，但是与学习任务相关也许仅仅是其中的一个低维子空间，也称为一个<strong>低维嵌入</strong>，例如：数据属性中存在噪声属性、相似属性或冗余属性等，<strong>对高维数据进行降维能在一定程度上达到提炼低维优质属性或降噪的效果</strong>。</p><h2 id="11-1-K近邻学习"><a href="#11-1-K近邻学习" class="headerlink" title="11.1 K近邻学习"></a><strong>11.1 K近邻学习</strong></h2><p>k近邻算法简称<strong>kNN（k-Nearest Neighbor）</strong>，是一种经典的监督学习方法，同时也实力担当入选数据挖掘十大算法。其工作机制十分简单粗暴：给定某个测试样本，kNN基于某种<strong>距离度量</strong>在训练集中找出与其距离最近的k个带有真实标记的训练样本，然后给基于这k个邻居的真实标记来进行预测，类似于前面集成学习中所讲到的基学习器结合策略：分类任务采用投票法，回归任务则采用平均法。接下来本篇主要就kNN分类进行讨论。</p><p><img src="https://i.loli.net/2018/10/18/5bc851a43873a.png" alt="1.png"></p><p>从上图【来自Wiki】中我们可以看到，图中有两种类型的样本，一类是蓝色正方形，另一类是红色三角形。而那个绿色圆形是我们待分类的样本。基于kNN算法的思路，我们很容易得到以下结论：</p><blockquote><p>如果K=3，那么离绿色点最近的有2个红色三角形和1个蓝色的正方形，这3个点投票，于是绿色的这个待分类点属于红色的三角形。<br>如果K=5，那么离绿色点最近的有2个红色三角形和3个蓝色的正方形，这5个点投票，于是绿色的这个待分类点属于蓝色的正方形。</p></blockquote><p>可以发现：<strong>kNN虽然是一种监督学习方法，但是它却没有显式的训练过程</strong>，而是当有新样本需要预测时，才来计算出最近的k个邻居，因此<strong>kNN是一种典型的懒惰学习方法</strong>，再来回想一下朴素贝叶斯的流程，训练的过程就是参数估计，因此朴素贝叶斯也可以懒惰式学习，此类技术在<strong>训练阶段开销为零</strong>，待收到测试样本后再进行计算。相应地我们称那些一有训练数据立马开工的算法为“<strong>急切学习</strong>”，可见前面我们学习的大部分算法都归属于急切学习。</p><p>很容易看出：<strong>kNN算法的核心在于k值的选取以及距离的度量</strong>。k值选取太小，模型很容易受到噪声数据的干扰，例如：极端地取k=1，若待分类样本正好与一个噪声数据距离最近，就导致了分类错误；若k值太大， 则在更大的邻域内进行投票，此时模型的预测能力大大减弱，例如：极端取k=训练样本数，就相当于模型根本没有学习，所有测试样本的预测结果都是一样的。<strong>一般地我们都通过交叉验证法来选取一个适当的k值</strong>。</p><p><img src="https://i.loli.net/2018/10/18/5bc851a47db9a.png" alt="2.png"></p><p>对于距离度量，<strong>不同的度量方法得到的k个近邻不尽相同，从而对最终的投票结果产生了影响</strong>，因此选择一个合适的距离度量方法也十分重要。在上一篇聚类算法中，在度量样本相似性时介绍了常用的几种距离计算方法，包括<strong>闵可夫斯基距离，曼哈顿距离，VDM</strong>等。在实际应用中，<strong>kNN的距离度量函数一般根据样本的特性来选择合适的距离度量，同时应对数据进行去量纲/归一化处理来消除大量纲属性的强权政治影响</strong>。</p><h2 id="11-2-MDS算法"><a href="#11-2-MDS算法" class="headerlink" title="11.2 MDS算法"></a><strong>11.2 MDS算法</strong></h2><p>不管是使用核函数升维还是对数据降维，我们都希望<strong>原始空间样本点之间的距离在新空间中基本保持不变</strong>，这样才不会使得原始空间样本之间的关系及总体分布发生较大的改变。<strong>“多维缩放”（MDS）</strong>正是基于这样的思想，<strong>MDS要求原始空间样本之间的距离在降维后的低维空间中得以保持</strong>。</p><p>假定m个样本在原始空间中任意两两样本之间的距离矩阵为D∈R(m<em>m)，我们的目标便是获得样本在低维空间中的表示Z∈R(d’</em>m , d’&lt; d)，且任意两个样本在低维空间中的欧式距离等于原始空间中的距离，即||zi-zj||=Dist(ij)。因此接下来我们要做的就是根据已有的距离矩阵D来求解出降维后的坐标矩阵Z。</p><p><img src="https://i.loli.net/2018/10/18/5bc851a4b664e.png" alt="3.png"></p><p>令降维后的样本坐标矩阵Z被中心化，<strong>中心化是指将每个样本向量减去整个样本集的均值向量，故所有样本向量求和得到一个零向量</strong>。这样易知：矩阵B的每一列以及每一列求和均为0，因为提取公因子后都有一项为所有样本向量的和向量。</p><p><img src="https://i.loli.net/2018/10/18/5bc851a4a4ee2.png" alt="4.png"></p><p>根据上面矩阵B的特征，我们很容易得到等式（2）、（3）以及（4）：</p><p><img src="https://i.loli.net/2018/10/18/5bc851a4a777b.png" alt="5.png"></p><p>这时根据(1)—(4)式我们便可以计算出bij，即<strong>bij=(1)-(2)<em>(1/m)-(3)</em>(1/m)+(4)*(1/(m^2))</strong>，再逐一地计算每个b(ij)，就得到了降维后低维空间中的内积矩阵B(B=Z’*Z)，只需对B进行特征值分解便可以得到Z。MDS的算法流程如下图所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc851a5340dd.png" alt="6.png"></p><h2 id="11-3-主成分分析（PCA）"><a href="#11-3-主成分分析（PCA）" class="headerlink" title="11.3 主成分分析（PCA）"></a><strong>11.3 主成分分析（PCA）</strong></h2><p>不同于MDS采用距离保持的方法，<strong>主成分分析（PCA）直接通过一个线性变换，将原始空间中的样本投影到新的低维空间中</strong>。简单来理解这一过程便是：<strong>PCA采用一组新的基来表示样本点，其中每一个基向量都是原来基向量的线性组合，通过使用尽可能少的新基向量来表出样本，从而达到降维的目的。</strong></p><p>假设使用d’个新基向量来表示原来样本，实质上是将样本投影到一个由d’个基向量确定的一个<strong>超平面</strong>上（<strong>即舍弃了一些维度</strong>），要用一个超平面对空间中所有高维样本进行恰当的表达，最理想的情形是：<strong>若这些样本点都能在超平面上表出且这些表出在超平面上都能够很好地分散开来</strong>。但是一般使用较原空间低一些维度的超平面来做到这两点十分不容易，因此我们退一步海阔天空，要求这个超平面应具有如下两个性质：</p><blockquote><p><strong>最近重构性</strong>：样本点到超平面的距离足够近，即尽可能在超平面附近；<br><strong>最大可分性</strong>：样本点在超平面上的投影尽可能地分散开来，即投影后的坐标具有区分性。</p></blockquote><p>这里十分神奇的是：<strong>最近重构性与最大可分性虽然从不同的出发点来定义优化问题中的目标函数，但最终这两种特性得到了完全相同的优化问题</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc851a5213c1.png" alt="7.png"></p><p>接着使用拉格朗日乘子法求解上面的优化问题，得到：</p><p><img src="https://i.loli.net/2018/10/18/5bc851a4a102a.png" alt="8.png"></p><p>因此只需对协方差矩阵进行特征值分解即可求解出W，PCA算法的整个流程如下图所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc851a540eb3.png" alt="9.png"></p><p>另一篇博客给出更通俗更详细的理解：<a href="http://blog.csdn.net/u011826404/article/details/57472730" target="_blank" rel="noopener">主成分分析解析（基于最大方差理论）</a></p><h2 id="11-4-核化线性降维"><a href="#11-4-核化线性降维" class="headerlink" title="11.4 核化线性降维"></a><strong>11.4 核化线性降维</strong></h2><p>说起机器学习你中有我/我中有你/水乳相融…在这里能够得到很好的体现。正如SVM在处理非线性可分时，通过引入核函数将样本投影到高维特征空间，接着在高维空间再对样本点使用超平面划分。这里也是相同的问题：若我们的样本数据点本身就不是线性分布，那还如何使用一个超平面去近似表出呢？因此也就引入了核函数，<strong>即先将样本映射到高维空间，再在高维空间中使用线性降维的方法</strong>。下面主要介绍<strong>核化主成分分析（KPCA）</strong>的思想。</p><p>若核函数的形式已知，即我们知道如何将低维的坐标变换为高维坐标，这时我们只需先将数据映射到高维特征空间，再在高维空间中运用PCA即可。但是一般情况下，我们并不知道核函数具体的映射规则，例如：Sigmoid、高斯核等，我们只知道如何计算高维空间中的样本内积，这时就引出了KPCA的一个重要创新之处：<strong>即空间中的任一向量，都可以由该空间中的所有样本线性表示</strong>。证明过程也十分简单：</p><p><img src="https://i.loli.net/2018/10/18/5bc851a51bd2a.png" alt="10.png"></p><p>这样我们便可以将高维特征空间中的投影向量wi使用所有高维样本点线性表出，接着代入PCA的求解问题，得到：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b74b083.png" alt="11.png"></p><p>化简到最后一步，发现结果十分的美妙，只需对核矩阵K进行特征分解，便可以得出投影向量wi对应的系数向量α，因此选取特征值前d’大对应的特征向量便是d’个系数向量。这时对于需要降维的样本点，只需按照以下步骤便可以求出其降维后的坐标。可以看出：KPCA在计算降维后的坐标表示时，需要与所有样本点计算核函数值并求和，因此该算法的计算开销十分大。</p><p><img src="https://i.loli.net/2018/10/18/5bc851b735754.png" alt="12.png"></p><h2 id="11-5-流形学习"><a href="#11-5-流形学习" class="headerlink" title="11.5 流形学习"></a><strong>11.5 流形学习</strong></h2><p><strong>流形学习（manifold learning）是一种借助拓扑流形概念的降维方法</strong>，<strong>流形是指在局部与欧式空间同胚的空间</strong>，即在局部与欧式空间具有相同的性质，能用欧氏距离计算样本之间的距离。这样即使高维空间的分布十分复杂，但是在局部上依然满足欧式空间的性质，基于流形学习的降维正是这种<strong>“邻域保持”</strong>的思想。其中<strong>等度量映射（Isomap）试图在降维前后保持邻域内样本之间的距离，而局部线性嵌入（LLE）则是保持邻域内样本之间的线性关系</strong>，下面将分别对这两种著名的流行学习方法进行介绍。</p><h3 id="11-5-1-等度量映射（Isomap）"><a href="#11-5-1-等度量映射（Isomap）" class="headerlink" title="11.5.1 等度量映射（Isomap）"></a><strong>11.5.1 等度量映射（Isomap）</strong></h3><p>等度量映射的基本出发点是：高维空间中的直线距离具有误导性，因为有时高维空间中的直线距离在低维空间中是不可达的。<strong>因此利用流形在局部上与欧式空间同胚的性质，可以使用近邻距离来逼近测地线距离</strong>，即对于一个样本点，它与近邻内的样本点之间是可达的，且距离使用欧式距离计算，这样整个样本空间就形成了一张近邻图，高维空间中两个样本之间的距离就转为最短路径问题。可采用著名的<strong>Dijkstra算法</strong>或<strong>Floyd算法</strong>计算最短距离，得到高维空间中任意两点之间的距离后便可以使用MDS算法来其计算低维空间中的坐标。</p><p><img src="https://i.loli.net/2018/10/18/5bc851b731a1e.png" alt="13.png"></p><p>从MDS算法的描述中我们可以知道：MDS先求出了低维空间的内积矩阵B，接着使用特征值分解计算出了样本在低维空间中的坐标，但是并没有给出通用的投影向量w，因此对于需要降维的新样本无从下手，书中给出的权宜之计是利用已知高/低维坐标的样本作为训练集学习出一个“投影器”，便可以用高维坐标预测出低维坐标。Isomap算法流程如下图：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b6c7e37.png" alt="14.png"></p><p>对于近邻图的构建，常用的有两种方法：<strong>一种是指定近邻点个数</strong>，像kNN一样选取k个最近的邻居；<strong>另一种是指定邻域半径</strong>，距离小于该阈值的被认为是它的近邻点。但两种方法均会出现下面的问题：</p><blockquote><p>若<strong>邻域范围指定过大，则会造成“短路问题”</strong>，即本身距离很远却成了近邻，将距离近的那些样本扼杀在摇篮。<br>若<strong>邻域范围指定过小，则会造成“断路问题”</strong>，即有些样本点无法可达了，整个世界村被划分为互不可达的小部落。</p></blockquote><h3 id="11-5-2-局部线性嵌入-LLE"><a href="#11-5-2-局部线性嵌入-LLE" class="headerlink" title="11.5.2 局部线性嵌入(LLE)"></a><strong>11.5.2 局部线性嵌入(LLE)</strong></h3><p>不同于Isomap算法去保持邻域距离，LLE算法试图去保持邻域内的线性关系，假定样本xi的坐标可以通过它的邻域样本线性表出：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b64236f.png" alt="15.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc851b6a7b9a.png" alt="16.png"></p><p>LLE算法分为两步走，<strong>首先第一步根据近邻关系计算出所有样本的邻域重构系数w</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b662815.png" alt="17.png"></p><p><strong>接着根据邻域重构系数不变，去求解低维坐标</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b648b98.png" alt="18.png"></p><p>这样利用矩阵M，优化问题可以重写为：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b6948d7.png" alt="19.png"></p><p>M特征值分解后最小的d’个特征值对应的特征向量组成Z，LLE算法的具体流程如下图所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc851b757d8c.png" alt="20.png"></p><h2 id="11-6-度量学习"><a href="#11-6-度量学习" class="headerlink" title="11.6 度量学习"></a><strong>11.6 度量学习</strong></h2><p>本篇一开始就提到维数灾难，即在高维空间进行机器学习任务遇到样本稀疏、距离难计算等诸多的问题，因此前面讨论的降维方法都试图将原空间投影到一个合适的低维空间中，接着在低维空间进行学习任务从而产生较好的性能。事实上，不管高维空间还是低维空间都潜在对应着一个距离度量，那可不可以直接学习出一个距离度量来等效降维呢？例如：<strong>咋们就按照降维后的方式来进行距离的计算，这便是度量学习的初衷</strong>。</p><p><strong>首先要学习出距离度量必须先定义一个合适的距离度量形式</strong>。对两个样本xi与xj，它们之间的平方欧式距离为：</p><p><img src="https://i.loli.net/2018/10/18/5bc851d3ca3d5.png" alt="21.png"></p><p>若各个属性重要程度不一样即都有一个权重，则得到加权的平方欧式距离：</p><p><img src="https://i.loli.net/2018/10/18/5bc851d3d82c5.png" alt="22.png"></p><p>此时各个属性之间都是相互独立无关的，但现实中往往会存在属性之间有关联的情形，例如：身高和体重，一般人越高，体重也会重一些，他们之间存在较大的相关性。这样计算距离就不能分属性单独计算，于是就引入经典的<strong>马氏距离(Mahalanobis distance)</strong>:</p><p><img src="https://i.loli.net/2018/10/18/5bc851d3dc303.png" alt="23.png"></p><p><strong>标准的马氏距离中M是协方差矩阵的逆，马氏距离是一种考虑属性之间相关性且尺度无关（即无须去量纲）的距离度量</strong>。</p><p><img src="https://i.loli.net/2018/10/18/5bc851d3e17c0.png" alt="24.png"></p><p><strong>矩阵M也称为“度量矩阵”，为保证距离度量的非负性与对称性，M必须为(半)正定对称矩阵</strong>，这样就为度量学习定义好了距离度量的形式，换句话说：<strong>度量学习便是对度量矩阵进行学习</strong>。现在来回想一下前面我们接触的机器学习不难发现：<strong>机器学习算法几乎都是在优化目标函数，从而求解目标函数中的参数</strong>。同样对于度量学习，也需要设置一个优化目标，书中简要介绍了错误率和相似性两种优化目标，此处限于篇幅不进行展开。</p><p>在此，降维和度量学习就介绍完毕。<strong>降维是将原高维空间嵌入到一个合适的低维子空间中，接着在低维空间中进行学习任务；度量学习则是试图去学习出一个距离度量来等效降维的效果</strong>，两者都是为了解决维数灾难带来的诸多问题。也许大家最后心存疑惑，那kNN呢，为什么一开头就说了kNN算法，但是好像和后面没有半毛钱关系？正是因为在降维算法中，低维子空间的维数d’通常都由人为指定，因此我们需要使用一些低开销的学习器来选取合适的d’，<strong>kNN这家伙懒到家了根本无心学习，在训练阶段开销为零，测试阶段也只是遍历计算了距离，因此拿kNN来进行交叉验证就十分有优势了~同时降维后样本密度增大同时距离计算变易，更为kNN来展示它独特的十八般手艺提供了用武之地。</strong></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇主要介绍了几种常用的聚类算法，首先从距离度量与性能评估出发，列举了常见的距离计算公式与聚类评价指标，接着分别讨论了K-Means、LVQ、高斯混合聚类、密度聚类以及层次聚类算法。K-Means与LVQ都试图以类簇中心作为原型指导聚类，其中K-Means通过EM算法不断迭代直至收敛，LVQ使用真实类标辅助聚类；高斯混合聚类采用高斯分布来描述类簇原型；密度聚类则是将一个核心对象所有密度可达的样本形成类簇，直到所有核心对象都遍历完；最后层次聚类是一种自底向上的树形聚类方法，不断合并最相近的两个小类簇。本篇将讨论机器学习常用的方法—降维与度量学习。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>Python进阶</title>
    <link href="http://yoursite.com/2020/07/27/Python%E8%BF%9B%E9%98%B6/"/>
    <id>http://yoursite.com/2020/07/27/Python%E8%BF%9B%E9%98%B6/</id>
    <published>2020-07-27T04:13:45.000Z</published>
    <updated>2020-07-27T09:50:55.953Z</updated>
    
    <content type="html"><![CDATA[<p>参考<a href="https://eastlakeside.gitbook.io/interpy-zh/" target="_blank" rel="noopener">此处</a></p><h1 id="Python进阶"><a href="#Python进阶" class="headerlink" title="Python进阶 "></a>Python进阶 </h1><p>《Python进阶》是《Intermediate Python》的中文译本, 谨以此献给进击的 Python 和 Python 程序员们!<br><a id="more"></a></p><h3 id="快速阅读传送门"><a href="#快速阅读传送门" class="headerlink" title="快速阅读传送门"></a>快速阅读传送门</h3><ul><li>Github快速阅读任一章节：<a href="https://github.com/eastlakeside/interpy-zh/blob/master/SUMMARY.md" target="_blank" rel="noopener">进入目录</a></li><li>Gitbook完整顺序地阅读：<a href="https://eastlakeside.gitbooks.io/interpy-zh/content/" target="_blank" rel="noopener">进入Gitbook</a></li><li>本地或kindle上阅读：<a href="https://github.com/eastlakeside/interpy-zh/releases" target="_blank" rel="noopener">下载pdf/epub/mobi</a></li><li>国内推荐镜像（实时同步）：<a href="http://wiki.jikexueyuan.com/project/interpy-zh/" target="_blank" rel="noopener">极客学院收录</a></li><li>其他镜像（不定期同步）：<a href="http://docs.pythontab.com/interpy/" target="_blank" rel="noopener">Pythontab收录</a></li><li>纯代码阅读和演示：<a href="https://github.com/eastlakeside/interpy-zh/tree/master/code/" target="_blank" rel="noopener">进入code目录</a></li></ul><h1 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h1><p>Python，作为一个”老练”、”小清新”的开发语言，已受到广大才男俊女的喜爱。我们也从最基础的Python粉，经过时间的摧残慢慢的变成了Python老鬼。</p><p>IntermediatePython这本书具有如下几个优点：</p><ol><li>简单</li><li>易读</li><li>易译</li></ol><p>这些都不是重点，重点是：<strong>它是一本开脑洞的书</strong>。无论你是Python初学者，还是Python高手，它显现给你的永远是Python里最美好的事物。</p><blockquote><p>世上语言千万种<br>美好事物藏其中</p></blockquote><p>译者在翻译过程中，慢慢发现，本书作者的行文方式有着科普作家的风范，—那就是能将晦涩难懂的技术用比较清晰简洁的方式进行呈现，深入浅出的风格在每个章节的讨论中都得到了体现：</p><ul><li>每个章节都非常精简，5分钟就能看完，用最简洁的例子精辟地展现了原理</li><li>每个章节都会通过疑问，来引导读者主动思考答案</li><li>每个章节都引导读者做延伸阅读，让有兴趣的读者能进一步举一反三</li><li>每个章节都是独立的，你可以挑选任意的章节开始阅读，而不受影响</li></ul><p>总之，这本书非常方便随时选取一个章节进行阅读，而且每次阅读一个章节，你都可能会有一些新的发现。</p><h2 id="原书作者"><a href="#原书作者" class="headerlink" title="原书作者"></a>原书作者</h2><p>感谢英文原著作者 @yasoob《<a href="https://github.com/yasoob/intermediatePython" target="_blank" rel="noopener">Intermediate Python</a>》，有了他才有了这里的一切</p><h1 id="序"><a href="#序" class="headerlink" title="序"></a>序</h1><p>这是一本<a href="https://github.com/yasoob/intermediatePython" target="_blank" rel="noopener">Intermediate Python</a> 的中文译本, 谨以此献给进击的 Python 和 Python 程序员们!</p><p>这是一次团队建设、一次尝鲜、一次对自我的提升。相信每个有为青年，心里想藏着一个小宇宙：<strong>我想要做一件有意思的事</strong>。<script type="math/tex">什么是有意思的事？</script> <strong>别闹</strong></p><p>Python，作为一个”老练”、”小清新”的开发语言，已受到广大才男俊女的喜爱。我们也从最基础的Python粉，经过时间的摧残慢慢的变成了Python老鬼。因此一开始 @大牙 提出要翻译点什么的时候，我还是挺兴奋的，团队一起协作，不单可以磨练自己，也能加强团队之间的协作。为此在经过短暂的讨论后，翻译的内容就定为：《Intermediate Python》。</p><p>IntermediatePython这本书具有如下几个优点：</p><ol><li>简单</li><li>易读</li><li>易译</li></ol><p>这些都不是重点，重点是：<strong>它是一本开脑洞的书</strong>。无论你是Python初学者，还是Python高手，它显现给你的永远是Python里最美好的事物。</p><h1 id="关于原作者"><a href="#关于原作者" class="headerlink" title="关于原作者"></a>关于原作者</h1><p>我是 Muhammad Yasoob Ullah Khalid. </p><p>我已经广泛使用 Python 编程3年多了. 同时参与了很多开源项目. 并定期在<a href="http://pythontips.com/" target="_blank" rel="noopener">我的博客</a>里写一些关于Python有趣的话题. </p><p>2014年我在柏林举办的欧洲最大的Python会议<strong>EuroPython</strong>上做过精彩的演讲. </p><blockquote><p>译者注：分享的主题为：《Session: Web Scraping in Python 101》<br>地址：<a href="https://ep2014.europython.eu/en/schedule/sessions/20/" target="_blank" rel="noopener">https://ep2014.europython.eu/en/schedule/sessions/20/</a></p></blockquote><p>如果你能给我有意思的工作机会, 请联系我哦.</p><blockquote><p>译者注：嗯，硬广，你来中国么，HOHO</p></blockquote><h1 id="作者前言"><a href="#作者前言" class="headerlink" title="作者前言"></a>作者前言</h1><p>Hello 大家好! 我非常自豪地宣布我自己创作的书完成啦.<br>经过很多辛苦工作和决心, 终于将不可能变成了可能, “Intermediate Python”终于杀青.<br>ps: 它还将持续更新 :)</p><p>Python 是一门奇妙的语言, 还有一个强大而友爱的程序员社区.<br>然而, 在你理解消化掉 Python 的基础后, 关于下一步学习什么的资料比较缺乏. 而我正是要通过本书来解决这一问题.<br>我会给你一些可以进一步探索的有趣的话题的信息.</p><p>本书讨论的这些话题将会打开你的脑洞, 将你引导至 Python 语言的一些美好的地方. 我最开始学习 Python 时, 渴望见到Python最优雅的地方, 而本书正是这些渴望的结果.</p><p>无论你是个初学者, 中级或者甚至高级程序员, 你都会在这本书里有所收获.</p><p>请注意本书不是一个指导手册, 也不会教你 Python. 因为书中的话题并没有进行基础解释, 而只提供了展开讨论前所需的最少信息.</p><p>好啦，你肯定也和我一样兴奋, 那让我们开始吧!</p><h1 id="开源公告"><a href="#开源公告" class="headerlink" title="开源公告"></a>开源公告</h1><p>注意: 这本书是开源的, 也是一个持续进展中的工作. 如果你发现typo, 或者想添加更多内容进来, 或者可以改进的任意地方(我知道你会发现很多),  那么请慷慨地提交一个 pull request, 我会无比高兴地合并进来. :)</p><p>另外, 我决定将这本书免费发布!   我相信它会帮助到那些需要帮助的人. 祝你们好运!</p><p>这里是免费阅读链接:</p><ul><li><a href="http://book.pythontips.com/" target="_blank" rel="noopener">Html</a> </li><li><a href="http://readthedocs.org/projects/intermediatepythongithubio/downloads/pdf/latest/" target="_blank" rel="noopener">PDF</a></li><li><a href="https://github.com/IntermediatePython/intermediatePython" target="_blank" rel="noopener">GitHub</a></li></ul><h1 id="args-和-kwargs"><a href="#args-和-kwargs" class="headerlink" title="*args 和 **kwargs"></a><code>*args</code> 和 <code>**kwargs</code></h1><p>我观察到，大部分新的Python程序员都需要花上大量时间理解清楚 <code>*args</code> 和<code>**kwargs</code>这两个魔法变量。那么它们到底是什么? </p><p>首先让我告诉你, 其实并不是必须写成<code>*args</code> 和<code>**kwargs</code>。 只有变量前面的 <code>*</code>(星号)才是必须的. 你也可以写成<code>*var</code> 和<code>**vars</code>. 而写成<code>*args</code> 和<code>**kwargs</code>只是一个通俗的命名约定。 那就让我们先看一下<code>*args</code>吧。</p><h1 id="args-的用法"><a href="#args-的用法" class="headerlink" title="*args 的用法"></a>*args 的用法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">和 &#96;&#96;&#96;**kwargs&#96;&#96;&#96; 主要用于函数定义。 你可以将不定数量的参数传递给一个函数。 </span><br><span class="line"></span><br><span class="line">这里的不定的意思是：预先并不知道, 函数使用者会传递多少个参数给你, 所以在这个场景下使用这两个关键字。 &#96;&#96;&#96;*args&#96;&#96;&#96; 是用来发送一个非键值对的可变数量的参数列表给一个函数. </span><br><span class="line"></span><br><span class="line">这里有个例子帮你理解这个概念:</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">def test_var_args(f_arg, *argv):</span><br><span class="line">    print(&quot;first normal arg:&quot;, f_arg)</span><br><span class="line">    for arg in argv:</span><br><span class="line">        print(&quot;another arg through *argv:&quot;, arg)</span><br><span class="line"></span><br><span class="line">test_var_args(&#39;yasoob&#39;, &#39;python&#39;, &#39;eggs&#39;, &#39;test&#39;)</span><br></pre></td></tr></table></figure><p>这会产生如下输出:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">first normal arg: yasoob</span><br><span class="line">another arg through *argv: python</span><br><span class="line">another arg through *argv: eggs</span><br><span class="line">another arg through *argv: test</span><br></pre></td></tr></table></figure><p>我希望这解决了你所有的困惑. 那接下来让我们谈谈 <code>**kwargs</code></p><h1 id="kwargs-的用法"><a href="#kwargs-的用法" class="headerlink" title="**kwargs 的用法"></a>**kwargs 的用法</h1><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">允许你将不定长度的**键值对**, 作为参数传递给一个函数。 如果你想要在一个函数里处理**带名字的参数**, 你应该使用&#96;&#96;&#96;**kwargs&#96;&#96;&#96;。 </span><br><span class="line"></span><br><span class="line">这里有个让你上手的例子:</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">def greet_me(**kwargs):</span><br><span class="line">    for key, value in kwargs.items():</span><br><span class="line">        print(&quot;&#123;0&#125; &#x3D;&#x3D; &#123;1&#125;&quot;.format(key, value))</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">&gt;&gt;&gt; greet_me(name&#x3D;&quot;yasoob&quot;)</span><br><span class="line">name &#x3D;&#x3D; yasoob</span><br></pre></td></tr></table></figure><p>现在你可以看出我们怎样在一个函数里, 处理了一个<strong>键值对</strong>参数了。</p><p>这就是<code>**kwargs</code>的基础, 而且你可以看出它有多么管用。 接下来让我们谈谈，你怎样使用<code>*args</code> 和 <code>**kwargs</code>来调用一个参数为列表或者字典的函数。</p><h1 id="使用-args-和-kwargs-来调用函数"><a href="#使用-args-和-kwargs-来调用函数" class="headerlink" title="使用 *args 和 **kwargs 来调用函数"></a>使用 <code>*args</code> 和 <code>**kwargs</code> 来调用函数</h1><p>那现在我们将看到怎样使用<code>*args</code>和<code>**kwargs</code> 来调用一个函数。<br> 假设，你有这样一个小函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">test_args_kwargs</span><span class="params">(arg1, arg2, arg3)</span>:</span></span><br><span class="line">    print(<span class="string">"arg1:"</span>, arg1)</span><br><span class="line">    print(<span class="string">"arg2:"</span>, arg2)</span><br><span class="line">    print(<span class="string">"arg3:"</span>, arg3)</span><br></pre></td></tr></table></figure></p><p>你可以使用<code>*args</code>或<code>**kwargs</code>来给这个小函数传递参数。<br>下面是怎样做：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先使用 *args</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>args = (<span class="string">"two"</span>, <span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_args_kwargs(*args)</span><br><span class="line">arg1: two</span><br><span class="line">arg2: <span class="number">3</span></span><br><span class="line">arg3: <span class="number">5</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在使用 **kwargs:</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>kwargs = &#123;<span class="string">"arg3"</span>: <span class="number">3</span>, <span class="string">"arg2"</span>: <span class="string">"two"</span>, <span class="string">"arg1"</span>: <span class="number">5</span>&#125;</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>test_args_kwargs(**kwargs)</span><br><span class="line">arg1: <span class="number">5</span></span><br><span class="line">arg2: two</span><br><span class="line">arg3: <span class="number">3</span></span><br></pre></td></tr></table></figure></p><h3 id="标准参数与-args、-kwargs在使用时的顺序"><a href="#标准参数与-args、-kwargs在使用时的顺序" class="headerlink" title="标准参数与*args、**kwargs在使用时的顺序"></a>标准参数与<code>*args、**kwargs</code>在使用时的顺序</h3><p>那么如果你想在函数里同时使用所有这三种参数， 顺序是这样的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">some_func(fargs, *args, **kwargs)</span><br></pre></td></tr></table></figure></p><h1 id="什么时候使用它们？"><a href="#什么时候使用它们？" class="headerlink" title="什么时候使用它们？"></a>什么时候使用它们？</h1><p>这还真的要看你的需求而定。</p><p>最常见的用例是在写函数装饰器的时候（会在另一章里讨论）。</p><p>此外它也可以用来做猴子补丁(monkey patching)。猴子补丁的意思是在程序运行时(runtime)修改某些代码。 打个比方，你有一个类，里面有个叫<code>get_info</code>的函数会调用一个API并返回相应的数据。如果我们想测试它，可以把API调用替换成一些测试数据。例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> someclass</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">get_info</span><span class="params">(self, *args)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"Test data"</span></span><br><span class="line"></span><br><span class="line">someclass.get_info = get_info</span><br></pre></td></tr></table></figure></p><p>我敢肯定你也可以想象到一些其他的用例。</p><h1 id="调试（Debugging）"><a href="#调试（Debugging）" class="headerlink" title="调试（Debugging）"></a>调试（Debugging）</h1><p>利用好调试，能大大提高你捕捉代码Bug的。大部分新人忽略了Python debugger(<code>pdb</code>)的重要性。 在这个章节我只会告诉你一些重要的命令，你可以从官方文档中学习到更多。</p><blockquote><p>译者注，参考：<a href="https://docs.python.org/2/library/pdb.html" target="_blank" rel="noopener">https://docs.python.org/2/library/pdb.html</a><br>Or <a href="https://docs.python.org/3/library/pdb.html" target="_blank" rel="noopener">https://docs.python.org/3/library/pdb.html</a></p></blockquote><h3 id="从命令行运行"><a href="#从命令行运行" class="headerlink" title="从命令行运行"></a>从命令行运行</h3><p>你可以在命令行使用Python debugger运行一个脚本， 举个例子：<br><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ python -m pdb my_script.py</span><br></pre></td></tr></table></figure></p><p>这会触发debugger在脚本第一行指令处停止执行。这在脚本很短时会很有帮助。你可以通过(Pdb)模式接着查看变量信息，并且逐行调试。</p><h3 id="从脚本内部运行"><a href="#从脚本内部运行" class="headerlink" title="从脚本内部运行"></a>从脚本内部运行</h3><p>同时，你也可以在脚本内部设置断点，这样就可以在某些特定点查看变量信息和各种执行时信息了。这里将使用<code>pdb.set_trace()</code>方法来实现。举个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> pdb</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">make_bread</span><span class="params">()</span>:</span></span><br><span class="line">    pdb.set_trace()</span><br><span class="line">    <span class="keyword">return</span> <span class="string">"I don't have time"</span></span><br><span class="line"></span><br><span class="line">print(make_bread())</span><br></pre></td></tr></table></figure></p><p>试下保存上面的脚本后运行之。你会在运行时马上进入debugger模式。现在是时候了解下debugger模式下的一些命令了。</p><h5 id="命令列表："><a href="#命令列表：" class="headerlink" title="命令列表："></a>命令列表：</h5><ul><li><code>c</code>: 继续执行</li><li><code>w</code>: 显示当前正在执行的代码行的上下文信息</li><li><code>a</code>: 打印当前函数的参数列表</li><li><code>s</code>: 执行当前代码行，并停在第一个能停的地方（相当于单步进入）</li><li><code>n</code>: 继续执行到当前函数的下一行，或者当前行直接返回（单步跳过）</li></ul><p>单步跳过（<code>n</code>ext）和单步进入（<code>s</code>tep）的区别在于， 单步进入会进入当前行调用的函数内部并停在里面， 而单步跳过会（几乎）全速执行完当前行调用的函数，并停在当前函数的下一行。</p><p>pdb真的是一个很方便的功能，上面仅列举少量用法，更多的命令强烈推荐你去看官方文档。</p><h1 id="生成器（Generators）"><a href="#生成器（Generators）" class="headerlink" title="生成器（Generators）"></a>生成器（Generators）</h1><p>首先我们要理解迭代器(iterators)。根据维基百科，迭代器是一个让程序员可以遍历一个容器（特别是列表）的对象。然而，一个迭代器在遍历并读取一个容器的数据元素时，并不会执行一个迭代。你可能有点晕了，那我们来个慢动作。换句话说这里有三个部分：</p><ul><li>可迭代对象(Iterable)</li><li>迭代器(Iterator)</li><li>迭代(Iteration)</li></ul><p>上面这些部分互相联系。我们会先各个击破来讨论他们，然后再讨论生成器(generators).</p><h1 id="可迭代对象-Iterable"><a href="#可迭代对象-Iterable" class="headerlink" title="可迭代对象(Iterable)"></a>可迭代对象(Iterable)</h1><p>Python中任意的对象，只要它定义了可以返回一个迭代器的<code>__iter__</code>方法，或者定义了可以支持下标索引的<code>__getitem__</code>方法(这些双下划线方法会在其他章节中全面解释)，那么它就是一个可迭代对象。简单说，可迭代对象就是能提供迭代器的任意对象。那迭代器又是什么呢？</p><h1 id="迭代器-Iterator"><a href="#迭代器-Iterator" class="headerlink" title="迭代器(Iterator)"></a>迭代器(Iterator)</h1><p>任意对象，只要定义了<code>next</code>(Python2) 或者<code>__next__</code>方法，它就是一个迭代器。就这么简单。现在我们来理解迭代(iteration)</p><h1 id="迭代-Iteration"><a href="#迭代-Iteration" class="headerlink" title="迭代(Iteration)"></a>迭代(Iteration)</h1><p>用简单的话讲，它就是从某个地方（比如一个列表）取出一个元素的过程。当我们使用一个循环来遍历某个东西时，这个过程本身就叫迭代。现在既然我们有了这些术语的基本理解，那我们开始理解生成器吧。</p><h1 id="生成器-Generators"><a href="#生成器-Generators" class="headerlink" title="生成器(Generators)"></a>生成器(Generators)</h1><p>生成器也是一种迭代器，但是你只能对其迭代一次。这是因为它们并没有把所有的值存在内存中，而是在运行时生成值。你通过遍历来使用它们，要么用一个“for”循环，要么将它们传递给任意可以进行迭代的函数和结构。大多数时候生成器是以函数来实现的。然而，它们并不返回一个值，而是<code>yield</code>(暂且译作“生出”)一个值。这里有个生成器函数的简单例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> item <span class="keyword">in</span> generator_function():</span><br><span class="line">    print(item)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: 0</span></span><br><span class="line"><span class="comment"># 1</span></span><br><span class="line"><span class="comment"># 2</span></span><br><span class="line"><span class="comment"># 3</span></span><br><span class="line"><span class="comment"># 4</span></span><br><span class="line"><span class="comment"># 5</span></span><br><span class="line"><span class="comment"># 6</span></span><br><span class="line"><span class="comment"># 7</span></span><br><span class="line"><span class="comment"># 8</span></span><br><span class="line"><span class="comment"># 9</span></span><br></pre></td></tr></table></figure></p><p>这个案例并不是非常实用。生成器最佳应用场景是：你不想同一时间将所有计算出来的大量结果集分配到内存当中，特别是结果集里还包含循环。</p><blockquote><p>译者注：这样做会消耗大量资源 </p></blockquote><p>许多Python 2里的标准库函数都会返回列表，而Python 3都修改成了返回生成器，因为生成器占用更少的资源。  </p><p>下面是一个计算斐波那契数列的生成器：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># generator version</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibon</span><span class="params">(n)</span>:</span></span><br><span class="line">    a = b = <span class="number">1</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a + b</span><br></pre></td></tr></table></figure><p>函数使用方法如下：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">for x in fibon(1000000):</span><br><span class="line">    print(x)</span><br></pre></td></tr></table></figure><p>用这种方式，我们可以不用担心它会使用大量资源。然而，之前如果我们这样来实现的话：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibon</span><span class="params">(n)</span>:</span></span><br><span class="line">    a = b = <span class="number">1</span></span><br><span class="line">    result = []</span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(n):</span><br><span class="line">        result.append(a)</span><br><span class="line">        a, b = b, a + b</span><br><span class="line">    <span class="keyword">return</span> result</span><br></pre></td></tr></table></figure><p>这也许会在计算很大的输入参数时，用尽所有的资源。我们已经讨论过生成器使用一次迭代，但我们并没有测试过。在测试前你需要再知道一个Python内置函数：<code>next()</code>。它允许我们获取一个序列的下一个元素。那我们来验证下我们的理解：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">generator_function</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">3</span>):</span><br><span class="line">        <span class="keyword">yield</span> i</span><br><span class="line"></span><br><span class="line">gen = generator_function()</span><br><span class="line">print(next(gen))</span><br><span class="line"><span class="comment"># Output: 0</span></span><br><span class="line">print(next(gen))</span><br><span class="line"><span class="comment"># Output: 1</span></span><br><span class="line">print(next(gen))</span><br><span class="line"><span class="comment"># Output: 2</span></span><br><span class="line">print(next(gen))</span><br><span class="line"><span class="comment"># Output: Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#            File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#         StopIteration</span></span><br></pre></td></tr></table></figure><p>我们可以看到，在<code>yield</code>掉所有的值后，<code>next()</code>触发了一个<code>StopIteration</code>的异常。基本上这个异常告诉我们，所有的值都已经被<code>yield</code>完了。你也许会奇怪，为什么我们在使用<code>for</code>循环时没有这个异常呢？啊哈，答案很简单。<code>for</code>循环会自动捕捉到这个异常并停止调用<code>next()</code>。你知不知道Python中一些内置数据类型也支持迭代哦？我们这就去看看：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">my_string = <span class="string">"Yasoob"</span></span><br><span class="line">next(my_string)</span><br><span class="line"><span class="comment"># Output: Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">#      File "&lt;stdin&gt;", line 1, in &lt;module&gt;</span></span><br><span class="line"><span class="comment">#    TypeError: str object is not an iterator</span></span><br></pre></td></tr></table></figure><p>好吧，这不是我们预期的。这个异常说那个<code>str</code>对象不是一个迭代器。对，就是这样！它是一个可迭代对象，而不是一个迭代器。这意味着它支持迭代，但我们不能直接对其进行迭代操作。那我们怎样才能对它实施迭代呢？是时候学习下另一个内置函数，<code>iter</code>。它将根据一个可迭代对象返回一个迭代器对象。这里是我们如何使用它：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_string = <span class="string">"Yasoob"</span></span><br><span class="line">my_iter = iter(my_string)</span><br><span class="line">next(my_iter)</span><br><span class="line"><span class="comment"># Output: 'Y'</span></span><br></pre></td></tr></table></figure><br>现在好多啦。我肯定你已经爱上了学习生成器。一定要记住，想要完全掌握这个概念，你只有使用它。确保你按照这个模式，并在生成器对你有意义的任何时候都使用它。你绝对不会失望的！</p><h1 id="Map，Filter-和-Reduce"><a href="#Map，Filter-和-Reduce" class="headerlink" title="Map，Filter 和 Reduce"></a>Map，Filter 和 Reduce</h1><p>Map，Filter 和 Reduce 三个函数能为函数式编程提供便利。我们会通过实例一个一个讨论并理解它们。</p><h1 id="Map"><a href="#Map" class="headerlink" title="Map"></a><code>Map</code></h1><p><code>Map</code>会将一个函数映射到一个输入列表的所有元素上。这是它的规范：</p><p><strong>规范</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">map(function_to_apply, list_of_inputs)</span><br></pre></td></tr></table></figure></p><p>大多数时候，我们要把列表中所有元素一个个地传递给一个函数，并收集输出。比方说：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = []</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> items:</span><br><span class="line">    squared.append(i**<span class="number">2</span>)</span><br></pre></td></tr></table></figure><p><code>Map</code>可以让我们用一种简单而漂亮得多的方式来实现。就是这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">items = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line">squared = list(map(<span class="keyword">lambda</span> x: x**<span class="number">2</span>, items))</span><br></pre></td></tr></table></figure><p>大多数时候，我们使用匿名函数(lambdas)来配合<code>map</code>, 所以我在上面也是这么做的。<br> 不仅用于一列表的输入， 我们甚至可以用于一列表的函数！</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">multiply</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (x*x)</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(x)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> (x+x)</span><br><span class="line"></span><br><span class="line">funcs = [multiply, add]</span><br><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">5</span>):</span><br><span class="line">    value = map(<span class="keyword">lambda</span> x: x(i), funcs)</span><br><span class="line">    print(list(value))</span><br><span class="line">    <span class="comment"># 译者注：上面print时，加了list转换，是为了python2/3的兼容性</span></span><br><span class="line">    <span class="comment">#        在python2中map直接返回列表，但在python3中返回迭代器</span></span><br><span class="line">    <span class="comment">#        因此为了兼容python3, 需要list转换一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"><span class="comment"># [0, 0]</span></span><br><span class="line"><span class="comment"># [1, 2]</span></span><br><span class="line"><span class="comment"># [4, 4]</span></span><br><span class="line"><span class="comment"># [9, 6]</span></span><br><span class="line"><span class="comment"># [16, 8]</span></span><br></pre></td></tr></table></figure><h1 id="Filter"><a href="#Filter" class="headerlink" title="Filter"></a><code>Filter</code></h1><p>顾名思义，<code>filter</code>过滤列表中的元素，并且返回一个由所有符合要求的元素所构成的列表，<code>符合要求</code>即函数映射到该元素时返回值为True. 这里是一个简短的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">number_list = range(<span class="number">-5</span>, <span class="number">5</span>)</span><br><span class="line">less_than_zero = filter(<span class="keyword">lambda</span> x: x &lt; <span class="number">0</span>, number_list)</span><br><span class="line">print(list(less_than_zero))  </span><br><span class="line"><span class="comment"># 译者注：上面print时，加了list转换，是为了python2/3的兼容性</span></span><br><span class="line"><span class="comment">#        在python2中filter直接返回列表，但在python3中返回迭代器</span></span><br><span class="line"><span class="comment">#        因此为了兼容python3, 需要list转换一下</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: [-5, -4, -3, -2, -1]</span></span><br></pre></td></tr></table></figure><p>这个<code>filter</code>类似于一个<code>for</code>循环，但它是一个内置函数，并且更快。</p><p>注意：如果<code>map</code>和<code>filter</code>对你来说看起来并不优雅的话，那么你可以看看另外一章：列表/字典/元组推导式。</p><blockquote><p>译者注：大部分情况下推导式的可读性更好</p></blockquote><h1 id="Reduce"><a href="#Reduce" class="headerlink" title="Reduce"></a><code>Reduce</code></h1><p>当需要对一个列表进行一些计算并返回结果时，<code>Reduce</code> 是个非常有用的函数。举个例子，当你需要计算一个整数列表的乘积时。</p><p>通常在 python 中你可能会使用基本的 for 循环来完成这个任务。</p><p>现在我们来试试 reduce：</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">from functools import reduce</span><br><span class="line">product &#x3D; reduce( (lambda x, y: x * y), [1, 2, 3, 4] )</span><br><span class="line"></span><br><span class="line"># Output: 24</span><br></pre></td></tr></table></figure><h1 id="set-集合-数据结构"><a href="#set-集合-数据结构" class="headerlink" title="set(集合)数据结构"></a><code>set</code>(集合)数据结构</h1><p><code>set</code>(集合)是一个非常有用的数据结构。它与列表(<code>list</code>)的行为类似，区别在于<code>set</code>不能包含重复的值。<br>这在很多情况下非常有用。例如你可能想检查列表中是否包含重复的元素，你有两个选择，第一个需要使用<code>for</code>循环，就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">some_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'n'</span>]</span><br><span class="line"></span><br><span class="line">duplicates = []</span><br><span class="line"><span class="keyword">for</span> value <span class="keyword">in</span> some_list:</span><br><span class="line">    <span class="keyword">if</span> some_list.count(value) &gt; <span class="number">1</span>:</span><br><span class="line">        <span class="keyword">if</span> value <span class="keyword">not</span> <span class="keyword">in</span> duplicates:</span><br><span class="line">            duplicates.append(value)</span><br><span class="line"></span><br><span class="line">print(duplicates)</span><br><span class="line"><span class="comment">### 输出: ['b', 'n']</span></span><br></pre></td></tr></table></figure><p>但还有一种更简单更优雅的解决方案，那就是使用<code>集合(sets)</code>，你直接这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_list = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'b'</span>, <span class="string">'d'</span>, <span class="string">'m'</span>, <span class="string">'n'</span>, <span class="string">'n'</span>]</span><br><span class="line">duplicates = set([x <span class="keyword">for</span> x <span class="keyword">in</span> some_list <span class="keyword">if</span> some_list.count(x) &gt; <span class="number">1</span>])</span><br><span class="line">print(duplicates)</span><br><span class="line"><span class="comment">### 输出: set(['b', 'n'])</span></span><br></pre></td></tr></table></figure><p>集合还有一些其它方法，下面我们介绍其中一部分。</p><h2 id="交集"><a href="#交集" class="headerlink" title="交集"></a>交集</h2><p>你可以对比两个集合的交集（两个集合中都有的数据），如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">valid = set([<span class="string">'yellow'</span>, <span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'black'</span>])</span><br><span class="line">input_set = set([<span class="string">'red'</span>, <span class="string">'brown'</span>])</span><br><span class="line">print(input_set.intersection(valid))</span><br><span class="line"><span class="comment">### 输出: set(['red'])</span></span><br></pre></td></tr></table></figure><h2 id="差集"><a href="#差集" class="headerlink" title="差集"></a>差集</h2><p>你可以用差集(difference)找出无效的数据，相当于用一个集合减去另一个集合的数据，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">valid = set([<span class="string">'yellow'</span>, <span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>, <span class="string">'black'</span>])</span><br><span class="line">input_set = set([<span class="string">'red'</span>, <span class="string">'brown'</span>])</span><br><span class="line">print(input_set.difference(valid))</span><br><span class="line"><span class="comment">### 输出: set(['brown'])</span></span><br></pre></td></tr></table></figure><p>你也可以用<code>{}</code>符号来创建集合，如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">a_set = &#123;<span class="string">'red'</span>, <span class="string">'blue'</span>, <span class="string">'green'</span>&#125;</span><br><span class="line">print(type(a_set))</span><br><span class="line"><span class="comment">### 输出: &lt;type 'set'&gt;</span></span><br></pre></td></tr></table></figure><p>集合还有一些其它方法，我会建议访问官方文档并做个快速阅读。</p><h1 id="三元运算符"><a href="#三元运算符" class="headerlink" title="三元运算符"></a>三元运算符</h1><p>三元运算符通常在Python里被称为条件表达式，这些表达式基于真(true)/假(false)的条件判断，在Python 2.4以上才有了三元操作。</p><p>下面是一个伪代码和例子：</p><p><strong>伪代码:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#如果条件为真，返回真 否则返回假</span></span><br><span class="line">condition_is_true <span class="keyword">if</span> condition <span class="keyword">else</span> condition_is_false</span><br></pre></td></tr></table></figure><p><strong>例子:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">is_fat = <span class="literal">True</span></span><br><span class="line">state = <span class="string">"fat"</span> <span class="keyword">if</span> is_fat <span class="keyword">else</span> <span class="string">"not fat"</span></span><br></pre></td></tr></table></figure><p>它允许用简单的一行快速判断，而不是使用复杂的多行<code>if</code>语句。<br>这在大多数时候非常有用，而且可以使代码简单可维护。</p><p>另一个晦涩一点的用法比较少见，它使用了元组，请继续看：</p><p><strong>伪代码:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#(返回假，返回真)[真或假]</span></span><br><span class="line">(if_test_is_false, if_test_is_true)[test]</span><br></pre></td></tr></table></figure><p><strong>例子:</strong></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fat = <span class="literal">True</span></span><br><span class="line">fitness = (<span class="string">"skinny"</span>, <span class="string">"fat"</span>)[fat]</span><br><span class="line">print(<span class="string">"Ali is"</span>, fitness)</span><br><span class="line"><span class="comment">#输出: Ali is fat</span></span><br></pre></td></tr></table></figure><p>这之所以能正常工作，是因为在Python中，True等于1，而False等于0，这就相当于在元组中使用0和1来选取数据。</p><p>上面的例子没有被广泛使用，而且Python玩家一般不喜欢那样，因为没有Python味儿(Pythonic)。这样的用法很容易把真正的数据与True/False弄混。</p><p>另外一个不使用元组条件表达式的缘故是因为在元组中会把两个条件都执行，而 <code>if-else</code> 的条件表达式不会这样。</p><p>例如:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">condition = <span class="literal">True</span></span><br><span class="line">print(<span class="number">2</span> <span class="keyword">if</span> condition <span class="keyword">else</span> <span class="number">1</span> / <span class="number">0</span>)</span><br><span class="line"><span class="comment">#输出: 2</span></span><br><span class="line"></span><br><span class="line">print((<span class="number">1</span> / <span class="number">0</span>, <span class="number">2</span>)[condition])</span><br><span class="line"><span class="comment">#输出ZeroDivisionError异常</span></span><br></pre></td></tr></table></figure><p>这是因为在元组中是先建数据，然后用True(1)/False(0)来索引到数据。<br>而<code>if-else</code>条件表达式遵循普通的<code>if-else</code>逻辑树，<br>因此，如果逻辑中的条件异常，或者是重计算型（计算较久）的情况下，最好尽量避免使用元组条件表达式。</p><h1 id="装饰器"><a href="#装饰器" class="headerlink" title="装饰器"></a>装饰器</h1><p>装饰器(Decorators)是Python的一个重要部分。简单地说：他们是修改其他函数的功能的函数。他们有助于让我们的代码更简短，也更Pythonic（Python范儿）。大多数初学者不知道在哪儿使用它们，所以我将要分享下，哪些区域里装饰器可以让你的代码更简洁。</p><p>首先，让我们讨论下如何写你自己的装饰器。</p><p>这可能是最难掌握的概念之一。我们会每次只讨论一个步骤，这样你能完全理解它。</p><h1 id="一切皆对象"><a href="#一切皆对象" class="headerlink" title="一切皆对象"></a>一切皆对象</h1><p>首先我们来理解下Python中的函数</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">(name=<span class="string">"yasoob"</span>)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hi "</span> + name</span><br><span class="line"></span><br><span class="line">print(hi())</span><br><span class="line"><span class="comment"># output: 'hi yasoob'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 我们甚至可以将一个函数赋值给一个变量，比如</span></span><br><span class="line">greet = hi</span><br><span class="line"><span class="comment"># 我们这里没有在使用小括号，因为我们并不是在调用hi函数</span></span><br><span class="line"><span class="comment"># 而是在将它放在greet变量里头。我们尝试运行下这个</span></span><br><span class="line"></span><br><span class="line">print(greet())</span><br><span class="line"><span class="comment"># output: 'hi yasoob'</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 如果我们删掉旧的hi函数，看看会发生什么！</span></span><br><span class="line"><span class="keyword">del</span> hi</span><br><span class="line">print(hi())</span><br><span class="line"><span class="comment">#outputs: NameError</span></span><br><span class="line"></span><br><span class="line">print(greet())</span><br><span class="line"><span class="comment">#outputs: 'hi yasoob'</span></span><br></pre></td></tr></table></figure><h1 id="在函数中定义函数"><a href="#在函数中定义函数" class="headerlink" title="在函数中定义函数"></a>在函数中定义函数</h1><p>刚才那些就是函数的基本知识了。我们来让你的知识更进一步。在Python中我们可以在一个函数中定义另一个函数：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">(name=<span class="string">"yasoob"</span>)</span>:</span></span><br><span class="line">    print(<span class="string">"now you are inside the hi() function"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the greet() function"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">welcome</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the welcome() function"</span></span><br><span class="line"></span><br><span class="line">    print(greet())</span><br><span class="line">    print(welcome())</span><br><span class="line">    print(<span class="string">"now you are back in the hi() function"</span>)</span><br><span class="line"></span><br><span class="line">hi()</span><br><span class="line"><span class="comment">#output:now you are inside the hi() function</span></span><br><span class="line"><span class="comment">#       now you are in the greet() function</span></span><br><span class="line"><span class="comment">#       now you are in the welcome() function</span></span><br><span class="line"><span class="comment">#       now you are back in the hi() function</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># 上面展示了无论何时你调用hi(), greet()和welcome()将会同时被调用。</span></span><br><span class="line"><span class="comment"># 然后greet()和welcome()函数在hi()函数之外是不能访问的，比如：</span></span><br><span class="line"></span><br><span class="line">greet()</span><br><span class="line"><span class="comment">#outputs: NameError: name 'greet' is not defined</span></span><br></pre></td></tr></table></figure><br>那现在我们知道了可以在函数中定义另外的函数。也就是说：我们可以创建嵌套的函数。现在你需要再多学一点，就是函数也能返回函数。</p><h1 id="从函数中返回函数"><a href="#从函数中返回函数" class="headerlink" title="从函数中返回函数"></a>从函数中返回函数</h1><p>其实并不需要在一个函数里去执行另一个函数，我们也可以将其作为输出返回出来：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">(name=<span class="string">"yasoob"</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">greet</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the greet() function"</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">welcome</span><span class="params">()</span>:</span></span><br><span class="line">        <span class="keyword">return</span> <span class="string">"now you are in the welcome() function"</span></span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> name == <span class="string">"yasoob"</span>:</span><br><span class="line">        <span class="keyword">return</span> greet</span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="keyword">return</span> welcome</span><br><span class="line"></span><br><span class="line">a = hi()</span><br><span class="line">print(a)</span><br><span class="line"><span class="comment">#outputs: &lt;function greet at 0x7f2143c01500&gt;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#上面清晰地展示了`a`现在指向到hi()函数中的greet()函数</span></span><br><span class="line"><span class="comment">#现在试试这个</span></span><br><span class="line"></span><br><span class="line">print(a())</span><br><span class="line"><span class="comment">#outputs: now you are in the greet() function</span></span><br></pre></td></tr></table></figure><p>再次看看这个代码。在<code>if/else</code>语句中我们返回<code>greet</code>和<code>welcome</code>，而不是<code>greet()</code>和<code>welcome()</code>。为什么那样？这是因为当你把一对小括号放在后面，这个函数就会执行；然而如果你不放括号在它后面，那它可以被到处传递，并且可以赋值给别的变量而不去执行它。</p><p>你明白了吗？让我再稍微多解释点细节。</p><p>当我们写下<code>a = hi()</code>，<code>hi()</code>会被执行，而由于<code>name</code>参数默认是<em>yasoob</em>，所以函数<code>greet</code>被返回了。如果我们把语句改为<code>a = hi(name = &quot;ali&quot;)</code>，那么<code>welcome</code>函数将被返回。我们还可以打印出<code>hi()()</code>，这会输出<em>now you are in the greet() function</em>。</p><h1 id="将函数作为参数传给另一个函数"><a href="#将函数作为参数传给另一个函数" class="headerlink" title="将函数作为参数传给另一个函数"></a>将函数作为参数传给另一个函数</h1><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">hi</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span> <span class="string">"hi yasoob!"</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">doSomethingBeforeHi</span><span class="params">(func)</span>:</span></span><br><span class="line">    print(<span class="string">"I am doing some boring work before executing hi()"</span>)</span><br><span class="line">    print(func())</span><br><span class="line"></span><br><span class="line">doSomethingBeforeHi(hi)</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing hi()</span></span><br><span class="line"><span class="comment">#        hi yasoob!</span></span><br></pre></td></tr></table></figure><p>现在你已经具备所有必需知识，来进一步学习装饰器真正是什么了。装饰器让你在一个函数的前后去执行代码。</p><h1 id="你的第一个装饰器"><a href="#你的第一个装饰器" class="headerlink" title="你的第一个装饰器"></a>你的第一个装饰器</h1><p>在上一个例子里，其实我们已经创建了一个装饰器！现在我们修改下上一个装饰器，并编写一个稍微更有用点的程序：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span><span class="params">(a_func)</span>:</span></span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"I am doing some boring work before executing a_func()"</span>)</span><br><span class="line"></span><br><span class="line">        a_func()</span><br><span class="line"></span><br><span class="line">        print(<span class="string">"I am doing some boring work after executing a_func()"</span>)</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to remove my foul smell"</span>)</span><br><span class="line"></span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: "I am the function which needs some decoration to remove my foul smell"</span></span><br><span class="line"></span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br><span class="line"><span class="comment">#now a_function_requiring_decoration is wrapped by wrapTheFunction()</span></span><br><span class="line"></span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs:I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#        I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#        I am doing some boring work after executing a_func()</span></span><br></pre></td></tr></table></figure><p>你看明白了吗？我们刚刚应用了之前学习到的原理。这正是python中装饰器做的事情！它们封装一个函数，并且用这样或者那样的方式来修改它的行为。现在你也许疑惑，我们在代码里并没有使用@符号？那只是一个简短的方式来生成一个被装饰的函数。这里是我们如何使用@来运行之前的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Hey you! Decorate me!"""</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to "</span></span><br><span class="line">          <span class="string">"remove my foul smell"</span>)</span><br><span class="line"></span><br><span class="line">a_function_requiring_decoration()</span><br><span class="line"><span class="comment">#outputs: I am doing some boring work before executing a_func()</span></span><br><span class="line"><span class="comment">#         I am the function which needs some decoration to remove my foul smell</span></span><br><span class="line"><span class="comment">#         I am doing some boring work after executing a_func()</span></span><br><span class="line"></span><br><span class="line"><span class="comment">#the @a_new_decorator is just a short way of saying:</span></span><br><span class="line">a_function_requiring_decoration = a_new_decorator(a_function_requiring_decoration)</span><br></pre></td></tr></table></figure><p>希望你现在对Python装饰器的工作原理有一个基本的理解。如果我们运行如下代码会存在一个问题：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">print(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: wrapTheFunction</span></span><br></pre></td></tr></table></figure><p>这并不是我们想要的！Ouput输出应该是“a_function_requiring_decoration”。这里的函数被warpTheFunction替代了。它重写了我们函数的名字和注释文档(docstring)。幸运的是Python提供给我们一个简单的函数来解决这个问题，那就是functools.wraps。我们修改上一个例子来使用functools.wraps：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_new_decorator</span><span class="params">(a_func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(a_func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapTheFunction</span><span class="params">()</span>:</span></span><br><span class="line">        print(<span class="string">"I am doing some boring work before executing a_func()"</span>)</span><br><span class="line">        a_func()</span><br><span class="line">        print(<span class="string">"I am doing some boring work after executing a_func()"</span>)</span><br><span class="line">    <span class="keyword">return</span> wrapTheFunction</span><br><span class="line"></span><br><span class="line"><span class="meta">@a_new_decorator</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">a_function_requiring_decoration</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="string">"""Hey yo! Decorate me!"""</span></span><br><span class="line">    print(<span class="string">"I am the function which needs some decoration to "</span></span><br><span class="line">          <span class="string">"remove my foul smell"</span>)</span><br><span class="line"></span><br><span class="line">print(a_function_requiring_decoration.__name__)</span><br><span class="line"><span class="comment"># Output: a_function_requiring_decoration</span></span><br></pre></td></tr></table></figure><p>现在好多了。我们接下来学习装饰器的一些常用场景。</p><p>蓝本规范:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">decorator_name</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> can_run:</span><br><span class="line">            <span class="keyword">return</span> <span class="string">"Function will not run"</span></span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br><span class="line"></span><br><span class="line"><span class="meta">@decorator_name</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">func</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">return</span>(<span class="string">"Function is running"</span>)</span><br><span class="line"></span><br><span class="line">can_run = <span class="literal">True</span></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># Output: Function is running</span></span><br><span class="line"></span><br><span class="line">can_run = <span class="literal">False</span></span><br><span class="line">print(func())</span><br><span class="line"><span class="comment"># Output: Function will not run</span></span><br></pre></td></tr></table></figure><br>注意：@wraps接受一个函数来进行装饰，并加入了复制函数名称、注释文档、参数列表等等的功能。这可以让我们在装饰器里面访问在装饰之前的函数的属性。</p><h1 id="使用场景"><a href="#使用场景" class="headerlink" title="使用场景"></a>使用场景</h1><p>现在我们来看一下装饰器在哪些地方特别耀眼，以及使用它可以让一些事情管理起来变得更简单。</p><h1 id="授权-Authorization"><a href="#授权-Authorization" class="headerlink" title="授权(Authorization)"></a>授权(Authorization)</h1><p>装饰器能有助于检查某个人是否被授权去使用一个web应用的端点(endpoint)。它们被大量使用于Flask和Django web框架中。这里是一个例子来使用基于装饰器的授权：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">requires_auth</span><span class="params">(f)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(f)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">decorated</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        auth = request.authorization</span><br><span class="line">        <span class="keyword">if</span> <span class="keyword">not</span> auth <span class="keyword">or</span> <span class="keyword">not</span> check_auth(auth.username, auth.password):</span><br><span class="line">            authenticate()</span><br><span class="line">        <span class="keyword">return</span> f(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> decorated</span><br></pre></td></tr></table></figure><h1 id="日志-Logging"><a href="#日志-Logging" class="headerlink" title="日志(Logging)"></a>日志(Logging)</h1><p>日志是装饰器运用的另一个亮点。这是个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logit</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">    @wraps(func)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">with_logging</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">        print(func.__name__ + <span class="string">" was called"</span>)</span><br><span class="line">        <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">    <span class="keyword">return</span> with_logging</span><br><span class="line"></span><br><span class="line"><span class="meta">@logit</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">addition_func</span><span class="params">(x)</span>:</span></span><br><span class="line">   <span class="string">"""Do some math."""</span></span><br><span class="line">   <span class="keyword">return</span> x + x</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">result = addition_func(<span class="number">4</span>)</span><br><span class="line"><span class="comment"># Output: addition_func was called</span></span><br></pre></td></tr></table></figure></p><p>我敢肯定你已经在思考装饰器的一个其他聪明用法了。</p><h1 id="带参数的装饰器"><a href="#带参数的装饰器" class="headerlink" title="带参数的装饰器"></a>带参数的装饰器</h1><p>来想想这个问题，难道<code>@wraps</code>不也是个装饰器吗？但是，它接收一个参数，就像任何普通的函数能做的那样。那么，为什么我们不也那样做呢？</p><p>这是因为，当你使用<code>@my_decorator</code>语法时，你是在应用一个以单个函数作为参数的一个包裹函数。记住，Python里每个东西都是一个对象，而且这包括函数！记住了这些，我们可以编写一下能返回一个包裹函数的函数。</p><h1 id="在函数中嵌入装饰器"><a href="#在函数中嵌入装饰器" class="headerlink" title="在函数中嵌入装饰器"></a>在函数中嵌入装饰器</h1><p>我们回到日志的例子，并创建一个包裹函数，能让我们指定一个用于输出的日志文件。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">logit</span><span class="params">(logfile=<span class="string">'out.log'</span>)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">logging_decorator</span><span class="params">(func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log_string = func.__name__ + <span class="string">" was called"</span></span><br><span class="line">            print(log_string)</span><br><span class="line">            <span class="comment"># 打开logfile，并写入内容</span></span><br><span class="line">            <span class="keyword">with</span> open(logfile, <span class="string">'a'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">                <span class="comment"># 现在将日志打到指定的logfile</span></span><br><span class="line">                opened_file.write(log_string + <span class="string">'\n'</span>)</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line">    <span class="keyword">return</span> logging_decorator</span><br><span class="line"></span><br><span class="line"><span class="meta">@logit()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">myfunc1()</span><br><span class="line"><span class="comment"># Output: myfunc1 was called</span></span><br><span class="line"><span class="comment"># 现在一个叫做 out.log 的文件出现了，里面的内容就是上面的字符串</span></span><br><span class="line"></span><br><span class="line"><span class="meta">@logit(logfile='func2.log')</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc2</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br><span class="line"></span><br><span class="line">myfunc2()</span><br><span class="line"><span class="comment"># Output: myfunc2 was called</span></span><br><span class="line"><span class="comment"># 现在一个叫做 func2.log 的文件出现了，里面的内容就是上面的字符串</span></span><br></pre></td></tr></table></figure><h1 id="装饰器类"><a href="#装饰器类" class="headerlink" title="装饰器类"></a>装饰器类</h1><p>现在我们有了能用于正式环境的<code>logit</code>装饰器，但当我们的应用的某些部分还比较脆弱时，异常也许是需要更紧急关注的事情。比方说有时你只想打日志到一个文件。而有时你想把引起你注意的问题发送到一个email，同时也保留日志，留个记录。这是一个使用继承的场景，但目前为止我们只看到过用来构建装饰器的函数。</p><p>幸运的是，类也可以用来构建装饰器。那我们现在以一个类而不是一个函数的方式，来重新构建<code>logit</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">logit</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, logfile=<span class="string">'out.log'</span>)</span>:</span></span><br><span class="line">        self.logfile = logfile</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__call__</span><span class="params">(self, func)</span>:</span></span><br><span class="line"><span class="meta">        @wraps(func)</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">wrapped_function</span><span class="params">(*args, **kwargs)</span>:</span></span><br><span class="line">            log_string = func.__name__ + <span class="string">" was called"</span></span><br><span class="line">            print(log_string)</span><br><span class="line">            <span class="comment"># 打开logfile并写入</span></span><br><span class="line">            <span class="keyword">with</span> open(self.logfile, <span class="string">'a'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">                <span class="comment"># 现在将日志打到指定的文件</span></span><br><span class="line">                opened_file.write(log_string + <span class="string">'\n'</span>)</span><br><span class="line">            <span class="comment"># 现在，发送一个通知</span></span><br><span class="line">            self.notify()</span><br><span class="line">            <span class="keyword">return</span> func(*args, **kwargs)</span><br><span class="line">        <span class="keyword">return</span> wrapped_function</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># logit只打日志，不做别的</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>这个实现有一个附加优势，在于比嵌套函数的方式更加整洁，而且包裹一个函数还是使用跟以前一样的语法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@logit()</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">myfunc1</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>现在，我们给<code>logit</code>创建子类，来添加email的功能(虽然email这个话题不会在这里展开)。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">email_logit</span><span class="params">(logit)</span>:</span></span><br><span class="line">    <span class="string">'''</span></span><br><span class="line"><span class="string">    一个logit的实现版本，可以在函数调用时发送email给管理员</span></span><br><span class="line"><span class="string">    '''</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, email=<span class="string">'admin@myproject.com'</span>, *args, **kwargs)</span>:</span></span><br><span class="line">        self.email = email</span><br><span class="line">        super(email_logit, self).__init__(*args, **kwargs)</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">notify</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="comment"># 发送一封email到self.email</span></span><br><span class="line">        <span class="comment"># 这里就不做实现了</span></span><br><span class="line">        <span class="keyword">pass</span></span><br></pre></td></tr></table></figure><p>从现在起，<code>@email_logit</code>将会和<code>@logit</code>产生同样的效果，但是在打日志的基础上，还会多发送一封邮件给管理员。</p><h1 id="Global和Return"><a href="#Global和Return" class="headerlink" title="Global和Return"></a>Global和Return</h1><p>你也许遇到过, python中一些函数在最尾部有一个<code>return</code>关键字。你知道它是干嘛吗？它和其他语言的<code>return</code>类似。我们来检查下这个小函数：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(value1, value2)</span>:</span></span><br><span class="line">    <span class="keyword">return</span> value1 + value2</span><br><span class="line"></span><br><span class="line">result = add(<span class="number">3</span>, <span class="number">5</span>)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># Output: 8</span></span><br></pre></td></tr></table></figure><p>上面这个函数将两个值作为输入，然后输出它们相加之和。我们也可以这样做：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(value1,value2)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> result</span><br><span class="line">    result = value1 + value2</span><br><span class="line"></span><br><span class="line">add(<span class="number">3</span>,<span class="number">5</span>)</span><br><span class="line">print(result)</span><br><span class="line"><span class="comment"># Output: 8</span></span><br></pre></td></tr></table></figure></p><p>那首先我们来谈谈第一段也就是包含<code>return</code>关键字的代码。那个函数把值赋给了调用它的变量（也就是例子中的result变量）。<br>大多数境况下，你并不需要使用<code>global</code>关键字。然而我们也来检查下另外一段也就是包含<code>global</code>关键字的代码。<br>那个函数生成了一个<code>global</code>（全局）变量result。</p><p><code>global</code>在这的意思是什么？<code>global</code>变量意味着我们可以在函数以外的区域都能访问这个变量。让我们通过一个例子来证明它：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 首先，是没有使用global变量</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(value1, value2)</span>:</span></span><br><span class="line">    result = value1 + value2</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">print(result)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Oh 糟了，我们遇到异常了。为什么会这样？</span></span><br><span class="line"><span class="comment"># python解释器报错说没有一个叫result的变量。</span></span><br><span class="line"><span class="comment"># 这是因为result变量只能在创建它的函数内部才允许访问，除非它是全局的(global)。</span></span><br><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">""</span>, line <span class="number">1</span>, <span class="keyword">in</span></span><br><span class="line">    result</span><br><span class="line">NameError: name <span class="string">'result'</span> <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line"></span><br><span class="line"><span class="comment"># 现在我们运行相同的代码，不过是在将result变量设为global之后</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add</span><span class="params">(value1, value2)</span>:</span></span><br><span class="line">    <span class="keyword">global</span> result</span><br><span class="line">    result = value1 + value2</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">4</span>)</span><br><span class="line">print(result)</span><br><span class="line"><span class="number">6</span></span><br></pre></td></tr></table></figure><p>如我们所愿，在第二次运行时没有异常了。在实际的编程时，你应该试着避开<code>global</code>关键字，它只会让生活变得艰难，因为它引入了多余的变量到全局作用域了。</p><h1 id="多个return值"><a href="#多个return值" class="headerlink" title="多个return值"></a>多个return值</h1><p>那如果你想从一个函数里返回两个变量而不是一个呢？<br>新手们有若干种方法。最著名的方法，是使用<code>global</code>关键字。让我们看下这个没用的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">profile</span><span class="params">()</span>:</span></span><br><span class="line">    <span class="keyword">global</span> name</span><br><span class="line">    <span class="keyword">global</span> age</span><br><span class="line">    name = <span class="string">"Danny"</span></span><br><span class="line">    age = <span class="number">30</span></span><br><span class="line"></span><br><span class="line">profile()</span><br><span class="line">print(name)</span><br><span class="line"><span class="comment"># Output: Danny</span></span><br><span class="line"></span><br><span class="line">print(age)</span><br><span class="line"><span class="comment"># Output: 30</span></span><br></pre></td></tr></table></figure><p><strong>注意:</strong> 不要试着使用上述方法。重要的事情说三遍，不要试着使用上述方法！</p><p>有些人试着在函数结束时，返回一个包含多个值的<code>tuple</code>(元组)，<code>list</code>(列表)或者<code>dict</code>(字典),来解决这个问题。这是一种可行的方式，而且使用起来像一个黑魔法：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">profile</span><span class="params">()</span>:</span></span><br><span class="line">    name = <span class="string">"Danny"</span></span><br><span class="line">    age = <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> (name, age)</span><br><span class="line"></span><br><span class="line">profile_data = profile()</span><br><span class="line">print(profile_data[<span class="number">0</span>])</span><br><span class="line"><span class="comment"># Output: Danny</span></span><br><span class="line"></span><br><span class="line">print(profile_data[<span class="number">1</span>])</span><br><span class="line"><span class="comment"># Output: 30</span></span><br></pre></td></tr></table></figure><br>或者按照更常见的惯例：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">profile</span><span class="params">()</span>:</span></span><br><span class="line">    name = <span class="string">"Danny"</span></span><br><span class="line">    age = <span class="number">30</span></span><br><span class="line">    <span class="keyword">return</span> name, age</span><br></pre></td></tr></table></figure><br>这是一种比列表和字典更好的方式。不要使用<code>global</code>关键字，除非你知道你正在做什么。<code>global</code>也许在某些场景下是一个更好的选择（但其中大多数情况都不是）。</p><h1 id="对象变动-Mutation"><a href="#对象变动-Mutation" class="headerlink" title="对象变动(Mutation)"></a>对象变动(Mutation)</h1><p>Python中可变(<strong>mutable</strong>)与不可变(<strong>immutable</strong>)的数据类型让新手很是头痛。简单的说，可变(mutable)意味着”可以被改动”，而不可变(immutable)的意思是“常量(constant)”。想把脑筋转动起来吗？考虑下这个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">foo = [<span class="string">'hi'</span>]</span><br><span class="line">print(foo)</span><br><span class="line"><span class="comment"># Output: ['hi']</span></span><br><span class="line"></span><br><span class="line">bar = foo</span><br><span class="line">bar += [<span class="string">'bye'</span>]</span><br><span class="line">print(foo)</span><br><span class="line"><span class="comment"># Output: ['hi', 'bye']</span></span><br></pre></td></tr></table></figure><p>刚刚发生了什么？我们预期的不是那样！我们期望看到是这样的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo = [<span class="string">'hi'</span>]</span><br><span class="line">print(foo)</span><br><span class="line"><span class="comment"># Output: ['hi']</span></span><br><span class="line"></span><br><span class="line">bar = foo</span><br><span class="line">bar += [<span class="string">'bye'</span>]</span><br><span class="line"></span><br><span class="line">print(foo)</span><br><span class="line"><span class="comment"># Output: ['hi']</span></span><br><span class="line"></span><br><span class="line">print(bar)</span><br><span class="line"><span class="comment"># Output: ['hi', 'bye']</span></span><br></pre></td></tr></table></figure><p>这不是一个bug。这是对象可变性(<strong>mutability</strong>)在作怪。每当你将一个变量赋值为另一个可变类型的变量时，对这个数据的任意改动会同时反映到这两个变量上去。新变量只不过是老变量的一个别名而已。这个情况只是针对可变数据类型。下面的函数和可变数据类型让你一下就明白了：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to</span><span class="params">(num, target=[])</span>:</span></span><br><span class="line">    target.append(num)</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line"></span><br><span class="line">add_to(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># Output: [1]</span></span><br><span class="line"></span><br><span class="line">add_to(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Output: [1, 2]</span></span><br><span class="line"></span><br><span class="line">add_to(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Output: [1, 2, 3]</span></span><br></pre></td></tr></table></figure><p>你可能预期它表现的不是这样子。你可能希望，当你调用<code>add_to</code>时，有一个新的列表被创建，就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to</span><span class="params">(num, target=[])</span>:</span></span><br><span class="line">    target.append(num)</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line"></span><br><span class="line">add_to(<span class="number">1</span>)</span><br><span class="line"><span class="comment"># Output: [1]</span></span><br><span class="line"></span><br><span class="line">add_to(<span class="number">2</span>)</span><br><span class="line"><span class="comment"># Output: [2]</span></span><br><span class="line"></span><br><span class="line">add_to(<span class="number">3</span>)</span><br><span class="line"><span class="comment"># Output: [3]</span></span><br></pre></td></tr></table></figure><p>啊哈！这次又没有达到预期，是列表的可变性在作怪。在Python中当函数被定义时，默认参数只会运算一次，而不是每次被调用时都会重新运算。你应该永远不要定义可变类型的默认参数，除非你知道你正在做什么。你应该像这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">add_to</span><span class="params">(element, target=None)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> target <span class="keyword">is</span> <span class="literal">None</span>:</span><br><span class="line">        target = []</span><br><span class="line">    target.append(element)</span><br><span class="line">    <span class="keyword">return</span> target</span><br><span class="line">``` </span><br><span class="line">现在每当你在调用这个函数不传入```target```参数的时候，一个新的列表会被创建。举个例子：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line">add_to(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># Output: [42]</span></span><br><span class="line"></span><br><span class="line">add_to(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># Output: [42]</span></span><br><span class="line"></span><br><span class="line">add_to(<span class="number">42</span>)</span><br><span class="line"><span class="comment"># Output: [42]</span></span><br></pre></td></tr></table></figure><h1 id="slots-魔法"><a href="#slots-魔法" class="headerlink" title="__slots__魔法"></a><code>__slots__</code>魔法</h1><p>在Python中，每个类都有实例属性。默认情况下Python用一个字典来保存一个对象的实例属性。这非常有用，因为它允许我们在运行时去设置任意的新属性。</p><p>然而，对于有着已知属性的小类来说，它可能是个瓶颈。这个字典浪费了很多内存。Python不能在对象创建时直接分配一个固定量的内存来保存所有的属性。因此如果你创建许多对象（我指的是成千上万个），它会消耗掉很多内存。<br>不过还是有一个方法来规避这个问题。这个方法需要使用<code>__slots__</code>来告诉Python不要使用字典，而且只给一个固定集合的属性分配空间。</p><p>这里是一个使用与不使用<code>__slots__</code>的例子：</p><ul><li><p>不使用 <code>__slots__</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, identifier)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.identifier = identifier</span><br><span class="line">        self.set_up()</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li><li><p>使用 <code>__slots__</code>:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">    __slots__ = [<span class="string">'name'</span>, <span class="string">'identifier'</span>]</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, identifier)</span>:</span></span><br><span class="line">        self.name = name</span><br><span class="line">        self.identifier = identifier</span><br><span class="line">        self.set_up()</span><br><span class="line">    <span class="comment"># ...</span></span><br></pre></td></tr></table></figure></li></ul><p>第二段代码会为你的内存减轻负担。通过这个技巧，有些人已经看到内存占用率几乎40%~50%的减少。</p><p>稍微备注一下，你也许需要试一下PyPy。它已经默认地做了所有这些优化。</p><p>以下你可以看到一个例子，它用IPython来展示在有与没有<code>__slots__</code>情况下的精确内存占用，感谢 <a href="https://github.com/ianozsvald/ipython_memory_usage" target="_blank" rel="noopener">https://github.com/ianozsvald/ipython_memory_usage</a></p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><span class="line">Python <span class="number">3.4</span><span class="number">.3</span> (default, Jun  <span class="number">6</span> <span class="number">2015</span>, <span class="number">13</span>:<span class="number">32</span>:<span class="number">34</span>)</span><br><span class="line">Type <span class="string">"copyright"</span>, <span class="string">"credits"</span> <span class="keyword">or</span> <span class="string">"license"</span> <span class="keyword">for</span> more information.</span><br><span class="line"></span><br><span class="line">IPython <span class="number">4.0</span><span class="number">.0</span> -- An enhanced Interactive Python.</span><br><span class="line">?         -&gt; Introduction and overview of IPython's features.</span><br><span class="line">%quickref -&gt; Quick reference.</span><br><span class="line">help      -&gt; Python's own help system.</span><br><span class="line">object?   -&gt; Details about 'object', use 'object??' for extra details.</span><br><span class="line"></span><br><span class="line">In [<span class="number">1</span>]: <span class="keyword">import</span> ipython_memory_usage.ipython_memory_usage <span class="keyword">as</span> imu</span><br><span class="line"></span><br><span class="line">In [<span class="number">2</span>]: imu.start_watching_memory()</span><br><span class="line">In [<span class="number">2</span>] used <span class="number">0.0000</span> MiB RAM <span class="keyword">in</span> <span class="number">5.31</span>s, peaked <span class="number">0.00</span> MiB above current, total RAM usage <span class="number">15.57</span> MiB</span><br><span class="line"></span><br><span class="line">In [<span class="number">3</span>]: %cat slots.py</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">        __slots__ = [<span class="string">'name'</span>, <span class="string">'identifier'</span>]</span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, identifier)</span>:</span></span><br><span class="line">                self.name = name</span><br><span class="line">                self.identifier = identifier</span><br><span class="line"></span><br><span class="line">num = <span class="number">1024</span>*<span class="number">256</span></span><br><span class="line">x = [MyClass(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(num)]</span><br><span class="line">In [<span class="number">3</span>] used <span class="number">0.2305</span> MiB RAM <span class="keyword">in</span> <span class="number">0.12</span>s, peaked <span class="number">0.00</span> MiB above current, total RAM usage <span class="number">15.80</span> MiB</span><br><span class="line"></span><br><span class="line">In [<span class="number">4</span>]: <span class="keyword">from</span> slots <span class="keyword">import</span> *</span><br><span class="line">In [<span class="number">4</span>] used <span class="number">9.3008</span> MiB RAM <span class="keyword">in</span> <span class="number">0.72</span>s, peaked <span class="number">0.00</span> MiB above current, total RAM usage <span class="number">25.10</span> MiB</span><br><span class="line"></span><br><span class="line">In [<span class="number">5</span>]: %cat noslots.py</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span><span class="params">(object)</span>:</span></span><br><span class="line">        <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, name, identifier)</span>:</span></span><br><span class="line">                self.name = name</span><br><span class="line">                self.identifier = identifier</span><br><span class="line"></span><br><span class="line">num = <span class="number">1024</span>*<span class="number">256</span></span><br><span class="line">x = [MyClass(<span class="number">1</span>,<span class="number">1</span>) <span class="keyword">for</span> i <span class="keyword">in</span> range(num)]</span><br><span class="line">In [<span class="number">5</span>] used <span class="number">0.1758</span> MiB RAM <span class="keyword">in</span> <span class="number">0.12</span>s, peaked <span class="number">0.00</span> MiB above current, total RAM usage <span class="number">25.28</span> MiB</span><br><span class="line"></span><br><span class="line">In [<span class="number">6</span>]: <span class="keyword">from</span> noslots <span class="keyword">import</span> *</span><br><span class="line">In [<span class="number">6</span>] used <span class="number">22.6680</span> MiB RAM <span class="keyword">in</span> <span class="number">0.80</span>s, peaked <span class="number">0.00</span> MiB above current, total RAM usage <span class="number">47.95</span> MiB</span><br></pre></td></tr></table></figure><h1 id="虚拟环境-virtualenv"><a href="#虚拟环境-virtualenv" class="headerlink" title="虚拟环境(virtualenv)"></a>虚拟环境(virtualenv)</h1><h2 id="你听说过virtualenv吗？"><a href="#你听说过virtualenv吗？" class="headerlink" title="你听说过virtualenv吗？"></a>你听说过<code>virtualenv</code>吗？</h2><p>如果你是一位初学者，你可能没有听说过<code>virtualenv</code>；但如果你是位经验丰富的程序员，那么它可能是你的工具集的重要组成部分。</p><h2 id="那么，什么是virtualenv"><a href="#那么，什么是virtualenv" class="headerlink" title="那么，什么是virtualenv?"></a>那么，什么是<code>virtualenv</code>?</h2><p><code>Virtualenv</code> 是一个工具，它能够帮我们创建一个独立(隔离)的Python环境。想象你有一个应用程序，依赖于版本为2的第三方模块，但另一个程序依赖的版本是3，请问你如何使用和开发这些应用程序？</p><p>如果你把一切都安装到了<code>/usr/lib/python2.7/site-packages</code>（或者其它平台的标准位置），那很容易出现某个模块被升级而你却不知道的情况。</p><p>在另一种情况下，想象你有一个已经开发完成的程序，但是你不想更新它所依赖的第三方模块版本；但你已经开始另一个程序，需要这些第三方模块的版本。</p><h2 id="用什么方式解决？"><a href="#用什么方式解决？" class="headerlink" title="用什么方式解决？"></a>用什么方式解决？</h2><p>使用<code>virtualenv</code>！针对每个程序创建独立（隔离）的Python环境，而不是在全局安装所依赖的模块。</p><p>要安装它，只需要在命令行中输入以下命令：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ pip install virtualenv</span><br></pre></td></tr></table></figure><p>最重要的命令是：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ virtualenv myproject</span><br><span class="line">$ <span class="built_in">source</span> myproject/bin/activate</span><br></pre></td></tr></table></figure><p>执行第一个命令在<code>myproject</code>文件夹创建一个隔离的virtualenv环境，第二个命令激活这个隔离的环境(<code>virtualenv</code>)。</p><p>在创建virtualenv时，你必须做出决定：这个virtualenv是使用系统全局的模块呢？还是只使用这个virtualenv内的模块。<br>默认情况下，virtualenv不会使用系统全局模块。</p><p>如果你想让你的virtualenv使用系统全局模块，请使用<code>--system-site-packages</code>参数创建你的virtualenv，例如：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">virtualenv --system-site-packages mycoolproject</span><br></pre></td></tr></table></figure><p>使用以下命令可以退出这个virtualenv:</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ deactivate</span><br></pre></td></tr></table></figure><p>运行之后将恢复使用你系统全局的Python模块。</p><h1 id="福利"><a href="#福利" class="headerlink" title="福利"></a>福利</h1><p>你可以使用<code>smartcd</code>来帮助你管理你的环境，当你切换目录时，它可以帮助你激活（activate）和退出（deactivate）你的virtualenv。我已经用了很多次，很喜欢它。你可以在github(<a href="https://github.com/cxreg/smartcd" target="_blank" rel="noopener">https://github.com/cxreg/smartcd</a>) 上找到更多关于它的资料。</p><p>这只是一个virtualenv的简短介绍，你可以在 <a href="http://docs.python-guide.org/en/latest/dev/virtualenvs/" target="_blank" rel="noopener">http://docs.python-guide.org/en/latest/dev/virtualenvs/</a> 找到更多信息。</p><h1 id="容器-Collections"><a href="#容器-Collections" class="headerlink" title="容器(Collections)"></a>容器(<code>Collections</code>)</h1><p>Python附带一个模块，它包含许多容器数据类型，名字叫作<code>collections</code>。我们将讨论它的作用和用法。</p><p>我们将讨论的是：</p><ul><li>defaultdict</li><li>counter</li><li>deque</li><li>namedtuple</li><li>enum.Enum (包含在Python 3.4以上)</li></ul><h1 id="defaultdict"><a href="#defaultdict" class="headerlink" title="defaultdict"></a>defaultdict</h1><p>我个人使用<code>defaultdict</code>较多，与<code>dict</code>类型不同，你不需要检查<strong>key</strong>是否存在，所以我们能这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> defaultdict</span><br><span class="line"></span><br><span class="line">colours = (</span><br><span class="line">    (<span class="string">'Yasoob'</span>, <span class="string">'Yellow'</span>),</span><br><span class="line">    (<span class="string">'Ali'</span>, <span class="string">'Blue'</span>),</span><br><span class="line">    (<span class="string">'Arham'</span>, <span class="string">'Green'</span>),</span><br><span class="line">    (<span class="string">'Ali'</span>, <span class="string">'Black'</span>),</span><br><span class="line">    (<span class="string">'Yasoob'</span>, <span class="string">'Red'</span>),</span><br><span class="line">    (<span class="string">'Ahmed'</span>, <span class="string">'Silver'</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">favourite_colours = defaultdict(list)</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> name, colour <span class="keyword">in</span> colours:</span><br><span class="line">    favourite_colours[name].append(colour)</span><br><span class="line"></span><br><span class="line">print(favourite_colours)</span><br></pre></td></tr></table></figure><h2 id="运行输出"><a href="#运行输出" class="headerlink" title="运行输出"></a>运行输出</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># defaultdict(&lt;type 'list'&gt;,</span></span><br><span class="line"><span class="comment">#    &#123;'Arham': ['Green'],</span></span><br><span class="line"><span class="comment">#     'Yasoob': ['Yellow', 'Red'],</span></span><br><span class="line"><span class="comment">#     'Ahmed': ['Silver'],</span></span><br><span class="line"><span class="comment">#     'Ali': ['Blue', 'Black']</span></span><br><span class="line"><span class="comment"># &#125;)</span></span><br></pre></td></tr></table></figure><p>另一种重要的是例子就是：当你在一个字典中对一个键进行嵌套赋值时，如果这个键不存在，会触发<code>keyError</code>异常。 <code>defaultdict</code>允许我们用一个聪明的方式绕过这个问题。<br> 首先我分享一个使用<code>dict</code>触发<code>KeyError</code>的例子，然后提供一个使用<code>defaultdict</code>的解决方案。</p><p><strong>问题</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">some_dict = &#123;&#125;</span><br><span class="line">some_dict[<span class="string">'colours'</span>][<span class="string">'favourite'</span>] = <span class="string">"yellow"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 异常输出：KeyError: 'colours'</span></span><br></pre></td></tr></table></figure><p><strong>解决方案</strong>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> collections</span><br><span class="line">tree = <span class="keyword">lambda</span>: collections.defaultdict(tree)</span><br><span class="line">some_dict = tree()</span><br><span class="line">some_dict[<span class="string">'colours'</span>][<span class="string">'favourite'</span>] = <span class="string">"yellow"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 运行正常</span></span><br></pre></td></tr></table></figure><p>你可以用<code>json.dumps</code>打印出<code>some_dict</code>，例如：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> json</span><br><span class="line">print(json.dumps(some_dict))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: &#123;"colours": &#123;"favourite": "yellow"&#125;&#125;</span></span><br></pre></td></tr></table></figure></p><h1 id="counter"><a href="#counter" class="headerlink" title="counter"></a>counter</h1><p>Counter是一个计数器，它可以帮助我们针对某项数据进行计数。比如它可以用来计算每个人喜欢多少种颜色：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> Counter</span><br><span class="line"></span><br><span class="line">colours = (</span><br><span class="line">    (<span class="string">'Yasoob'</span>, <span class="string">'Yellow'</span>),</span><br><span class="line">    (<span class="string">'Ali'</span>, <span class="string">'Blue'</span>),</span><br><span class="line">    (<span class="string">'Arham'</span>, <span class="string">'Green'</span>),</span><br><span class="line">    (<span class="string">'Ali'</span>, <span class="string">'Black'</span>),</span><br><span class="line">    (<span class="string">'Yasoob'</span>, <span class="string">'Red'</span>),</span><br><span class="line">    (<span class="string">'Ahmed'</span>, <span class="string">'Silver'</span>),</span><br><span class="line">)</span><br><span class="line"></span><br><span class="line">favs = Counter(name <span class="keyword">for</span> name, colour <span class="keyword">in</span> colours)</span><br><span class="line">print(favs)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出:</span></span><br><span class="line"><span class="comment">## Counter(&#123;</span></span><br><span class="line"><span class="comment">##     'Yasoob': 2,</span></span><br><span class="line"><span class="comment">##     'Ali': 2,</span></span><br><span class="line"><span class="comment">##     'Arham': 1,</span></span><br><span class="line"><span class="comment">##     'Ahmed': 1</span></span><br><span class="line"><span class="comment">##  &#125;)</span></span><br></pre></td></tr></table></figure><p>我们也可以在利用它统计一个文件，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'filename'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    line_count = Counter(f)</span><br><span class="line">print(line_count)</span><br></pre></td></tr></table></figure><h1 id="deque"><a href="#deque" class="headerlink" title="deque"></a>deque</h1><p>deque提供了一个双端队列，你可以从头/尾两端添加或删除元素。要想使用它，首先我们要从<code>collections</code>中导入<code>deque</code>模块：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> deque</span><br></pre></td></tr></table></figure><p>现在，你可以创建一个<code>deque</code>对象。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = deque()</span><br></pre></td></tr></table></figure><p>它的用法就像python的<code>list</code>，并且提供了类似的方法，例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">d = deque()</span><br><span class="line">d.append(<span class="string">'1'</span>)</span><br><span class="line">d.append(<span class="string">'2'</span>)</span><br><span class="line">d.append(<span class="string">'3'</span>)</span><br><span class="line"></span><br><span class="line">print(len(d))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: 3</span></span><br><span class="line"></span><br><span class="line">print(d[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: '1'</span></span><br><span class="line"></span><br><span class="line">print(d[<span class="number">-1</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: '3'</span></span><br></pre></td></tr></table></figure><p>你可以从两端取出(pop)数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">d = deque(range(<span class="number">5</span>))</span><br><span class="line">print(len(d))</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: 5</span></span><br><span class="line"></span><br><span class="line">d.popleft()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: 0</span></span><br><span class="line"></span><br><span class="line">d.pop()</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: 4</span></span><br><span class="line"></span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: deque([1, 2, 3])</span></span><br></pre></td></tr></table></figure><p>我们也可以限制这个列表的大小，当超出你设定的限制时，数据会从对队列另一端被挤出去(pop)。<br>最好的解释是给出一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">d = deque(maxlen=<span class="number">30</span>)</span><br></pre></td></tr></table></figure><p>现在当你插入30条数据时，最左边一端的数据将从队列中删除。</p><p>你还可以从任一端扩展这个队列中的数据：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">d = deque([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>])</span><br><span class="line">d.extendleft([<span class="number">0</span>])</span><br><span class="line">d.extend([<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>])</span><br><span class="line">print(d)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: deque([0, 1, 2, 3, 4, 5, 6, 7, 8])</span></span><br></pre></td></tr></table></figure><h1 id="namedtuple"><a href="#namedtuple" class="headerlink" title="namedtuple"></a>namedtuple</h1><p>您可能已经熟悉元组。<br>一个元组是一个不可变的列表，你可以存储一个数据的序列，它和命名元组(<code>namedtuples</code>)非常像，但有几个关键的不同。<br>主要相似点是都不像列表，你不能修改元组中的数据。为了获取元组中的数据，你需要使用整数作为索引：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">man = (<span class="string">'Ali'</span>, <span class="number">30</span>)</span><br><span class="line">print(man[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: Ali</span></span><br></pre></td></tr></table></figure><p>嗯，那<code>namedtuples</code>是什么呢？它把元组变成一个针对简单任务的容器。你不必使用整数索引来访问一个<code>namedtuples</code>的数据。你可以像字典(<code>dict</code>)一样访问<code>namedtuples</code>，但<code>namedtuples</code>是不可变的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">perry = Animal(name=<span class="string">"perry"</span>, age=<span class="number">31</span>, type=<span class="string">"cat"</span>)</span><br><span class="line"></span><br><span class="line">print(perry)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: Animal(name='perry', age=31, type='cat')</span></span><br><span class="line"></span><br><span class="line">print(perry.name)</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: 'perry'</span></span><br></pre></td></tr></table></figure><p>现在你可以看到，我们可以用名字来访问<code>namedtuple</code>中的数据。我们再继续分析它。一个命名元组(<code>namedtuple</code>)有两个必需的参数。它们是元组名称和字段名称。</p><p>在上面的例子中，我们的元组名称是<code>Animal</code>，字段名称是’name’，’age’和’type’。<br><code>namedtuple</code>让你的元组变得<strong>自文档</strong>了。你只要看一眼就很容易理解代码是做什么的。<br>你也不必使用整数索引来访问一个命名元组，这让你的代码更易于维护。<br>而且，<strong><code>namedtuple</code>的每个实例没有对象字典</strong>，所以它们很轻量，与普通的元组比，并不需要更多的内存。这使得它们比字典更快。</p><p>然而，要记住它是一个元组，属性值在<code>namedtuple</code>中是不可变的，所以下面的代码不能工作：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">perry = Animal(name=<span class="string">"perry"</span>, age=<span class="number">31</span>, type=<span class="string">"cat"</span>)</span><br><span class="line">perry.age = <span class="number">42</span></span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出:</span></span><br><span class="line"><span class="comment">## Traceback (most recent call last):</span></span><br><span class="line"><span class="comment">##     File "", line 1, in</span></span><br><span class="line"><span class="comment">## AttributeError: can't set attribute</span></span><br></pre></td></tr></table></figure><p>你应该使用命名元组来让代码<strong>自文档</strong>，<strong>它们向后兼容于普通的元组</strong>，这意味着你可以既使用整数索引，也可以使用名称来访问<code>namedtuple</code>：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">perry = Animal(name=<span class="string">"perry"</span>, age=<span class="number">31</span>, type=<span class="string">"cat"</span>)</span><br><span class="line">print(perry[<span class="number">0</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: perry</span></span><br></pre></td></tr></table></figure><p>最后，你可以将一个命名元组转换为字典，方法如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"></span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">perry = Animal(name=<span class="string">"Perry"</span>, age=<span class="number">31</span>, type=<span class="string">"cat"</span>)</span><br><span class="line">print(perry._asdict())</span><br><span class="line"></span><br><span class="line"><span class="comment">## 输出: OrderedDict([('name', 'Perry'), ('age', 31), ...</span></span><br></pre></td></tr></table></figure><h1 id="enum-Enum-Python-3-4"><a href="#enum-Enum-Python-3-4" class="headerlink" title="enum.Enum (Python 3.4+)"></a>enum.Enum (Python 3.4+)</h1><p>另一个有用的容器是枚举对象，它属于<code>enum</code>模块，存在于Python 3.4以上版本中（同时作为一个独立的PyPI包<code>enum34</code>供老版本使用）。Enums(枚举类型)基本上是一种组织各种东西的方式。</p><p>让我们回顾一下上一个’Animal’命名元组的例子。<br>它有一个type字段，问题是，type是一个字符串。<br>那么问题来了，万一程序员输入了<code>Cat</code>，因为他按到了Shift键，或者输入了’CAT’，甚至’kitten’？</p><p>枚举可以帮助我们避免这个问题，通过不使用字符串。考虑以下这个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> collections <span class="keyword">import</span> namedtuple</span><br><span class="line"><span class="keyword">from</span> enum <span class="keyword">import</span> Enum</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Species</span><span class="params">(Enum)</span>:</span></span><br><span class="line">    cat = <span class="number">1</span></span><br><span class="line">    dog = <span class="number">2</span></span><br><span class="line">    horse = <span class="number">3</span></span><br><span class="line">    aardvark = <span class="number">4</span></span><br><span class="line">    butterfly = <span class="number">5</span></span><br><span class="line">    owl = <span class="number">6</span></span><br><span class="line">    platypus = <span class="number">7</span></span><br><span class="line">    dragon = <span class="number">8</span></span><br><span class="line">    unicorn = <span class="number">9</span></span><br><span class="line">    <span class="comment"># 依次类推</span></span><br><span class="line"></span><br><span class="line">    <span class="comment"># 但我们并不想关心同一物种的年龄，所以我们可以使用一个别名</span></span><br><span class="line">    kitten = <span class="number">1</span>  <span class="comment"># (译者注：幼小的猫咪)</span></span><br><span class="line">    puppy = <span class="number">2</span>   <span class="comment"># (译者注：幼小的狗狗)</span></span><br><span class="line"></span><br><span class="line">Animal = namedtuple(<span class="string">'Animal'</span>, <span class="string">'name age type'</span>)</span><br><span class="line">perry = Animal(name=<span class="string">"Perry"</span>, age=<span class="number">31</span>, type=Species.cat)</span><br><span class="line">drogon = Animal(name=<span class="string">"Drogon"</span>, age=<span class="number">4</span>, type=Species.dragon)</span><br><span class="line">tom = Animal(name=<span class="string">"Tom"</span>, age=<span class="number">75</span>, type=Species.cat)</span><br><span class="line">charlie = Animal(name=<span class="string">"Charlie"</span>, age=<span class="number">2</span>, type=Species.kitten)</span><br></pre></td></tr></table></figure><h2 id="现在，我们进行一些测试："><a href="#现在，我们进行一些测试：" class="headerlink" title="现在，我们进行一些测试："></a>现在，我们进行一些测试：</h2><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span>charlie.type == tom.type</span><br><span class="line"><span class="literal">True</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>charlie.type</span><br><span class="line">&lt;Species.cat: <span class="number">1</span>&gt;</span><br></pre></td></tr></table></figure><p>这样就没那么容易错误，我们必须更明确，而且我们应该只使用定义后的枚举类型。</p><p>有三种方法访问枚举数据，例如以下方法都可以获取到’cat’的值：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Species(<span class="number">1</span>)</span><br><span class="line">Species[<span class="string">'cat'</span>]</span><br><span class="line">Species.cat</span><br></pre></td></tr></table></figure><p>这只是一个快速浏览<code>collections</code>模块的介绍，建议你阅读本文最后的官方文档。</p><h1 id="枚举"><a href="#枚举" class="headerlink" title="枚举"></a>枚举</h1><p>枚举(<code>enumerate</code>)是Python内置函数。它的用处很难在简单的一行中说明，但是大多数的新人，甚至一些高级程序员都没有意识到它。</p><p>它允许我们遍历数据并自动计数，</p><p>下面是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> counter, value <span class="keyword">in</span> enumerate(some_list):</span><br><span class="line">    print(counter, value)</span><br></pre></td></tr></table></figure><p>不只如此，<code>enumerate</code>也接受一些可选参数，这使它更有用。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grapes'</span>, <span class="string">'pear'</span>]</span><br><span class="line"><span class="keyword">for</span> c, value <span class="keyword">in</span> enumerate(my_list, <span class="number">1</span>):</span><br><span class="line">    print(c, value)</span><br><span class="line"></span><br><span class="line"><span class="comment"># 输出:</span></span><br><span class="line">(<span class="number">1</span>, <span class="string">'apple'</span>)</span><br><span class="line">(<span class="number">2</span>, <span class="string">'banana'</span>)</span><br><span class="line">(<span class="number">3</span>, <span class="string">'grapes'</span>)</span><br><span class="line">(<span class="number">4</span>, <span class="string">'pear'</span>)</span><br></pre></td></tr></table></figure><p>上面这个可选参数允许我们定制从哪个数字开始枚举。<br>你还可以用来创建包含索引的元组列表，<br>例如：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'grapes'</span>, <span class="string">'pear'</span>]</span><br><span class="line">counter_list = list(enumerate(my_list, <span class="number">1</span>))</span><br><span class="line">print(counter_list)</span><br><span class="line"><span class="comment"># 输出: [(1, 'apple'), (2, 'banana'), (3, 'grapes'), (4, 'pear')]</span></span><br></pre></td></tr></table></figure><h1 id="对象自省"><a href="#对象自省" class="headerlink" title="对象自省"></a>对象自省</h1><p>自省(introspection)，在计算机编程领域里，是指在运行时来判断一个对象的类型的能力。它是Python的强项之一。Python中所有一切都是一个对象，而且我们可以仔细勘察那些对象。Python还包含了许多内置函数和模块来帮助我们。</p><h1 id="dir"><a href="#dir" class="headerlink" title="dir"></a><code>dir</code></h1><p>在这个小节里我们会学习到<code>dir</code>以及它在自省方面如何给我们提供便利。</p><p>它是用于自省的最重要的函数之一。它返回一个列表，列出了一个对象所拥有的属性和方法。这里是一个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">my_list = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]</span><br><span class="line">dir(my_list)</span><br><span class="line"><span class="comment"># Output: ['__add__', '__class__', '__contains__', '__delattr__', '__delitem__',</span></span><br><span class="line"><span class="comment"># '__delslice__', '__doc__', '__eq__', '__format__', '__ge__', '__getattribute__',</span></span><br><span class="line"><span class="comment"># '__getitem__', '__getslice__', '__gt__', '__hash__', '__iadd__', '__imul__',</span></span><br><span class="line"><span class="comment"># '__init__', '__iter__', '__le__', '__len__', '__lt__', '__mul__', '__ne__',</span></span><br><span class="line"><span class="comment"># '__new__', '__reduce__', '__reduce_ex__', '__repr__', '__reversed__', '__rmul__',</span></span><br><span class="line"><span class="comment"># '__setattr__', '__setitem__', '__setslice__', '__sizeof__', '__str__',</span></span><br><span class="line"><span class="comment"># '__subclasshook__', 'append', 'count', 'extend', 'index', 'insert', 'pop',</span></span><br><span class="line"><span class="comment"># 'remove', 'reverse', 'sort']</span></span><br></pre></td></tr></table></figure><p>上面的自省给了我们一个列表对象的所有方法的名字。当你没法回忆起一个方法的名字，这会非常有帮助。如果我们运行<code>dir()</code>而不传入参数，那么它会返回当前作用域的所有名字。</p><h1 id="type和id"><a href="#type和id" class="headerlink" title="type和id"></a><code>type</code>和<code>id</code></h1><p><code>type</code>函数返回一个对象的类型。举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">print(type(<span class="string">''</span>))</span><br><span class="line"><span class="comment"># Output: &lt;type 'str'&gt;</span></span><br><span class="line"></span><br><span class="line">print(type([]))</span><br><span class="line"><span class="comment"># Output: &lt;type 'list'&gt;</span></span><br><span class="line"></span><br><span class="line">print(type(&#123;&#125;))</span><br><span class="line"><span class="comment"># Output: &lt;type 'dict'&gt;</span></span><br><span class="line"></span><br><span class="line">print(type(dict))</span><br><span class="line"><span class="comment"># Output: &lt;type 'type'&gt;</span></span><br><span class="line"></span><br><span class="line">print(type(<span class="number">3</span>))</span><br><span class="line"><span class="comment"># Output: &lt;type 'int'&gt;</span></span><br></pre></td></tr></table></figure><p><code>id()</code>函数返回任意不同种类对象的唯一ID，举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">name = <span class="string">"Yasoob"</span></span><br><span class="line">print(id(name))</span><br><span class="line"><span class="comment"># Output: 139972439030304</span></span><br></pre></td></tr></table></figure><h1 id="inspect模块"><a href="#inspect模块" class="headerlink" title="inspect模块"></a><code>inspect</code>模块</h1><p><code>inspect</code>模块也提供了许多有用的函数，来获取活跃对象的信息。比方说，你可以查看一个对象的成员，只需运行：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> inspect</span><br><span class="line">print(inspect.getmembers(str))</span><br><span class="line"><span class="comment"># Output: [('__add__', &lt;slot wrapper '__add__' of ... ...</span></span><br></pre></td></tr></table></figure><p>还有好多个其他方法也能有助于自省。如果你愿意，你可以去探索它们。</p><h1 id="各种推导式-comprehensions"><a href="#各种推导式-comprehensions" class="headerlink" title="各种推导式(comprehensions)"></a>各种推导式(comprehensions)</h1><p>推导式（又称解析式）是Python的一种独有特性，如果我被迫离开了它，我会非常想念。推导式是可以从一个数据序列构建另一个新的数据序列的结构体。 共有三种推导，在Python2和3中都有支持：</p><ul><li>列表(<code>list</code>)推导式</li><li>字典(<code>dict</code>)推导式</li><li>集合(<code>set</code>)推导式</li></ul><p>我们将一一进行讨论。一旦你知道了使用列表推导式的诀窍，你就能轻易使用任意一种推导式了。</p><h1 id="列表推导式（list-comprehensions）"><a href="#列表推导式（list-comprehensions）" class="headerlink" title="列表推导式（list comprehensions）"></a>列表推导式（<code>list</code> comprehensions）</h1><p>列表推导式（又称列表解析式）提供了一种简明扼要的方法来创建列表。<br>它的结构是在一个中括号里包含一个表达式，然后是一个<code>for</code>语句，然后是0个或多个<code>for</code>或者<code>if</code>语句。那个表达式可以是任意的，意思是你可以在列表中放入任意类型的对象。返回结果将是一个新的列表，在这个以<code>if</code>和<code>for</code>语句为上下文的表达式运行完成之后产生。</p><h3 id="规范"><a href="#规范" class="headerlink" title="规范"></a>规范</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">variable = [out_exp <span class="keyword">for</span> out_exp <span class="keyword">in</span> input_list <span class="keyword">if</span> out_exp == <span class="number">2</span>]</span><br></pre></td></tr></table></figure><p>这里是另外一个简明例子:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">multiples = [i <span class="keyword">for</span> i <span class="keyword">in</span> range(<span class="number">30</span>) <span class="keyword">if</span> i % <span class="number">3</span> <span class="keyword">is</span> <span class="number">0</span>]</span><br><span class="line">print(multiples)</span><br><span class="line"><span class="comment"># Output: [0, 3, 6, 9, 12, 15, 18, 21, 24, 27]</span></span><br></pre></td></tr></table></figure><p>这将对快速生成列表非常有用。<br>有些人甚至更喜欢使用它而不是<code>filter</code>函数。<br>列表推导式在有些情况下超赞，特别是当你需要使用<code>for</code>循环来生成一个新列表。举个例子，你通常会这样做：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">squared = []</span><br><span class="line"><span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>):</span><br><span class="line">    squared.append(x**<span class="number">2</span>)</span><br></pre></td></tr></table></figure></p><p>你可以使用列表推导式来简化它，就像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">squared = [x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">10</span>)]</span><br></pre></td></tr></table></figure><h1 id="字典推导式（dict-comprehensions）"><a href="#字典推导式（dict-comprehensions）" class="headerlink" title="字典推导式（dict comprehensions）"></a>字典推导式（<code>dict</code> comprehensions）</h1><p>字典推导和列表推导的使用方法是类似的。这里有个我最近发现的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">mcase = &#123;<span class="string">'a'</span>: <span class="number">10</span>, <span class="string">'b'</span>: <span class="number">34</span>, <span class="string">'A'</span>: <span class="number">7</span>, <span class="string">'Z'</span>: <span class="number">3</span>&#125;</span><br><span class="line"></span><br><span class="line">mcase_frequency = &#123;</span><br><span class="line">    k.lower(): mcase.get(k.lower(), <span class="number">0</span>) + mcase.get(k.upper(), <span class="number">0</span>)</span><br><span class="line">    <span class="keyword">for</span> k <span class="keyword">in</span> mcase.keys()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment"># mcase_frequency == &#123;'a': 17, 'z': 3, 'b': 34&#125;</span></span><br></pre></td></tr></table></figure></p><p>在上面的例子中我们把同一个字母但不同大小写的值合并起来了。  </p><p>就我个人来说没有大量使用字典推导式。</p><p>你还可以快速对换一个字典的键和值：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;v: k <span class="keyword">for</span> k, v <span class="keyword">in</span> some_dict.items()&#125;</span><br></pre></td></tr></table></figure></p><h1 id="集合推导式（set-comprehensions）"><a href="#集合推导式（set-comprehensions）" class="headerlink" title="集合推导式（set comprehensions）"></a>集合推导式（<code>set</code> comprehensions）</h1><p>它们跟列表推导式也是类似的。 唯一的区别在于它们使用大括号<code>{}</code>。 举个例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">squared = &#123;x**<span class="number">2</span> <span class="keyword">for</span> x <span class="keyword">in</span> [<span class="number">1</span>, <span class="number">1</span>, <span class="number">2</span>]&#125;</span><br><span class="line">print(squared)</span><br><span class="line"><span class="comment"># Output: &#123;1, 4&#125;</span></span><br></pre></td></tr></table></figure></p><h1 id="异常"><a href="#异常" class="headerlink" title="异常"></a>异常</h1><p>异常处理是一种艺术，一旦你掌握，会授予你无穷的力量。我将要向你展示我们能处理异常的一些方式。</p><p>最基本的术语里我们知道了<code>try/except</code>从句。可能触发异常产生的代码会放到<code>try</code>语句块里，而处理异常的代码会在<code>except</code>语句块里实现。这是一个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    file = open(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'An IOError occurred. &#123;&#125;'</span>.format(e.args[<span class="number">-1</span>]))</span><br></pre></td></tr></table></figure><p>上面的例子里，我们仅仅在处理一个<code>IOError</code>的异常。大部分初学者还不知道的是，我们可以处理多个异常。</p><h1 id="处理多个异常"><a href="#处理多个异常" class="headerlink" title="处理多个异常"></a>处理多个异常</h1><p>我们可以使用三种方法来处理多个异常。</p><p>第一种方法需要把所有可能发生的异常放到一个元组里。像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    file = open(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">except</span> (IOError, EOFError) <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"An error occurred. &#123;&#125;"</span>.format(e.args[<span class="number">-1</span>]))</span><br></pre></td></tr></table></figure><p>另外一种方式是对每个单独的异常在单独的<code>except</code>语句块中处理。我们想要多少个<code>except</code>语句块都可以。这里是个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    file = open(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">except</span> EOFError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"An EOF error occurred."</span>)</span><br><span class="line">    <span class="keyword">raise</span> e</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">"An error occurred."</span>)</span><br><span class="line">    <span class="keyword">raise</span> e</span><br></pre></td></tr></table></figure><p>上面这个方式中，如果异常没有被第一个<code>except</code>语句块处理，那么它也许被下一个语句块处理，或者根本不会被处理。</p><p>现在，最后一种方式会捕获<strong>所有</strong>异常：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    file = open(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    <span class="comment"># 打印一些异常日志，如果你想要的话</span></span><br><span class="line">    <span class="keyword">raise</span></span><br></pre></td></tr></table></figure><p>当你不知道你的程序会抛出什么样的异常时，上面的方式可能非常有帮助。</p><h1 id="finally从句"><a href="#finally从句" class="headerlink" title="finally从句"></a><code>finally</code>从句</h1><p>我们把我们的主程序代码包裹进了<code>try</code>从句。然后我们把一些代码包裹进一个<code>except</code>从句，它会在<code>try</code>从句中的代码触发异常时执行。</p><p>在下面的例子中，我们还会使用第三个从句，那就是<code>finally</code>从句。包裹到<code>finally</code>从句中的代码不管异常是否触发都将会被执行。这可以被用来在脚本执行之后做清理工作。这里是个简单的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    file = open(<span class="string">'test.txt'</span>, <span class="string">'rb'</span>)</span><br><span class="line"><span class="keyword">except</span> IOError <span class="keyword">as</span> e:</span><br><span class="line">    print(<span class="string">'An IOError occurred. &#123;&#125;'</span>.format(e.args[<span class="number">-1</span>]))</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">"This would be printed whether or not an exception occurred!"</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: An IOError occurred. No such file or directory</span></span><br><span class="line"><span class="comment"># This would be printed whether or not an exception occurred!</span></span><br></pre></td></tr></table></figure><h1 id="try-else从句"><a href="#try-else从句" class="headerlink" title="try/else从句"></a><code>try/else</code>从句</h1><p>我们常常想在没有触发异常的时候执行一些代码。这可以很轻松地通过一个<code>else</code>从句来达到。</p><p>有人也许问了：如果你只是想让一些代码在没有触发异常的情况下执行，为啥你不直接把代码放在<code>try</code>里面呢？<br>回答是，那样的话这段代码中的任意异常都还是会被<code>try</code>捕获，而你并不一定想要那样。</p><p>大多数人并不使用<code>else</code>从句，而且坦率地讲我自己也没有大范围使用。这里是个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    print(<span class="string">'I am sure no exception is going to occur!'</span>)</span><br><span class="line"><span class="keyword">except</span> Exception:</span><br><span class="line">    print(<span class="string">'exception'</span>)</span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    <span class="comment"># 这里的代码只会在try语句里没有触发异常时运行,</span></span><br><span class="line">    <span class="comment"># 但是这里的异常将 *不会* 被捕获</span></span><br><span class="line">    print(<span class="string">'This would only run if no exception occurs. And an error here '</span></span><br><span class="line">          <span class="string">'would NOT be caught.'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    print(<span class="string">'This would be printed in every case.'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: I am sure no exception is going to occur!</span></span><br><span class="line"><span class="comment"># This would only run if no exception occurs.</span></span><br><span class="line"><span class="comment"># This would be printed in every case.</span></span><br></pre></td></tr></table></figure><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line"></span><br><span class="line"># 17. &#96;&#96;&#96;lambda&#96;&#96;&#96;表达式</span><br><span class="line">&#96;lambda&#96;表达式是一行函数。  </span><br><span class="line">它们在其他语言中也被称为匿名函数。如果你不想在程序中对一个函数使用两次，你也许会想用lambda表达式，它们和普通的函数完全一样。</span><br><span class="line"></span><br><span class="line">__原型__</span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">    lambda 参数:操作(参数)</span><br></pre></td></tr></table></figure><p><strong>例子</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">add = <span class="keyword">lambda</span> x, y: x + y</span><br><span class="line"></span><br><span class="line">print(add(<span class="number">3</span>, <span class="number">5</span>))</span><br><span class="line"><span class="comment"># Output: 8</span></span><br></pre></td></tr></table></figure></p><p>这还有一些lambda表达式的应用案例，可以在一些特殊情况下使用：</p><p><strong>列表排序</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">a = [(<span class="number">1</span>, <span class="number">2</span>), (<span class="number">4</span>, <span class="number">1</span>), (<span class="number">9</span>, <span class="number">10</span>), (<span class="number">13</span>, <span class="number">-3</span>)]</span><br><span class="line">a.sort(key=<span class="keyword">lambda</span> x: x[<span class="number">1</span>])</span><br><span class="line"></span><br><span class="line">print(a)</span><br><span class="line"><span class="comment"># Output: [(13, -3), (4, 1), (1, 2), (9, 10)]</span></span><br></pre></td></tr></table></figure></p><p><strong>列表并行排序</strong><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">data = zip(list1, list2)</span><br><span class="line">data = sorted(data)</span><br><span class="line">list1, list2 = map(<span class="keyword">lambda</span> t: list(t), zip(*data))</span><br></pre></td></tr></table></figure></p><h1 id="18-一行式"><a href="#18-一行式" class="headerlink" title="18. 一行式"></a>18. 一行式</h1><p>本章节,我将向大家展示一些一行式的Python命令，这些程序将对你非常有帮助。</p><p><strong>简易Web Server</strong></p><p>你是否想过通过网络快速共享文件？好消息，Python为你提供了这样的功能。进入到你要共享文件的目录下并在命令行中运行下面的代码：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># Python 2</span></span><br><span class="line">python -m SimpleHTTPServer</span><br><span class="line"></span><br><span class="line"><span class="comment"># Python 3</span></span><br><span class="line">python -m http.server</span><br></pre></td></tr></table></figure><p><strong>漂亮的打印</strong></p><p>你可以在Python REPL漂亮的打印出列表和字典。这里是相关的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> pprint <span class="keyword">import</span> pprint</span><br><span class="line"></span><br><span class="line">my_dict = &#123;<span class="string">'name'</span>: <span class="string">'Yasoob'</span>, <span class="string">'age'</span>: <span class="string">'undefined'</span>, <span class="string">'personality'</span>: <span class="string">'awesome'</span>&#125;</span><br><span class="line">pprint(my_dict)</span><br></pre></td></tr></table></figure><p>这种方法在字典上更为有效。此外，如果你想快速漂亮的从文件打印出json数据，那么你可以这么做：<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">cat file.json | python -m json.tool</span><br></pre></td></tr></table></figure></p><p><strong>脚本性能分析</strong><br>这可能在定位你的脚本中的性能瓶颈时，会非常奏效：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -m cProfile my_script.py</span><br></pre></td></tr></table></figure><p>备注：<code>cProfile</code>是一个比<code>profile</code>更快的实现，因为它是用c写的</p><p><strong>CSV转换为json</strong></p><p>在命令行执行这条指令<br><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python -c <span class="string">"import csv,json;print json.dumps(list(csv.reader(open('csv_file.csv'))))"</span></span><br></pre></td></tr></table></figure><br>确保更换<code>csv_file.csv</code>为你想要转换的csv文件</p><p><strong>列表辗平</strong></p><p>您可以通过使用<code>itertools</code>包中的<code>itertools.chain.from_iterable</code>轻松快速的辗平一个列表。下面是一个简单的例子：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">a_list = [[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]]</span><br><span class="line">print(list(itertools.chain.from_iterable(a_list)))</span><br><span class="line"><span class="comment"># Output: [1, 2, 3, 4, 5, 6]</span></span><br><span class="line"></span><br><span class="line"><span class="comment"># or</span></span><br><span class="line">print(list(itertools.chain(*a_list)))</span><br><span class="line"><span class="comment"># Output: [1, 2, 3, 4, 5, 6]</span></span><br></pre></td></tr></table></figure></p><p><strong>一行式的构造器</strong></p><p>避免类初始化时大量重复的赋值语句<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, a, b, c, d, e, f)</span>:</span></span><br><span class="line">        self.__dict__.update(&#123;k: v <span class="keyword">for</span> k, v <span class="keyword">in</span> locals().items() <span class="keyword">if</span> k != <span class="string">'self'</span>&#125;)</span><br></pre></td></tr></table></figure><br>更多的一行方法请参考<a href="https://wiki.python.org/moin/Powerful%20Python%20One-Liners" target="_blank" rel="noopener">Python官方文档</a>。</p><h1 id="For-Else"><a href="#For-Else" class="headerlink" title="For - Else"></a>For - Else</h1><p>循环是任何语言的一个必备要素。同样地，<code>for</code>循环就是Python的一个重要组成部分。然而还有一些东西是初学者并不知道的。我们将一个个讨论一下。</p><p>我们先从已经知道的开始。我们知道可以像这样使用<code>for</code>循环：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">fruits = [<span class="string">'apple'</span>, <span class="string">'banana'</span>, <span class="string">'mango'</span>]</span><br><span class="line"><span class="keyword">for</span> fruit <span class="keyword">in</span> fruits:</span><br><span class="line">    print(fruit.capitalize())</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: Apple</span></span><br><span class="line"><span class="comment">#         Banana</span></span><br><span class="line"><span class="comment">#         Mango</span></span><br></pre></td></tr></table></figure><p>这是一个<code>for</code>循环非常基础的结构。现在我们继续看看，Python的<code>for</code>循环的一些鲜为人所知的特性。</p><h1 id="else从句"><a href="#else从句" class="headerlink" title="else从句"></a><code>else</code>从句</h1><figure class="highlight plain"><figcaption><span>一旦你掌握了何时何地使用它，它真的会非常有用。我自己对它真是相见恨晚。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">有个常见的构造是跑一个循环，并查找一个元素。如果这个元素被找到了，我们使用&#96;&#96;&#96;break&#96;&#96;&#96;来中断这个循环。有两个场景会让循环停下来。</span><br><span class="line">- 第一个是当一个元素被找到，&#96;&#96;&#96;break&#96;&#96;&#96;被触发。</span><br><span class="line">- 第二个场景是循环结束。  </span><br><span class="line"></span><br><span class="line">现在我们也许想知道其中哪一个，才是导致循环完成的原因。一个方法是先设置一个标记，然后在循环结束时打上标记。另一个是使用&#96;&#96;&#96;else&#96;&#96;&#96;从句。</span><br><span class="line"></span><br><span class="line">这就是&#96;&#96;&#96;for&#x2F;else&#96;&#96;&#96;循环的基本结构：</span><br><span class="line"></span><br><span class="line">&#96;&#96;&#96;python</span><br><span class="line">for item in container:</span><br><span class="line">    if search_something(item):</span><br><span class="line">        # Found it!</span><br><span class="line">        process(item)</span><br><span class="line">        break</span><br><span class="line">else:</span><br><span class="line">    # Didn&#39;t find anything..</span><br><span class="line">    not_found_in_container()</span><br></pre></td></tr></table></figure><p>考虑下这个简单的案例，它是我从官方文档里拿来的：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">            print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n / x)</span><br><span class="line">            <span class="keyword">break</span></span><br></pre></td></tr></table></figure></p><p>它会找出2到10之间的数字的因子。现在是趣味环节了。我们可以加上一个附加的else语句块，来抓住质数，并且告诉我们：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">2</span>, <span class="number">10</span>):</span><br><span class="line">    <span class="keyword">for</span> x <span class="keyword">in</span> range(<span class="number">2</span>, n):</span><br><span class="line">        <span class="keyword">if</span> n % x == <span class="number">0</span>:</span><br><span class="line">            print(n, <span class="string">'equals'</span>, x, <span class="string">'*'</span>, n / x)</span><br><span class="line">            <span class="keyword">break</span></span><br><span class="line">    <span class="keyword">else</span>:</span><br><span class="line">        <span class="comment"># loop fell through without finding a factor</span></span><br><span class="line">        print(n, <span class="string">'is a prime number'</span>)</span><br></pre></td></tr></table></figure><h1 id="使用C扩展"><a href="#使用C扩展" class="headerlink" title="使用C扩展"></a>使用C扩展</h1><p>CPython还为开发者实现了一个有趣的特性，使用Python可以轻松调用C代码</p><p>开发者有三种方法可以在自己的Python代码中来调用C编写的函数-<code>ctypes</code>，<code>SWIG</code>，<code>Python/C API</code>。每种方式也都有各自的利弊。 </p><p>首先，我们要明确为什么要在Python中调用C？</p><p>常见原因如下：</p><ul><li>你要提升代码的运行速度，而且你知道C要比Python快50倍以上</li><li>C语言中有很多传统类库，而且有些正是你想要的，但你又不想用Python去重写它们</li><li>想对从内存到文件接口这样的底层资源进行访问</li><li>不需要理由，就是想这样做</li></ul><h1 id="CTypes"><a href="#CTypes" class="headerlink" title="CTypes"></a>CTypes</h1><p>Python中的<a href="https://docs.python.org/2/library/ctypes.html" target="_blank" rel="noopener">ctypes模块</a>可能是Python调用C方法中最简单的一种。ctypes模块提供了和C语言兼容的数据类型和函数来加载dll文件，因此在调用时不需对源文件做任何的修改。也正是如此奠定了这种方法的简单性。</p><p>示例如下</p><p>实现两数求和的C代码，保存为<code>add.c</code><br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//sample C file to add 2 numbers - int and floats</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;stdio.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span>, <span class="keyword">int</span>)</span></span>;</span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_float</span><span class="params">(<span class="keyword">float</span>, <span class="keyword">float</span>)</span></span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">int</span> <span class="title">add_int</span><span class="params">(<span class="keyword">int</span> num1, <span class="keyword">int</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">float</span> <span class="title">add_float</span><span class="params">(<span class="keyword">float</span> num1, <span class="keyword">float</span> num2)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> num1 + num2;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p><p>接下来将C文件编译为<code>.so</code>文件(windows下为DLL)。下面操作会生成adder.so文件<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash">For Linux</span></span><br><span class="line"><span class="meta">$</span><span class="bash">  gcc -shared -Wl,-soname,adder -o adder.so -fPIC add.c</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash">For Mac</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> gcc -shared -Wl,-install_name,adder.so -o adder.so -fPIC add.c</span></span><br></pre></td></tr></table></figure></p><p>现在在你的Python代码中来调用它<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> ctypes <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line"><span class="comment">#load the shared object file</span></span><br><span class="line">adder = CDLL(<span class="string">'./adder.so'</span>)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find sum of integers</span></span><br><span class="line">res_int = adder.add_int(<span class="number">4</span>,<span class="number">5</span>)</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Sum of 4 and 5 = "</span> + str(res_int)</span><br><span class="line"></span><br><span class="line"><span class="comment">#Find sum of floats</span></span><br><span class="line">a = c_float(<span class="number">5.5</span>)</span><br><span class="line">b = c_float(<span class="number">4.1</span>)</span><br><span class="line"></span><br><span class="line">add_float = adder.add_float</span><br><span class="line">add_float.restype = c_float</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Sum of 5.5 and 4.1 = "</span>, str(add_float(a, b))</span><br></pre></td></tr></table></figure></p><p>输出如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Sum of 4 and 5 &#x3D; 9</span><br><span class="line">Sum of 5.5 and 4.1 &#x3D;  9.60000038147</span><br></pre></td></tr></table></figure></p><p>在这个例子中，C文件是自解释的，它包含两个函数，分别实现了整形求和和浮点型求和。</p><p>在Python文件中，一开始先导入ctypes模块，然后使用CDLL函数来加载我们创建的库文件。这样我们就可以通过变量<code>adder</code>来使用C类库中的函数了。当<code>adder.add_int()</code>被调用时，内部将发起一个对C函数<code>add_int</code>的调用。ctypes接口允许我们在调用C函数时使用原生Python中默认的字符串型和整型。</p><p>而对于其他类似布尔型和浮点型这样的类型，必须要使用正确的ctype类型才可以。如向<code>adder.add_float()</code>函数传参时, 我们要先将Python中的十进制值转化为c_float类型，然后才能传送给C函数。这种方法虽然简单，清晰，但是却很受限。例如，并不能在C中对对象进行操作。</p><h1 id="SWIG"><a href="#SWIG" class="headerlink" title="SWIG"></a>SWIG</h1><p>SWIG是Simplified Wrapper and Interface Generator的缩写。是Python中调用C代码的另一种方法。在这个方法中，开发人员必须编写一个额外的接口文件来作为SWIG(终端工具)的入口。</p><p>Python开发者一般不会采用这种方法，因为大多数情况它会带来不必要的复杂。而当你有一个C/C++代码库需要被多种语言调用时，这将是个非常不错的选择。</p><p>示例如下(来自<a href="http://www.swig.org/tutorial.html" target="_blank" rel="noopener">SWIG官网</a>)</p><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">&#96;&#96;&#96;C</span><br><span class="line">#include &lt;time.h&gt;</span><br><span class="line">double My_variable &#x3D; 3.0;</span><br><span class="line"></span><br><span class="line">int fact(int n) &#123;</span><br><span class="line">    if (n &lt;&#x3D; 1) return 1;</span><br><span class="line">    else return n*fact(n-1);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int my_mod(int x, int y) &#123;</span><br><span class="line">    return (x%y);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">char *get_time()</span><br><span class="line">&#123;</span><br><span class="line">    time_t ltime;</span><br><span class="line">    time(&amp;ltime);</span><br><span class="line">    return ctime(&amp;ltime);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>编译它<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">unix % swig -python example.i</span><br><span class="line">unix % gcc -c example.c example_wrap.c \</span><br><span class="line">    -I/usr/local/include/python2.1</span><br><span class="line">unix % ld -shared example.o example_wrap.o -o _example.so</span><br></pre></td></tr></table></figure></p><p>最后，Python的输出<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;&gt;&gt; </span><span class="keyword">import</span> example</span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.fact(<span class="number">5</span>)</span><br><span class="line"><span class="number">120</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.my_mod(<span class="number">7</span>,<span class="number">3</span>)</span><br><span class="line"><span class="number">1</span></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>example.get_time()</span><br><span class="line"><span class="string">'Sun Feb 11 23:01:07 1996'</span></span><br><span class="line">&gt;&gt;&gt;</span><br></pre></td></tr></table></figure></p><p>我们可以看到，使用SWIG确实达到了同样的效果，虽然下了更多的工夫，但如果你的目标是多语言还是很值得的。</p><h1 id="Python-C-API"><a href="#Python-C-API" class="headerlink" title="Python/C API"></a>Python/C API</h1><p><a href="https://docs.python.org/2/c-api/" target="_blank" rel="noopener">Python/C API</a>可能是被最广泛使用的方法。它不仅简单，而且可以在C代码中操作你的Python对象。</p><p>这种方法需要以特定的方式来编写C代码以供Python去调用它。所有的Python对象都被表示为一种叫做PyObject的结构体，并且<code>Python.h</code>头文件中提供了各种操作它的函数。例如，如果PyObject表示为PyListType(列表类型)时，那么我们便可以使用<code>PyList_Size()</code>函数来获取该结构的长度，类似Python中的<code>len(list)</code>函数。大部分对Python原生对象的基础函数和操作在<code>Python.h</code>头文件中都能找到。</p><p>示例</p><p>编写一个C扩展，添加所有元素到一个Python列表(所有元素都是数字)</p><p>来看一下我们要实现的效果，这里演示了用Python调用C扩展的代码<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#Though it looks like an ordinary python import, the addList module is implemented in C</span></span><br><span class="line"><span class="keyword">import</span> addList</span><br><span class="line"></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Sum of List - "</span> + str(l) + <span class="string">" = "</span> +  str(addList.add(l))</span><br></pre></td></tr></table></figure></p><p>上面的代码和普通的Python文件并没有什么分别，导入并使用了另一个叫做<code>addList</code>的Python模块。唯一差别就是这个模块并不是用Python编写的，而是C。</p><p>接下来我们看看如何用C编写<code>addList</code>模块，这可能看起来有点让人难以接受，但是一旦你了解了这之中的各种组成，你就可以一往无前了。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//Python.h has all the required function definitions to manipulate the Python objects</span></span><br><span class="line"><span class="meta">#<span class="meta-keyword">include</span> <span class="meta-string">&lt;Python.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">//This is the function that is called from your python code</span></span><br><span class="line"><span class="function"><span class="keyword">static</span> PyObject* <span class="title">addList_add</span><span class="params">(PyObject* self, PyObject* args)</span></span>&#123;</span><br><span class="line"></span><br><span class="line">    PyObject * listObj;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//The input arguments come as a tuple, we parse the args to get the various variables</span></span><br><span class="line">    <span class="comment">//In this case it's only one list variable, which will now be referenced by listObj</span></span><br><span class="line">    <span class="keyword">if</span> (! PyArg_ParseTuple( args, <span class="string">"O"</span>, &amp;listObj ))</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//length of the list</span></span><br><span class="line">    <span class="keyword">long</span> length = PyList_Size(listObj);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//iterate over all the elements</span></span><br><span class="line">    <span class="keyword">int</span> i, sum =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (i = <span class="number">0</span>; i &lt; length; i++) &#123;</span><br><span class="line">        <span class="comment">//get an element out of the list - the element is also a python objects</span></span><br><span class="line">        PyObject* temp = PyList_GetItem(listObj, i);</span><br><span class="line">        <span class="comment">//we know that object represents an integer - so convert it into C long</span></span><br><span class="line">        <span class="keyword">long</span> elem = PyInt_AsLong(temp);</span><br><span class="line">        sum += elem;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">//value returned back to python code - another python object</span></span><br><span class="line">    <span class="comment">//build value here converts the C long to a python integer</span></span><br><span class="line">    <span class="keyword">return</span> Py_BuildValue(<span class="string">"i"</span>, sum);</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//This is the docstring that corresponds to our 'add' function.</span></span><br><span class="line"><span class="keyword">static</span> <span class="keyword">char</span> addList_docs[] =</span><br><span class="line"><span class="string">"add(  ): add all elements of the list\n"</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* This table contains the relavent info mapping -</span></span><br><span class="line"><span class="comment">   &lt;function-name in python module&gt;, &lt;actual-function&gt;,</span></span><br><span class="line"><span class="comment">   &lt;type-of-args the function expects&gt;, &lt;docstring associated with the function&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">static</span> PyMethodDef addList_funcs[] = &#123;</span><br><span class="line">    &#123;<span class="string">"add"</span>, (PyCFunction)addList_add, METH_VARARGS, addList_docs&#125;,</span><br><span class="line">    &#123;<span class="literal">NULL</span>, <span class="literal">NULL</span>, <span class="number">0</span>, <span class="literal">NULL</span>&#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">/*</span></span><br><span class="line"><span class="comment">   addList is the module name, and this is the initialization block of the module.</span></span><br><span class="line"><span class="comment">   &lt;desired module name&gt;, &lt;the-info-table&gt;, &lt;module's-docstring&gt;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="function">PyMODINIT_FUNC <span class="title">initaddList</span><span class="params">(<span class="keyword">void</span>)</span></span>&#123;</span><br><span class="line">    Py_InitModule3(<span class="string">"addList"</span>, addList_funcs,</span><br><span class="line">            <span class="string">"Add all ze lists"</span>);</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>逐步解释</p><ul><li><code>Python.h</code>头文件中包含了所有需要的类型(Python对象类型的表示)和函数定义(对Python对象的操作)</li><li>接下来我们编写将要在Python调用的函数, 函数传统的命名方式由{模块名}_{函数名}组成，所以我们将其命名为<code>addList_add</code>   </li><li>然后填写想在模块内实现函数的相关信息表，每行一个函数，以空行作为结束</li><li>最后的模块初始化块签名为<code>PyMODINIT_FUNC init{模块名}</code>。</li></ul><p>函数<code>addList_add</code>接受的参数类型为PyObject类型结构(同时也表示为元组类型，因为Python中万物皆为对象，所以我们先用PyObject来定义)。传入的参数则通过<code>PyArg_ParseTuple()</code>来解析。第一个参数是被解析的参数变量。第二个参数是一个字符串，告诉我们如何去解析元组中每一个元素。字符串的第n个字母正是代表着元组中第n个参数的类型。例如，”i”代表整形，”s”代表字符串类型, “O”则代表一个Python对象。接下来的参数都是你想要通过<code>PyArg_ParseTuple()</code>函数解析并保存的元素。这样参数的数量和模块中函数期待得到的参数数量就可以保持一致，并保证了位置的完整性。例如，我们想传入一个字符串，一个整数和一个Python列表，可以这样去写<br><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">int</span> n;</span><br><span class="line"><span class="keyword">char</span> *s;</span><br><span class="line">PyObject* <span class="built_in">list</span>;</span><br><span class="line">PyArg_ParseTuple(args, <span class="string">"siO"</span>, &amp;n, &amp;s, &amp;<span class="built_in">list</span>);</span><br></pre></td></tr></table></figure></p><p>在这种情况下，我们只需要提取一个列表对象，并将它存储在<code>listObj</code>变量中。然后用列表对象中的<code>PyList_Size()</code>函数来获取它的长度。就像Python中调用<code>len(list)</code>。</p><p>现在我们通过循环列表，使用<code>PyList_GetItem(list, index)</code>函数来获取每个元素。这将返回一个<code>PyObject*</code>对象。既然Python对象也能表示<code>PyIntType</code>，我们只要使用<code>PyInt_AsLong(PyObj *)</code>函数便可获得我们所需要的值。我们对每个元素都这样处理，最后再得到它们的总和。</p><p>总和将被转化为一个Python对象并通过<code>Py_BuildValue()</code>返回给Python代码，这里的i表示我们要返回一个Python整形对象。</p><p>现在我们已经编写完C模块了。将下列代码保存为<code>setup.py</code><br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#build the modules</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> distutils.core <span class="keyword">import</span> setup, Extension</span><br><span class="line"></span><br><span class="line">setup(name=<span class="string">'addList'</span>, version=<span class="string">'1.0'</span>,  \</span><br><span class="line">      ext_modules=[Extension(<span class="string">'addList'</span>, [<span class="string">'adder.c'</span>])])</span><br></pre></td></tr></table></figure></p><p>并且运行<br><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">python setup.py install</span><br></pre></td></tr></table></figure></p><p>现在应该已经将我们的C文件编译安装到我们的Python模块中了。</p><p>在一番辛苦后，让我们来验证下我们的模块是否有效<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">#module that talks to the C code</span></span><br><span class="line"><span class="keyword">import</span> addList</span><br><span class="line"></span><br><span class="line">l = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line"><span class="keyword">print</span> <span class="string">"Sum of List - "</span> + str(l) + <span class="string">" = "</span> +  str(addList.add(l))</span><br></pre></td></tr></table></figure></p><p>输出结果如下<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Sum of List - [1, 2, 3, 4, 5] &#x3D; 15</span><br></pre></td></tr></table></figure></p><p>如你所见，我们已经使用Python.h API成功开发出了我们第一个Python C扩展。这种方法看似复杂，但你一旦习惯，它将变的非常有效。</p><p>Python调用C代码的另一种方式便是使用<a href="http://cython.org/" target="_blank" rel="noopener">Cython</a>让Python编译的更快。但是Cython和传统的Python比起来可以将它理解为另一种语言，所以我们就不在这里过多描述了。</p><h1 id="open函数"><a href="#open函数" class="headerlink" title="open函数"></a><code>open</code>函数</h1><p><a href="http://docs.python.org/dev/library/functions.html#open" target="_blank" rel="noopener">open</a> 函数可以打开一个文件。超级简单吧？大多数时候，我们看到它这样被使用：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">f = open(<span class="string">'photo.jpg'</span>, <span class="string">'r+'</span>)</span><br><span class="line">jpgdata = f.read()</span><br><span class="line">f.close()</span><br></pre></td></tr></table></figure></p><p>我现在写这篇文章的原因，是大部分时间我看到<code>open</code>被这样使用。有<strong>三个</strong>错误存在于上面的代码中。你能把它们全指出来吗？如不能，请读下去。在这篇文章的结尾，你会知道上面的代码错在哪里，而且，更重要的是，你能在自己的代码里避免这些错误。现在我们从基础开始：</p><p><code>open</code>的返回值是一个文件句柄，从操作系统托付给你的Python程序。一旦你处理完文件，你会想要归还这个文件句柄，只有这样你的程序不会超出一次能打开的文件句柄的数量上限。</p><p>显式地调用<code>close</code>关闭了这个文件句柄，但前提是只有在read成功的情况下。如果有任意异常正好在<code>f = open(...)</code>之后产生，<code>f.close()</code>将不会被调用（取决于Python解释器的做法，文件句柄可能还是会被归还，但那是另外的话题了）。为了确保不管异常是否触发，文件都能关闭，我们将其包裹成一个<code>with</code>语句:<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'photo.jpg'</span>, <span class="string">'r+'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    jpgdata = f.read()</span><br></pre></td></tr></table></figure></p><figure class="highlight plain"><figcaption><span>打开模式)决定了这个文件如何被打开。</span></figcaption><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"></span><br><span class="line">- 如果你想读取文件，传入&#96;&#96;&#96;r</span><br></pre></td></tr></table></figure><ul><li>如果你想读取并写入文件，传入<code>r+</code></li><li>如果你想覆盖写入文件，传入<code>w</code></li><li>如果你想在文件末尾附加内容，传入<code>a</code></li></ul><p>虽然有若干个其他的有效的<code>mode</code>字符串，但有可能你将永远不会使用它们。<code>mode</code>很重要，不仅因为它改变了行为，而且它可能导致权限错误。举个例子，我们要是在一个写保护的目录里打开一个jpg文件， <code>open(.., &#39;r+&#39;)</code>就失败了。<code>mode</code>可能包含一个扩展字符；让我们还可以以二进制方式打开文件(你将得到字节串)或者文本模式(字符串)</p><p>一般来说，如果文件格式是由人写的，那么它更可能是文本模式。jpg图像文件一般不是人写的（而且其实不是人直接可读的），因此你应该以二进制模式来打开它们，方法是在<code>mode</code>字符串后加一个<code>b</code>(你可以看看开头的例子里，正确的方式应该是<code>rb</code>)。<br>如果你以文本模式打开一些东西（比如，加一个<code>t</code>,或者就用<code>r/r+/w/a</code>），你还必须知道要使用哪种编码。对于计算机来说，所有的文件都是字节，而不是字符。</p><p>可惜，在Pyhon 2.x版本里，<code>open</code>不支持显示地指定编码。然而，<a href="http://docs.python.org/2/library/io.html#io.open" target="_blank" rel="noopener">io.open</a>函数在Python 2.x中和3.x(其中它是<code>open</code>的别名)中都有提供，它能做正确的事。你可以传入<code>encoding</code>这个关键字参数来传入编码。<br>如果你不传入任意编码，一个系统 - 以及Python -指定的默认选项将被选中。你也许被诱惑去依赖这个默认选项，但这个默认选项经常是错误的，或者默认编码实际上不能表达文件里的所有字符（这将经常发生在Python 2.x和/或Windows）。<br>所以去挑选一个编码吧。<code>utf-8</code>是一个非常好的编码。当你写入一个文件，你可以选一个你喜欢的编码（或者最终读你文件的程序所喜欢的编码）。</p><p>那你怎么找出正在读的文件是用哪种编码写的呢？好吧，不幸的是，并没有一个十分简单的方式来检测编码。在不同的编码中，同样的字节可以表示不同，但同样有效的字符。因此，你必须依赖一个元数据（比如，在HTTP头信息里）来找出编码。越来越多的是，文件格式将编码定义成<code>UTF-8</code>。</p><p>有了这些基础知识，我们来写一个程序，读取一个文件，检测它是否是JPG（提示：这些文件头部以字节<code>FF D8</code>开始），把对输入文件的描述写入一个文本文件。<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> io</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> open(<span class="string">'photo.jpg'</span>, <span class="string">'rb'</span>) <span class="keyword">as</span> inf:</span><br><span class="line">    jpgdata = inf.read()</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> jpgdata.startswith(<span class="string">b'\xff\xd8'</span>):</span><br><span class="line">    text = <span class="string">u'This is a JPEG file (%d bytes long)\n'</span></span><br><span class="line"><span class="keyword">else</span>:</span><br><span class="line">    text = <span class="string">u'This is a random file (%d bytes long)\n'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> io.open(<span class="string">'summary.txt'</span>, <span class="string">'w'</span>, encoding=<span class="string">'utf-8'</span>) <span class="keyword">as</span> outf:</span><br><span class="line">    outf.write(text % len(jpgdata))</span><br></pre></td></tr></table></figure><br>我敢肯定，现在你会正确地使用<code>open</code>啦！</p><h1 id="22-目标Python2-3"><a href="#22-目标Python2-3" class="headerlink" title="22. 目标Python2+3"></a>22. 目标Python2+3</h1><p>很多时候你可能希望你开发的程序能够同时兼容Python2+和Python3+。</p><p>试想你有一个非常出名的Python模块被很多开发者使用着，但并不是所有人都只使用Python2或者Python3。这时候你有两个办法。第一个办法是开发两个模块，针对Python2一个，针对Python3一个。还有一个办法就是调整你现在的代码使其同时兼容Python2和Python3。</p><p>本节中，我将介绍一些技巧，让你的脚本同时兼容Python2和Python3。</p><p><strong>Future模块导入</strong></p><p>第一种也是最重要的方法，就是导入<code>__future__</code>模块。它可以帮你在Python2中导入Python3的功能。这有一组例子：</p><p>上下文管理器是Python2.6+引入的新特性，如果你想在Python2.5中使用它可以这样做：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> with_statement</span><br></pre></td></tr></table></figure></p><p>在Python3中<code>print</code>已经变为一个函数。如果你想在Python2中使用它可以通过<code>__future__</code>导入：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">print</span></span><br><span class="line"><span class="comment"># Output:</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">from</span> __future__ <span class="keyword">import</span> print_function</span><br><span class="line">print(<span class="keyword">print</span>)</span><br><span class="line"><span class="comment"># Output: &lt;built-in function print&gt;</span></span><br></pre></td></tr></table></figure><p><strong>模块重命名</strong></p><p>首先，告诉我你是如何在你的脚本中导入模块的。大多时候我们会这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo </span><br><span class="line"><span class="comment"># or</span></span><br><span class="line"><span class="keyword">from</span> foo <span class="keyword">import</span> bar</span><br></pre></td></tr></table></figure><p>你知道么，其实你也可以这样做：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> foo <span class="keyword">as</span> foo</span><br></pre></td></tr></table></figure><p>这样做可以起到和上面代码同样的功能，但最重要的是它能让你的脚本同时兼容Python2和Python3。现在我们来看下面的代码：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    <span class="keyword">import</span> urllib.request <span class="keyword">as</span> urllib_request  <span class="comment"># for Python 3</span></span><br><span class="line"><span class="keyword">except</span> ImportError:</span><br><span class="line">    <span class="keyword">import</span> urllib2 <span class="keyword">as</span> urllib_request  <span class="comment"># for Python 2</span></span><br></pre></td></tr></table></figure><p>让我来稍微解释一下上面的代码。<br>我们将模块导入代码包装在<code>try/except</code>语句中。我们是这样做是因为在Python 2中并没有<code>urllib.request</code>模块。这将引起一个<code>ImportError</code>异常。而在Python2中<code>urllib.request</code>的功能则是由<code>urllib2</code>提供的。所以,当我们试图在Python2中导入<code>urllib.request</code>模块的时候，一旦我们捕获到<code>ImportError</code>我们将通过导入<code>urllib2</code>模块来代替它。</p><p>最后，你要了解<code>as</code>关键字的作用。它将导入的模块映射到<code>urllib.request</code>，所以我们通过<code>urllib_request</code>这个别名就可以使用<code>urllib2</code>中的所有类和方法了。</p><p><strong>过期的Python2内置功能</strong></p><p>另一个需要了解的事情就是Python2中有12个内置功能在Python3中已经被移除了。要确保在Python2代码中不要出现这些功能来保证对Python3的兼容。这有一个强制让你放弃12内置功能的方法：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> future.builtins.disabled <span class="keyword">import</span> *</span><br></pre></td></tr></table></figure><p>现在，只要你尝试在Python3中使用这些被遗弃的模块时，就会抛出一个<code>NameError</code>异常如下：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> future.builtins.disabled <span class="keyword">import</span> *</span><br><span class="line"></span><br><span class="line">apply()</span><br><span class="line"><span class="comment"># Output: NameError: obsolete Python 2 builtin apply is disabled</span></span><br></pre></td></tr></table></figure><p><strong>标准库向下兼容的外部支持</strong></p><p>有一些包在非官方的支持下为Python2提供了Python3的功能。例如，我们有：</p><ul><li>enum <code>pip install enum34</code></li><li>singledispatch <code>pip install singledispatch</code></li><li>pathlib <code>pip install pathlib</code></li></ul><p>想更多了解，在Python文档中有一个<a href="https://docs.python.org/3/howto/pyporting.html" target="_blank" rel="noopener">全面的指南</a>可以帮助你让你的代码同时兼容Python2和Python3。</p><h1 id="23-协程"><a href="#23-协程" class="headerlink" title="23. 协程"></a>23. 协程</h1><p>Python中的协程和生成器很相似但又稍有不同。主要区别在于：</p><ul><li>生成器是数据的生产者</li><li>协程则是数据的消费者</li></ul><p>首先我们先来回顾下生成器的创建过程。我们可以这样去创建一个生成器:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">()</span>:</span></span><br><span class="line">    a, b = <span class="number">0</span>, <span class="number">1</span></span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        <span class="keyword">yield</span> a</span><br><span class="line">        a, b = b, a+b</span><br></pre></td></tr></table></figure><p>然后我们经常在<code>for</code>循环中这样使用它:</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> i <span class="keyword">in</span> fib():</span><br><span class="line">    <span class="keyword">print</span> i</span><br></pre></td></tr></table></figure><p>这样做不仅快而且不会给内存带来压力，因为我们所需要的值都是动态生成的而不是将他们存储在一个列表中。更概括的说如果现在我们在上面的例子中使用<code>yield</code>便可获得了一个协程。协程会消费掉发送给它的值。Python实现的<code>grep</code>就是个很好的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">grep</span><span class="params">(pattern)</span>:</span></span><br><span class="line">    print(<span class="string">"Searching for"</span>, pattern)</span><br><span class="line">    <span class="keyword">while</span> <span class="literal">True</span>:</span><br><span class="line">        line = (<span class="keyword">yield</span>)</span><br><span class="line">        <span class="keyword">if</span> pattern <span class="keyword">in</span> line:</span><br><span class="line">            print(line)</span><br></pre></td></tr></table></figure><p>等等！<code>yield</code>返回了什么？啊哈，我们已经把它变成了一个协程。它将不再包含任何初始值，相反要从外部传值给它。我们可以通过<code>send()</code>方法向它传值。这有个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">search = grep(<span class="string">'coroutine'</span>)</span><br><span class="line">next(search)</span><br><span class="line"><span class="comment">#output: Searching for coroutine</span></span><br><span class="line">search.send(<span class="string">"I love you"</span>)</span><br><span class="line">search.send(<span class="string">"Don't you love me?"</span>)</span><br><span class="line">search.send(<span class="string">"I love coroutine instead!"</span>)</span><br><span class="line"><span class="comment">#output: I love coroutine instead!</span></span><br></pre></td></tr></table></figure><p>发送的值会被<code>yield</code>接收。我们为什么要运行<code>next()</code>方法呢？这样做正是为了启动一个协程。就像协程中包含的生成器并不是立刻执行，而是通过<code>next()</code>方法来响应<code>send()</code>方法。因此，你必须通过<code>next()</code>方法来执行<code>yield</code>表达式。</p><p>我们可以通过调用<code>close()</code>方法来关闭一个协程。像这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">search = grep(<span class="string">'coroutine'</span>)</span><br><span class="line">search.close()</span><br></pre></td></tr></table></figure><p>更多协程相关知识的学习大家可以参考David Beazley的这份<a href="http://www.dabeaz.com/coroutines/Coroutines.pdf" target="_blank" rel="noopener">精彩演讲</a>。</p><h1 id="函数缓存-Function-caching"><a href="#函数缓存-Function-caching" class="headerlink" title="函数缓存 (Function caching)"></a>函数缓存 (Function caching)</h1><p>函数缓存允许我们将一个函数对于给定参数的返回值缓存起来。<br>当一个I/O密集的函数被频繁使用相同的参数调用的时候，函数缓存可以节约时间。<br>在Python 3.2版本以前我们只有写一个自定义的实现。在Python 3.2以后版本，有个<code>lru_cache</code>的装饰器，允许我们将一个函数的返回值快速地缓存或取消缓存。</p><p>我们来看看，Python 3.2前后的版本分别如何使用它。</p><h1 id="Python-3-2及以后版本"><a href="#Python-3-2及以后版本" class="headerlink" title="Python 3.2及以后版本"></a>Python 3.2及以后版本</h1><p>我们来实现一个斐波那契计算器，并使用<code>lru_cache</code>。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> lru_cache</span><br><span class="line"></span><br><span class="line"><span class="meta">@lru_cache(maxsize=32)</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fib</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>:</span><br><span class="line">        <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fib(n<span class="number">-1</span>) + fib(n<span class="number">-2</span>)</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;&gt;&gt; </span>print([fib(n) <span class="keyword">for</span> n <span class="keyword">in</span> range(<span class="number">10</span>)])</span><br><span class="line"><span class="comment"># Output: [0, 1, 1, 2, 3, 5, 8, 13, 21, 34]</span></span><br></pre></td></tr></table></figure><p>那个<code>maxsize</code>参数是告诉<code>lru_cache</code>，最多缓存最近多少个返回值。</p><p>我们也可以轻松地对返回值清空缓存，通过这样：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">fib.cache_clear()</span><br></pre></td></tr></table></figure><h1 id="Python-2系列版本"><a href="#Python-2系列版本" class="headerlink" title="Python 2系列版本"></a>Python 2系列版本</h1><p>你可以创建任意种类的缓存机制，有若干种方式来达到相同的效果，这完全取决于你的需要。<br>这里是一个一般的缓存：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> functools <span class="keyword">import</span> wraps</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">memoize</span><span class="params">(function)</span>:</span></span><br><span class="line">    memo = &#123;&#125;</span><br><span class="line"><span class="meta">    @wraps(function)</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">wrapper</span><span class="params">(*args)</span>:</span></span><br><span class="line">        <span class="keyword">if</span> args <span class="keyword">in</span> memo:</span><br><span class="line">            <span class="keyword">return</span> memo[args]</span><br><span class="line">        <span class="keyword">else</span>:</span><br><span class="line">            rv = function(*args)</span><br><span class="line">            memo[args] = rv</span><br><span class="line">            <span class="keyword">return</span> rv</span><br><span class="line">    <span class="keyword">return</span> wrapper</span><br><span class="line"></span><br><span class="line"><span class="meta">@memoize</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">fibonacci</span><span class="params">(n)</span>:</span></span><br><span class="line">    <span class="keyword">if</span> n &lt; <span class="number">2</span>: <span class="keyword">return</span> n</span><br><span class="line">    <span class="keyword">return</span> fibonacci(n - <span class="number">1</span>) + fibonacci(n - <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">fibonacci(<span class="number">25</span>)</span><br></pre></td></tr></table></figure><br>这里有一篇<a href="https://www.caktusgroup.com/blog/2015/06/08/testing-client-side-applications-django-post-mortem/" target="_blank" rel="noopener">Caktus Group的不错的文章</a>，在其中他们发现一个Django框架的由lru_cache导致的bug。读起来很有意思。一定要打开去看一下。</p><h1 id="上下文管理器-Context-managers"><a href="#上下文管理器-Context-managers" class="headerlink" title="上下文管理器(Context managers)"></a>上下文管理器(Context managers)</h1><p>上下文管理器允许你在有需要的时候，精确地分配和释放资源。  </p><p>使用上下文管理器最广泛的案例就是<code>with</code>语句了。<br>想象下你有两个需要结对执行的相关操作，然后还要在它们中间放置一段代码。<br>上下文管理器就是专门让你做这种事情的。举个例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open(<span class="string">'some_file'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">    opened_file.write(<span class="string">'Hola!'</span>)</span><br></pre></td></tr></table></figure><p>上面这段代码打开了一个文件，往里面写入了一些数据，然后关闭该文件。如果在往文件写数据时发生异常，它也会尝试去关闭文件。上面那段代码与这一段是等价的：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">file = open(<span class="string">'some_file'</span>, <span class="string">'w'</span>)</span><br><span class="line"><span class="keyword">try</span>:</span><br><span class="line">    file.write(<span class="string">'Hola!'</span>)</span><br><span class="line"><span class="keyword">finally</span>:</span><br><span class="line">    file.close()</span><br></pre></td></tr></table></figure><p>当与第一个例子对比时，我们可以看到，通过使用<code>with</code>，许多样板代码(boilerplate code)被消掉了。 这就是<code>with</code>语句的主要优势，它确保我们的文件会被关闭，而不用关注嵌套代码如何退出。</p><p>上下文管理器的一个常见用例，是资源的加锁和解锁，以及关闭已打开的文件（就像我已经展示给你看的）。</p><p>让我们看看如何来实现我们自己的上下文管理器。这会让我们更完全地理解在这些场景背后都发生着什么。</p><h1 id="基于类的实现"><a href="#基于类的实现" class="headerlink" title="基于类的实现"></a>基于类的实现</h1><p>一个上下文管理器的类，最起码要定义<code>__enter__</code>和<code>__exit__</code>方法。<br>让我们来构造我们自己的开启文件的上下文管理器，并学习下基础知识。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, file_name, method)</span>:</span></span><br><span class="line">        self.file_obj = open(file_name, method)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.file_obj</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, type, value, traceback)</span>:</span></span><br><span class="line">        self.file_obj.close()</span><br></pre></td></tr></table></figure><p>通过定义<code>__enter__</code>和<code>__exit__</code>方法，我们可以在<code>with</code>语句里使用它。我们来试试：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> File(<span class="string">'demo.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">    opened_file.write(<span class="string">'Hola!'</span>)</span><br><span class="line">```    </span><br><span class="line"></span><br><span class="line">我们的```__exit__```函数接受三个参数。这些参数对于每个上下文管理器类中的```__exit__```方法都是必须的。我们来谈谈在底层都发生了什么。</span><br><span class="line"></span><br><span class="line"><span class="number">1.</span> ```<span class="keyword">with</span>```语句先暂存了```File```类的```__exit__```方法</span><br><span class="line"><span class="number">2.</span> 然后它调用```File```类的```__enter__```方法</span><br><span class="line"><span class="number">3.</span> ```__enter__```方法打开文件并返回给```<span class="keyword">with</span>```语句</span><br><span class="line"><span class="number">4.</span> 打开的文件句柄被传递给```opened_file```参数</span><br><span class="line"><span class="number">5.</span> 我们使用```.write()```来写文件</span><br><span class="line"><span class="number">6.</span> ```<span class="keyword">with</span>```语句调用之前暂存的```__exit__```方法</span><br><span class="line"><span class="number">7.</span> ```__exit__```方法关闭了文件</span><br><span class="line"></span><br><span class="line"></span><br><span class="line"><span class="comment"># 处理异常</span></span><br><span class="line"></span><br><span class="line">我们还没有谈到```__exit__```方法的这三个参数：```type```, ```value```和```traceback```。  </span><br><span class="line">在第<span class="number">4</span>步和第<span class="number">6</span>步之间，如果发生异常，Python会将异常的```type```,```value```和```traceback```传递给```__exit__```方法。  </span><br><span class="line">它让```__exit__```方法来决定如何关闭文件以及是否需要其他步骤。在我们的案例中，我们并没有注意它们。</span><br><span class="line"></span><br><span class="line">那如果我们的文件对象抛出一个异常呢？万一我们尝试访问文件对象的一个不支持的方法。举个例子：</span><br><span class="line"></span><br><span class="line">```python</span><br><span class="line"><span class="keyword">with</span> File(<span class="string">'demo.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">    opened_file.undefined_function(<span class="string">'Hola!'</span>)</span><br></pre></td></tr></table></figure><p>我们来列一下，当异常发生时，<code>with</code>语句会采取哪些步骤。</p><ol><li>它把异常的<code>type</code>,<code>value</code>和<code>traceback</code>传递给<code>__exit__</code>方法</li><li>它让<code>__exit__</code>方法来处理异常</li><li>如果<code>__exit__</code>返回的是True，那么这个异常就被优雅地处理了。</li><li>如果<code>__exit__</code>返回的是True以外的任何东西，那么这个异常将被<code>with</code>语句抛出。</li></ol><p>在我们的案例中，<code>__exit__</code>方法返回的是<code>None</code>(如果没有<code>return</code>语句那么方法会返回<code>None</code>)。因此，<code>with</code>语句抛出了那个异常。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Traceback (most recent call last):</span><br><span class="line">  File <span class="string">"&lt;stdin&gt;"</span>, line <span class="number">2</span>, <span class="keyword">in</span> &lt;module&gt;</span><br><span class="line">AttributeError: <span class="string">'file'</span> object has no attribute <span class="string">'undefined_function'</span></span><br></pre></td></tr></table></figure><p>我们尝试下在<code>__exit__</code>方法中处理异常：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">File</span><span class="params">(object)</span>:</span></span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__init__</span><span class="params">(self, file_name, method)</span>:</span></span><br><span class="line">        self.file_obj = open(file_name, method)</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__enter__</span><span class="params">(self)</span>:</span></span><br><span class="line">        <span class="keyword">return</span> self.file_obj</span><br><span class="line">    <span class="function"><span class="keyword">def</span> <span class="title">__exit__</span><span class="params">(self, type, value, traceback)</span>:</span></span><br><span class="line">        print(<span class="string">"Exception has been handled"</span>)</span><br><span class="line">        self.file_obj.close()</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">True</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> File(<span class="string">'demo.txt'</span>, <span class="string">'w'</span>) <span class="keyword">as</span> opened_file:</span><br><span class="line">    opened_file.undefined_function()</span><br><span class="line"></span><br><span class="line"><span class="comment"># Output: Exception has been handled</span></span><br></pre></td></tr></table></figure></p><p>我们的<code>__exit__</code>方法返回了<code>True</code>,因此没有异常会被<code>with</code>语句抛出。</p><p>这还不是实现上下文管理器的唯一方式。还有一种方式，我们会在下一节中一起看看。</p><h1 id="基于生成器的实现"><a href="#基于生成器的实现" class="headerlink" title="基于生成器的实现"></a>基于生成器的实现</h1><p>我们还可以用装饰器(decorators)和生成器(generators)来实现上下文管理器。<br>Python有个<code>contextlib</code>模块专门用于这个目的。我们可以使用一个生成器函数来实现一个上下文管理器，而不是使用一个类。<br>让我们看看一个基本的，没用的例子：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">from</span> contextlib <span class="keyword">import</span> contextmanager</span><br><span class="line"></span><br><span class="line"><span class="meta">@contextmanager</span></span><br><span class="line"><span class="function"><span class="keyword">def</span> <span class="title">open_file</span><span class="params">(name)</span>:</span></span><br><span class="line">    f = open(name, <span class="string">'w'</span>)</span><br><span class="line">    <span class="keyword">yield</span> f</span><br><span class="line">    f.close()</span><br></pre></td></tr></table></figure><p>OK啦！这个实现方式看起来更加直观和简单。然而，这个方法需要关于生成器、<code>yield</code>和装饰器的一些知识。在这个例子中我们还没有捕捉可能产生的任何异常。它的工作方式和之前的方法大致相同。</p><p>让我们小小地剖析下这个方法。</p><ol><li>Python解释器遇到了<code>yield</code>关键字。因为这个缘故它创建了一个生成器而不是一个普通的函数。</li><li>因为这个装饰器，<code>contextmanager</code>会被调用并传入函数名（<code>open_file</code>）作为参数。</li><li><code>contextmanager</code>函数返回一个以<code>GeneratorContextManager</code>对象封装过的生成器。</li><li>这个<code>GeneratorContextManager</code>被赋值给<code>open_file</code>函数，我们实际上是在调用<code>GeneratorContextManager</code>对象。</li></ol><p>那现在我们既然知道了所有这些，我们可以用这个新生成的上下文管理器了，像这样：<br><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">with</span> open_file(<span class="string">'some_file'</span>) <span class="keyword">as</span> f:</span><br><span class="line">    f.write(<span class="string">'hola!'</span>)</span><br></pre></td></tr></table></figure></p><h1 id="推荐阅读"><a href="#推荐阅读" class="headerlink" title="推荐阅读"></a>推荐阅读</h1><h2 id="本书推送贴的留言和讨论"><a href="#本书推送贴的留言和讨论" class="headerlink" title="本书推送贴的留言和讨论"></a>本书推送贴的留言和讨论</h2><ul><li>v2ex: <a href="http://www.v2ex.com/t/267557" target="_blank" rel="noopener">http://www.v2ex.com/t/267557</a></li><li>微博长文: <a href="http://weibo.com/1054764633/DoN6Z5Haq?type=repost" target="_blank" rel="noopener">http://weibo.com/1054764633/DoN6Z5Haq?type=repost</a></li></ul><h2 id="v2ex网友florije推荐"><a href="#v2ex网友florije推荐" class="headerlink" title="v2ex网友florije推荐"></a>v2ex网友florije推荐</h2><ul><li>另外一本同名IntermediatePython的更新的书  <a href="https://leanpub.com/intermediatepython" target="_blank" rel="noopener">https://leanpub.com/intermediatepython</a></li></ul><h2 id="v2ex网友xiaket推荐"><a href="#v2ex网友xiaket推荐" class="headerlink" title="v2ex网友xiaket推荐"></a>v2ex网友xiaket推荐</h2><ul><li>对于Python提高类的书，推荐Fluent Python 或 Pro Python</li></ul><h2 id="v2ex网友shishen10-推荐"><a href="#v2ex网友shishen10-推荐" class="headerlink" title="v2ex网友shishen10 推荐"></a>v2ex网友shishen10 推荐</h2><ul><li>老齐的教程 <a href="https://github.com/qiwsir/StarterLearningPython" target="_blank" rel="noopener">https://github.com/qiwsir/StarterLearningPython</a></li><li>老齐还整理了很多精华 <a href="https://github.com/qiwsir/ITArticles" target="_blank" rel="noopener">https://github.com/qiwsir/ITArticles</a></li></ul><h2 id="v2ex网友xiaowangge推荐"><a href="#v2ex网友xiaowangge推荐" class="headerlink" title="v2ex网友xiaowangge推荐"></a>v2ex网友xiaowangge推荐</h2><p><a href="https://github.com/Yixiaohan" target="_blank" rel="noopener">Yixiaohan</a>整理了一个不错的推荐：<a href="https://github.com/Yixiaohan/codeparkshare" target="_blank" rel="noopener">Python初学者（零基础学习Python、Python入门）书籍、视频、资料、社区推荐</a>大家可以前去Fork。</p><h2 id="v2ex推荐学习书目"><a href="#v2ex推荐学习书目" class="headerlink" title="v2ex推荐学习书目"></a>v2ex推荐学习书目</h2><ul><li><a href="https://flyouting.gitbooks.io/learn-python-the-hard-way-cn/content/" target="_blank" rel="noopener">Learn Python the Hard Way</a></li><li><a href="https://www.gitbook.com/book/yulongjun/learning-python-in-chinese/details" target="_blank" rel="noopener">Python 学习手册-第五版中文版</a> </li><li><a href="http://python3-cookbook.readthedocs.org/zh_CN/latest/" target="_blank" rel="noopener">Python Cookbook</a></li><li><a href="https://book.douban.com/subject/4866934/" target="_blank" rel="noopener">Python 基础教程</a></li></ul>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;参考&lt;a href=&quot;https://eastlakeside.gitbook.io/interpy-zh/&quot; target=&quot;_blank&quot; rel=&quot;noopener&quot;&gt;此处&lt;/a&gt;&lt;/p&gt;
&lt;h1 id=&quot;Python进阶&quot;&gt;&lt;a href=&quot;#Python进阶&quot; class=&quot;headerlink&quot; title=&quot;Python进阶 &quot;&gt;&lt;/a&gt;Python进阶 &lt;/h1&gt;&lt;p&gt;《Python进阶》是《Intermediate Python》的中文译本, 谨以此献给进击的 Python 和 Python 程序员们!&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="python" scheme="http://yoursite.com/categories/python/"/>
    
    
      <category term="python" scheme="http://yoursite.com/tags/python/"/>
    
      <category term="python书籍" scheme="http://yoursite.com/tags/python%E4%B9%A6%E7%B1%8D/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(11)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/</id>
    <published>2020-07-27T03:20:38.000Z</published>
    <updated>2020-07-27T11:03:00.443Z</updated>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了一种机器学习的通用框架—集成学习方法，首先从准确性和差异性两个重要概念引出集成学习“<strong>好而不同</strong>”的四字真言，接着介绍了现阶段主流的三种集成学习方法：AdaBoost、Bagging及Random Forest，AdaBoost采用最小化指数损失函数迭代式更新样本分布权重和计算基学习器权重，Bagging通过自助采样引入样本扰动增加了基学习器之间的差异性，随机森林则进一步引入了属性扰动，最后简单概述了集成模型中的三类结合策略：平均法、投票法及学习法，其中Stacking是学习法的典型代表。本篇将讨论无监督学习中应用最为广泛的学习算法—聚类。<br><a id="more"></a></p><p>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:25px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="10、聚类算法"><a href="#10、聚类算法" class="headerlink" title="10、聚类算法"></a><strong>10、聚类算法</strong></h1><p>聚类是一种经典的<strong>无监督学习</strong>方法，<strong>无监督学习的目标是通过对无标记训练样本的学习，发掘和揭示数据集本身潜在的结构与规律</strong>，即不依赖于训练数据集的类标记信息。聚类则是试图将数据集的样本划分为若干个互不相交的类簇，从而每个簇对应一个潜在的类别。</p><p>聚类直观上来说是将相似的样本聚在一起，从而形成一个<strong>类簇（cluster）</strong>。那首先的问题是如何来<strong>度量相似性</strong>（similarity measure）呢？这便是<strong>距离度量</strong>，在生活中我们说差别小则相似，对应到多维样本，每个样本可以对应于高维空间中的一个数据点，若它们的距离相近，我们便可以称它们相似。那接着如何来评价聚类结果的好坏呢？这便是<strong>性能度量</strong>，性能度量为评价聚类结果的好坏提供了一系列有效性指标。</p><h2 id="10-1-距离度量"><a href="#10-1-距离度量" class="headerlink" title="10.1 距离度量"></a><strong>10.1 距离度量</strong></h2><p>谈及距离度量，最熟悉的莫过于欧式距离了，从年头一直用到年尾的距离计算公式：即对应属性之间相减的平方和再开根号。度量距离还有其它的很多经典方法，通常它们需要满足一些基本性质：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed4c0390.png" alt="1.png"></p><p>最常用的距离度量方法是<strong>“闵可夫斯基距离”（Minkowski distance)</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed49e31f.png" alt="2.png"></p><p>当p=1时，闵可夫斯基距离即<strong>曼哈顿距离（Manhattan distance）</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed49c31f.png" alt="3.png"></p><p>当p=2时，闵可夫斯基距离即<strong>欧氏距离（Euclidean distance）</strong>：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed497613.png" alt="4.png"></p><p>我们知道属性分为两种：<strong>连续属性</strong>和<strong>离散属性</strong>（有限个取值）。对于连续值的属性，一般都可以被学习器所用，有时会根据具体的情形作相应的预处理，例如：归一化等；而对于离散值的属性，需要作下面进一步的处理：</p><blockquote><p>若属性值之间<strong>存在序关系</strong>，则可以将其转化为连续值，例如：身高属性“高”“中等”“矮”，可转化为{1, 0.5, 0}。<br>若属性值之间<strong>不存在序关系</strong>，则通常将其转化为向量的形式，例如：性别属性“男”“女”，可转化为{（1,0），（0,1）}。</p></blockquote><p>在进行距离度量时，易知<strong>连续属性和存在序关系的离散属性都可以直接参与计算</strong>，因为它们都可以反映一种程度，我们称其为“<strong>有序属性</strong>”；而对于不存在序关系的离散属性，我们称其为：“<strong>无序属性</strong>”，显然无序属性再使用闵可夫斯基距离就行不通了。</p><p><strong>对于无序属性，我们一般采用VDM进行距离的计算</strong>，例如：对于离散属性的两个取值a和b，定义：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed4e9560.png" alt="5.png"></p><p>于是，在计算两个样本之间的距离时，我们可以将闵可夫斯基距离和VDM混合在一起进行计算：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed507bc7.png" alt="6.png"></p><p>若我们定义的距离计算方法是用来度量相似性，例如下面将要讨论的聚类问题，即距离越小，相似性越大，反之距离越大，相似性越小。这时距离的度量方法并不一定需要满足前面所说的四个基本性质，这样的方法称为：<strong>非度量距离（non-metric distance）</strong>。</p><h2 id="10-2-性能度量"><a href="#10-2-性能度量" class="headerlink" title="10.2 性能度量"></a><strong>10.2 性能度量</strong></h2><p>由于聚类算法不依赖于样本的真实类标，就不能像监督学习的分类那般，通过计算分对分错（即精确度或错误率）来评价学习器的好坏或作为学习过程中的优化目标。一般聚类有两类性能度量指标：<strong>外部指标</strong>和<strong>内部指标</strong>。</p><h3 id="10-2-1-外部指标"><a href="#10-2-1-外部指标" class="headerlink" title="10.2.1 外部指标"></a><strong>10.2.1 外部指标</strong></h3><p>即将聚类结果与某个参考模型的结果进行比较，<strong>以参考模型的输出作为标准，来评价聚类好坏</strong>。假设聚类给出的结果为λ，参考模型给出的结果是λ*，则我们将样本进行两两配对，定义：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed59160e.png" alt="7.png"></p><p>显然a和b代表着聚类结果好坏的正能量，b和c则表示参考结果和聚类结果相矛盾，基于这四个值可以导出以下常用的外部评价指标：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed587438.png" alt="8.png"></p><h3 id="10-2-2-内部指标"><a href="#10-2-2-内部指标" class="headerlink" title="10.2.2 内部指标"></a><strong>10.2.2 内部指标</strong></h3><p>内部指标即不依赖任何外部模型，直接对聚类的结果进行评估，聚类的目的是想将那些相似的样本尽可能聚在一起，不相似的样本尽可能分开，直观来说：<strong>簇内高内聚紧紧抱团，簇间低耦合老死不相往来</strong>。定义：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed581852.png" alt="9.png"></p><p>基于上面的四个距离，可以导出下面这些常用的内部评价指标：</p><p><img src="https://i.loli.net/2018/10/18/5bc84ed582854.png" alt="10.png"></p><h2 id="10-3-原型聚类"><a href="#10-3-原型聚类" class="headerlink" title="10.3 原型聚类"></a><strong>10.3 原型聚类</strong></h2><p>原型聚类即“<strong>基于原型的聚类</strong>”（prototype-based clustering），原型表示模板的意思，就是通过参考一个模板向量或模板分布的方式来完成聚类的过程，常见的K-Means便是基于簇中心来实现聚类，混合高斯聚类则是基于簇分布来实现聚类。</p><h3 id="10-3-1-K-Means"><a href="#10-3-1-K-Means" class="headerlink" title="10.3.1 K-Means"></a><strong>10.3.1 K-Means</strong></h3><p>K-Means的思想十分简单，<strong>首先随机指定类中心，根据样本与类中心的远近划分类簇，接着重新计算类中心，迭代直至收敛</strong>。但是其中迭代的过程并不是主观地想象得出，事实上，若将样本的类别看做为“隐变量”（latent variable），类中心看作样本的分布参数，这一过程正是通过<strong>EM算法</strong>的两步走策略而计算出，其根本的目的是为了最小化平方误差函数E：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb82b5d3.png" alt="11.png"></p><p>K-Means的算法流程如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb9c0817.png" alt="12.png"></p><h3 id="10-3-2-学习向量量化（LVQ）"><a href="#10-3-2-学习向量量化（LVQ）" class="headerlink" title="10.3.2 学习向量量化（LVQ）"></a><strong>10.3.2 学习向量量化（LVQ）</strong></h3><p>LVQ也是基于原型的聚类算法，与K-Means不同的是，<strong>LVQ使用样本真实类标记辅助聚类</strong>，首先LVQ根据样本的类标记，从各类中分别随机选出一个样本作为该类簇的原型，从而组成了一个<strong>原型特征向量组</strong>，接着从样本集中随机挑选一个样本，计算其与原型向量组中每个向量的距离，并选取距离最小的原型向量所在的类簇作为它的划分结果，再与真实类标比较。</p><blockquote><p><strong>若划分结果正确，则对应原型向量向这个样本靠近一些</strong><br><strong>若划分结果不正确，则对应原型向量向这个样本远离一些</strong></p></blockquote><p>LVQ算法的流程如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb9d59f2.png" alt="13.png"></p><h3 id="10-3-3-高斯混合聚类"><a href="#10-3-3-高斯混合聚类" class="headerlink" title="10.3.3 高斯混合聚类"></a><strong>10.3.3 高斯混合聚类</strong></h3><p>现在可以看出K-Means与LVQ都试图以类中心作为原型指导聚类，高斯混合聚类则采用高斯分布来描述原型。现假设<strong>每个类簇中的样本都服从一个多维高斯分布，那么空间中的样本可以看作由k个多维高斯分布混合而成</strong>。</p><p>对于多维高斯分布，其概率密度函数如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb870d98.png" alt="14.png"></p><p>其中u表示均值向量，∑表示协方差矩阵，可以看出一个多维高斯分布完全由这两个参数所确定。接着定义高斯混合分布为：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb876794.png" alt="15.png"></p><p>α称为混合系数，这样空间中样本的采集过程则可以抽象为：<strong>（1）先选择一个类簇（高斯分布），（2）再根据对应高斯分布的密度函数进行采样</strong>，这时候贝叶斯公式又能大展身手了：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb9191d9.png" alt="16.png"></p><p>此时只需要选择PM最大时的类簇并将该样本划分到其中，看到这里很容易发现：这和那个传说中的贝叶斯分类不是神似吗，都是通过贝叶斯公式展开，然后计算类先验概率和类条件概率。但遗憾的是：<strong>这里没有真实类标信息，对于类条件概率，并不能像贝叶斯分类那样通过最大似然法美好地计算出来</strong>，因为这里的样本可能属于所有的类簇，这里的似然函数变为：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb871d4a.png" alt="17.png"></p><p>可以看出：简单的最大似然法根本无法求出所有的参数，这样PM也就没法计算。<strong>这里就要召唤出之前的EM大法，首先对高斯分布的参数及混合系数进行随机初始化，计算出各个PM（即γji，第i个样本属于j类），再最大化似然函数（即LL（D）分别对α、u和∑求偏导 ），对参数进行迭代更新</strong>。</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb8a6f32.png" alt="18.png"></p><p>高斯混合聚类的算法流程如下图所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb9c4fa4.png" alt="19.png"></p><h2 id="10-4-密度聚类"><a href="#10-4-密度聚类" class="headerlink" title="10.4 密度聚类"></a><strong>10.4 密度聚类</strong></h2><p>密度聚类则是基于密度的聚类，它从样本分布的角度来考察样本之间的可连接性，并基于可连接性（密度可达）不断拓展疆域（类簇）。其中最著名的便是<strong>DBSCAN</strong>算法，首先定义以下概念：</p><p><img src="https://i.loli.net/2018/10/18/5bc84fb9bd69c.png" alt="20.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc8509f8d619.png" alt="21.png"></p><p>简单来理解DBSCAN便是：<strong>找出一个核心对象所有密度可达的样本集合形成簇</strong>。首先从数据集中任选一个核心对象A，找出所有A密度可达的样本集合，将这些样本形成一个密度相连的类簇，直到所有的核心对象都遍历完。DBSCAN算法的流程如下图所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc8509feb587.png" alt="22.png"></p><h2 id="10-5-层次聚类"><a href="#10-5-层次聚类" class="headerlink" title="10.5 层次聚类"></a><strong>10.5 层次聚类</strong></h2><p>层次聚类是一种基于树形结构的聚类方法，常用的是<strong>自底向上</strong>的结合策略（<strong>AGNES算法</strong>）。假设有N个待聚类的样本，其基本步骤是：</p><blockquote><p>1.初始化—&gt;把每个样本归为一类，计算每两个类之间的距离，也就是样本与样本之间的相似度；<br>2.寻找各个类之间最近的两个类，把他们归为一类（这样类的总数就少了一个）；<br>3.重新计算新生成的这个<strong>类与各个旧类之间的相似度</strong>；<br>4.重复2和3直到所有样本点都归为一类，结束。</p></blockquote><p>可以看出其中最关键的一步就是<strong>计算两个类簇的相似度</strong>，这里有多种度量方法：</p><pre><code>* 单链接（single-linkage）:取类间最小距离。</code></pre><p><img src="https://i.loli.net/2018/10/18/5bc8509ebb022.png" alt="23.png"></p><pre><code>* 全链接（complete-linkage）:取类间最大距离</code></pre><p><img src="https://i.loli.net/2018/10/18/5bc8509eb2b30.png" alt="24.png"></p><pre><code>* 均链接（average-linkage）:取类间两两的平均距离</code></pre><p><img src="https://i.loli.net/2018/10/18/5bc8509f089a7.png" alt="25.png"></p><p>很容易看出：<strong>单链接的包容性极强，稍微有点暧昧就当做是自己人了，全链接则是坚持到底，只要存在缺点就坚决不合并，均连接则是从全局出发顾全大局</strong>。层次聚类法的算法流程如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc8509f9d4a0.png" alt="26.png"></p><blockquote><p>在此聚类算法就介绍完毕，分类/聚类都是机器学习中最常见的任务，我实验室的大Boss也是靠着聚类起家，从此走上人生事业钱途…之巅峰，在书最后的阅读材料还看见Boss的名字，所以这章也是必读不可了…</p></blockquote>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇主要介绍了一种机器学习的通用框架—集成学习方法，首先从准确性和差异性两个重要概念引出集成学习“&lt;strong&gt;好而不同&lt;/strong&gt;”的四字真言，接着介绍了现阶段主流的三种集成学习方法：AdaBoost、Bagging及Random Forest，AdaBoost采用最小化指数损失函数迭代式更新样本分布权重和计算基学习器权重，Bagging通过自助采样引入样本扰动增加了基学习器之间的差异性，随机森林则进一步引入了属性扰动，最后简单概述了集成模型中的三类结合策略：平均法、投票法及学习法，其中Stacking是学习法的典型代表。本篇将讨论无监督学习中应用最为广泛的学习算法—聚类。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(10)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/</id>
    <published>2020-07-27T02:20:38.000Z</published>
    <updated>2020-07-27T11:02:50.148Z</updated>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了鼎鼎大名的EM算法，从算法思想到数学公式推导（边际似然引入隐变量，Jensen不等式简化求导），EM算法实际上可以理解为一种坐标下降法，首先固定一个变量，接着求另外变量的最优解，通过其优美的“两步走”策略能较好地估计隐变量的值。本篇将继续讨论下一类经典算法—集成学习。<br><a id="more"></a></p><p>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:25px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="9、集成学习"><a href="#9、集成学习" class="headerlink" title="9、集成学习"></a><strong>9、集成学习</strong></h1><p>顾名思义，集成学习（ensemble learning）指的是将多个学习器进行有效地结合，组建一个“学习器委员会”，其中每个学习器担任委员会成员并行使投票表决权，使得委员会最后的决定更能够四方造福普度众生~…~，即其泛化性能要能优于其中任何一个学习器。</p><h2 id="9-1-个体与集成"><a href="#9-1-个体与集成" class="headerlink" title="9.1 个体与集成"></a><strong>9.1 个体与集成</strong></h2><p>集成学习的基本结构为：先产生一组个体学习器，再使用某种策略将它们结合在一起。集成模型如下图所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0c15683.png" alt="1.png"></p><p>在上图的集成模型中，若个体学习器都属于同一类别，例如都是决策树或都是神经网络，则称该集成为同质的（homogeneous）;若个体学习器包含多种类型的学习算法，例如既有决策树又有神经网络，则称该集成为异质的（heterogenous）。</p><blockquote><p><strong>同质集成</strong>：个体学习器称为“基学习器”（base learner），对应的学习算法为“基学习算法”（base learning algorithm）。<br><strong>异质集成</strong>：个体学习器称为“组件学习器”（component learner）或直称为“个体学习器”。</p></blockquote><p>上面我们已经提到要让集成起来的泛化性能比单个学习器都要好，虽说团结力量大但也有木桶短板理论调皮捣蛋，那如何做到呢？这就引出了集成学习的两个重要概念：<strong>准确性</strong>和<strong>多样性</strong>（diversity）。准确性指的是个体学习器不能太差，要有一定的准确度；多样性则是个体学习器之间的输出要具有差异性。通过下面的这三个例子可以很容易看出这一点，准确度较高，差异度也较高，可以较好地提升集成性能。</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0d23e13.png" alt="2.png"></p><p>现在考虑二分类的简单情形，假设基分类器之间相互独立（能提供较高的差异度），且错误率相等为 ε，则可以将集成器的预测看做一个伯努利实验，易知当所有基分类器中不足一半预测正确的情况下，集成器预测错误，所以集成器的错误率可以计算为：</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0cce0bb.png" alt="3.png"></p><p>此时，集成器错误率随着基分类器的个数的增加呈指数下降，但前提是基分类器之间相互独立，在实际情形中显然是不可能的，假设训练有A和B两个分类器，对于某个测试样本，显然满足：P（A=1 | B=1）&gt; P（A=1），因为A和B为了解决相同的问题而训练，因此在预测新样本时存在着很大的联系。因此，<strong>个体学习器的“准确性”和“差异性”本身就是一对矛盾的变量</strong>，准确性高意味着牺牲多样性，所以产生“<strong>好而不同</strong>”的个体学习器正是集成学习研究的核心。现阶段有三种主流的集成学习方法：Boosting、Bagging以及随机森林（Random Forest），接下来将进行逐一介绍。</p><h2 id="9-2-Boosting"><a href="#9-2-Boosting" class="headerlink" title="9.2 Boosting"></a><strong>9.2 Boosting</strong></h2><p>Boosting是一种串行的工作机制，即个体学习器的训练存在依赖关系，必须一步一步序列化进行。其基本思想是：增加前一个基学习器在训练训练过程中预测错误样本的权重，使得后续基学习器更加关注这些打标错误的训练样本，尽可能纠正这些错误，一直向下串行直至产生需要的T个基学习器，Boosting最终对这T个学习器进行加权结合，产生学习器委员会。</p><p>Boosting族算法最著名、使用最为广泛的就是AdaBoost，因此下面主要是对AdaBoost算法进行介绍。AdaBoost使用的是<strong>指数损失函数</strong>，因此AdaBoost的权值与样本分布的更新都是围绕着最小化指数损失函数进行的。看到这里回想一下之前的机器学习算法，<strong>不难发现机器学习的大部分带参模型只是改变了最优化目标中的损失函数</strong>：如果是Square loss，那就是最小二乘了；如果是Hinge Loss，那就是著名的SVM了；如果是log-Loss，那就是Logistic Regression了。</p><p>定义基学习器的集成为加权结合，则有：</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0ca2ca5.png" alt="4.png"></p><p>AdaBoost算法的指数损失函数定义为：</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0d10461.png" alt="5.png"></p><p>具体说来，整个Adaboost 迭代算法分为3步：</p><ul><li>初始化训练数据的权值分布。如果有N个样本，则每一个训练样本最开始时都被赋予相同的权值：1/N。</li><li>训练弱分类器。具体训练过程中，如果某个样本点已经被准确地分类，那么在构造下一个训练集中，它的权值就被降低；相反，如果某个样本点没有被准确地分类，那么它的权值就得到提高。然后，权值更新过的样本集被用于训练下一个分类器，整个训练过程如此迭代地进行下去。</li><li>将各个训练得到的弱分类器组合成强分类器。各个弱分类器的训练过程结束后，加大分类误差率小的弱分类器的权重，使其在最终的分类函数中起着较大的决定作用，而降低分类误差率大的弱分类器的权重，使其在最终的分类函数中起着较小的决定作用。</li></ul><p>整个AdaBoost的算法流程如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0d7c057.png" alt="6.png"></p><p>可以看出：<strong>AdaBoost的核心步骤就是计算基学习器权重和样本权重分布</strong>，那为何是上述的计算公式呢？这就涉及到了我们之前为什么说大部分带参机器学习算法只是改变了损失函数，就是因为<strong>大部分模型的参数都是通过最优化损失函数（可能还加个规则项）而计算（梯度下降，坐标下降等）得到</strong>，这里正是通过最优化指数损失函数从而得到这两个参数的计算公式，具体的推导过程此处不进行展开。</p><p>Boosting算法要求基学习器能对特定分布的数据进行学习，即每次都更新样本分布权重，这里书上提到了两种方法：“重赋权法”（re-weighting）和“重采样法”（re-sampling），书上的解释有些晦涩，这里进行展开一下：</p><blockquote><p><strong>重赋权法</strong> : 对每个样本附加一个权重，这时涉及到样本属性与标签的计算，都需要乘上一个权值。<br><strong>重采样法</strong> : 对于一些无法接受带权样本的及学习算法，适合用“重采样法”进行处理。方法大致过程是，根据各个样本的权重，对训练数据进行重采样，初始时样本权重一样，每个样本被采样到的概率一致，每次从N个原始的训练样本中按照权重有放回采样N个样本作为训练集，然后计算训练集错误率，然后调整权重，重复采样，集成多个基学习器。</p></blockquote><p>从偏差-方差分解来看：Boosting算法主要关注于降低偏差，每轮的迭代都关注于训练过程中预测错误的样本，将弱学习提升为强学习器。从AdaBoost的算法流程来看，标准的AdaBoost只适用于二分类问题。在此，当选为数据挖掘十大算法之一的AdaBoost介绍到这里，能够当选正是说明这个算法十分婀娜多姿，背后的数学证明和推导充分证明了这一点，限于篇幅不再继续展开。</p><h2 id="9-3-Bagging与Random-Forest"><a href="#9-3-Bagging与Random-Forest" class="headerlink" title="9.3 Bagging与Random Forest"></a><strong>9.3 Bagging与Random Forest</strong></h2><p>相比之下，Bagging与随机森林算法就简洁了许多，上面已经提到产生“好而不同”的个体学习器是集成学习研究的核心，即在保证基学习器准确性的同时增加基学习器之间的多样性。而这两种算法的基本思（tao）想（lu）都是通过“自助采样”的方法来增加多样性。</p><h3 id="9-3-1-Bagging"><a href="#9-3-1-Bagging" class="headerlink" title="9.3.1 Bagging"></a><strong>9.3.1 Bagging</strong></h3><p>Bagging是一种并行式的集成学习方法，即基学习器的训练之间没有前后顺序可以同时进行，Bagging使用“有放回”采样的方式选取训练集，对于包含m个样本的训练集，进行m次有放回的随机采样操作，从而得到m个样本的采样集，这样训练集中有接近36.8%的样本没有被采到。按照相同的方式重复进行，我们就可以采集到T个包含m个样本的数据集，从而训练出T个基学习器，最终对这T个基学习器的输出进行结合。</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0ce62fc.png" alt="7.png"></p><p>Bagging算法的流程如下所示：</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0d0e761.png" alt="8.png"></p><p>可以看出Bagging主要通过<strong>样本的扰动</strong>来增加基学习器之间的多样性，因此Bagging的基学习器应为那些对训练集十分敏感的不稳定学习算法，例如：神经网络与决策树等。从偏差-方差分解来看，Bagging算法主要关注于降低方差，即通过多次重复训练提高稳定性。不同于AdaBoost的是，Bagging可以十分简单地移植到多分类、回归等问题。总的说起来则是：<strong>AdaBoost关注于降低偏差，而Bagging关注于降低方差。</strong></p><h3 id="9-3-2-随机森林"><a href="#9-3-2-随机森林" class="headerlink" title="9.3.2 随机森林"></a><strong>9.3.2 随机森林</strong></h3><p>随机森林（Random Forest）是Bagging的一个拓展体，它的基学习器固定为决策树，多棵树也就组成了森林，而“随机”则在于选择划分属性的随机，随机森林在训练基学习器时，也采用有放回采样的方式添加样本扰动，同时它还引入了一种<strong>属性扰动</strong>，即在基决策树的训练过程中，在选择划分属性时，RF先从候选属性集中随机挑选出一个包含K个属性的子集，再从这个子集中选择最优划分属性，一般推荐K=log2（d）。</p><p>这样随机森林中基学习器的多样性不仅来自样本扰动，还来自属性扰动，从而进一步提升了基学习器之间的差异度。相比决策树的Bagging集成，随机森林的起始性能较差（由于属性扰动，基决策树的准确度有所下降），但随着基学习器数目的增多，随机森林往往会收敛到更低的泛化误差。同时不同于Bagging中决策树从所有属性集中选择最优划分属性，随机森林只在属性集的一个子集中选择划分属性，因此训练效率更高。</p><p><img src="https://i.loli.net/2018/10/18/5bc84d0d7a4fd.png" alt="9.png"></p><h2 id="9-4-结合策略"><a href="#9-4-结合策略" class="headerlink" title="9.4 结合策略"></a><strong>9.4 结合策略</strong></h2><p>结合策略指的是在训练好基学习器后，如何将这些基学习器的输出结合起来产生集成模型的最终输出，下面将介绍一些常用的结合策略：</p><h3 id="9-4-1-平均法（回归问题）"><a href="#9-4-1-平均法（回归问题）" class="headerlink" title="9.4.1 平均法（回归问题）"></a><strong>9.4.1 平均法（回归问题）</strong></h3><p><img src="https://i.loli.net/2018/10/18/5bc84d0d07983.png" alt="10.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc84de1b74ff.png" alt="11.png"></p><p>易知简单平均法是加权平均法的一种特例，加权平均法可以认为是集成学习研究的基本出发点。由于各个基学习器的权值在训练中得出，<strong>一般而言，在个体学习器性能相差较大时宜使用加权平均法，在个体学习器性能相差较小时宜使用简单平均法</strong>。</p><h3 id="9-4-2-投票法（分类问题）"><a href="#9-4-2-投票法（分类问题）" class="headerlink" title="9.4.2 投票法（分类问题）"></a><strong>9.4.2 投票法（分类问题）</strong></h3><p><img src="https://i.loli.net/2018/10/18/5bc84de2629c4.png" alt="12.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc84de25a74b.png" alt="13.png"></p><p><img src="https://i.loli.net/2018/10/18/5bc84de1bacc4.png" alt="14.png"></p><p>绝对多数投票法（majority voting）提供了拒绝选项，这在可靠性要求很高的学习任务中是一个很好的机制。同时，对于分类任务，各个基学习器的输出值有两种类型，分别为类标记和类概率。</p><p><img src="https://i.loli.net/2018/10/18/5bc84de2768c1.png" alt="15.png"></p><p>一些在产生类别标记的同时也生成置信度的学习器，置信度可转化为类概率使用，<strong>一般基于类概率进行结合往往比基于类标记进行结合的效果更好</strong>，需要注意的是对于异质集成，其类概率不能直接进行比较，此时需要将类概率转化为类标记输出，然后再投票。</p><h3 id="9-4-3-学习法"><a href="#9-4-3-学习法" class="headerlink" title="9.4.3 学习法"></a><strong>9.4.3 学习法</strong></h3><p>学习法是一种更高级的结合策略，即学习出一种“投票”的学习器，Stacking是学习法的典型代表。Stacking的基本思想是：首先训练出T个基学习器，对于一个样本它们会产生T个输出，将这T个基学习器的输出与该样本的真实标记作为新的样本，m个样本就会产生一个m<em>T的样本集，来训练一个新的“投票”学习器。投票学习器的输入属性与学习算法对Stacking集成的泛化性能有很大的影响，书中已经提到：<em>*投票学习器采用类概率作为输入属性，选用多响应线性回归（MLR）一般会产生较好的效果</em></em>。</p><p><img src="https://i.loli.net/2018/10/18/5bc84de25cbaf.png" alt="16.png"></p><h2 id="9-5-多样性（diversity）"><a href="#9-5-多样性（diversity）" class="headerlink" title="9.5 多样性（diversity）"></a><strong>9.5 多样性（diversity）</strong></h2><p>在集成学习中，基学习器之间的多样性是影响集成器泛化性能的重要因素。因此增加多样性对于集成学习研究十分重要，一般的思路是在学习过程中引入随机性，常见的做法主要是对数据样本、输入属性、输出表示、算法参数进行扰动。</p><blockquote><p><strong>数据样本扰动</strong>，即利用具有差异的数据集来训练不同的基学习器。例如：有放回自助采样法，但此类做法只对那些不稳定学习算法十分有效，例如：决策树和神经网络等，训练集的稍微改变能导致学习器的显著变动。<br><strong>输入属性扰动</strong>，即随机选取原空间的一个子空间来训练基学习器。例如：随机森林，从初始属性集中抽取子集，再基于每个子集来训练基学习器。但若训练集只包含少量属性，则不宜使用属性扰动。<br><strong>输出表示扰动</strong>，此类做法可对训练样本的类标稍作变动，或对基学习器的输出进行转化。<br><strong>算法参数扰动</strong>，通过随机设置不同的参数，例如：神经网络中，随机初始化权重与随机设置隐含层节点数。</p></blockquote><p>在此，集成学习就介绍完毕，看到这里，大家也会发现集成学习实质上是一种通用框架，可以使用任何一种基学习器，从而改进单个学习器的泛化性能。据说数据挖掘竞赛KDDCup历年的冠军几乎都使用了集成学习，看来的确是个好东西~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇主要介绍了鼎鼎大名的EM算法，从算法思想到数学公式推导（边际似然引入隐变量，Jensen不等式简化求导），EM算法实际上可以理解为一种坐标下降法，首先固定一个变量，接着求另外变量的最优解，通过其优美的“两步走”策略能较好地估计隐变量的值。本篇将继续讨论下一类经典算法—集成学习。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(9)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/</id>
    <published>2020-07-27T01:20:38.000Z</published>
    <updated>2020-07-27T11:02:42.228Z</updated>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了贝叶斯分类器，从贝叶斯公式到贝叶斯决策论，再到通过极大似然法估计类条件概率，贝叶斯分类器的训练就是参数估计的过程。朴素贝叶斯则是“属性条件独立性假设”下的特例，它避免了假设属性联合分布过于经验性和训练集不足引起参数估计较大偏差两个大问题，最后介绍的拉普拉斯修正将概率值进行平滑处理。本篇将介绍另一个当选为数据挖掘十大算法之一的<strong>EM算法</strong>。<br><a id="more"></a></p><p>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:25px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="8、EM算法"><a href="#8、EM算法" class="headerlink" title="8、EM算法"></a><strong>8、EM算法</strong></h1><p>EM（Expectation-Maximization）算法是一种常用的估计参数隐变量的利器，也称为“期望最大算法”，是数据挖掘的十大经典算法之一。EM算法主要应用于训练集样本不完整即存在隐变量时的情形（例如某个属性值未知），通过其独特的“两步走”策略能较好地估计出隐变量的值。</p><h2 id="8-1-EM算法思想"><a href="#8-1-EM算法思想" class="headerlink" title="8.1 EM算法思想"></a><strong>8.1 EM算法思想</strong></h2><p>EM是一种迭代式的方法，它的基本思想就是：若样本服从的分布参数θ已知，则可以根据已观测到的训练样本推断出隐变量Z的期望值（E步），若Z的值已知则运用最大似然法估计出新的θ值（M步）。重复这个过程直到Z和θ值不再发生变化。</p><p>简单来讲：假设我们想估计A和B这两个参数，在开始状态下二者都是未知的，但如果知道了A的信息就可以得到B的信息，反过来知道了B也就得到了A。可以考虑首先赋予A某种初值，以此得到B的估计值，然后从B的当前值出发，重新估计A的取值，这个过程一直持续到收敛为止。</p><p><img src="https://i.loli.net/2018/10/18/5bc843bf53eb2.png" alt="1.png"></p><p>现在再来回想聚类的代表算法K-Means：【首先随机选择类中心=&gt;将样本点划分到类簇中=&gt;重新计算类中心=&gt;不断迭代直至收敛】，不难发现这个过程和EM迭代的方法极其相似，事实上，若将样本的类别看做为“隐变量”（latent variable）Z，类中心看作样本的分布参数θ，K-Means就是通过EM算法来进行迭代的，与我们这里不同的是，K-Means的目标是最小化样本点到其对应类中心的距离和，上述为极大化似然函数。</p><h2 id="8-2-EM算法数学推导"><a href="#8-2-EM算法数学推导" class="headerlink" title="8.2 EM算法数学推导"></a><strong>8.2 EM算法数学推导</strong></h2><p>在上篇极大似然法中，当样本属性值都已知时，我们很容易通过极大化对数似然，接着对每个参数求偏导计算出参数的值。但当存在隐变量时，就无法直接求解，此时我们通常最大化已观察数据的对数“边际似然”（marginal likelihood）。</p><p><img src="https://i.loli.net/2018/10/18/5bc843bfd84d2.png" alt="2.png"></p><p>这时候，通过边缘似然将隐变量Z引入进来，对于参数估计，现在与最大似然不同的只是似然函数式中多了一个未知的变量Z，也就是说我们的目标是找到适合的θ和Z让L(θ)最大，这样我们也可以分别对未知的θ和Z求偏导，再令其等于0。</p><p>然而观察上式可以发现，和的对数（ln(x1+x2+x3)）求导十分复杂，那能否通过变换上式得到一种求导简单的新表达式呢？这时候 Jensen不等式就派上用场了，先回顾一下高等数学凸函数的内容：</p><p><strong>Jensen’s inequality</strong>：过一个凸函数上任意两点所作割线一定在这两点间的函数图象的上方。理解起来也十分简单，对于凸函数f(x)’’&gt;0，即曲线的变化率是越来越大单调递增的，所以函数越到后面增长越厉害，这样在一个区间下，函数的均值就会大一些了。</p><p><img src="https://i.loli.net/2018/10/18/5bc843c064c72.png" alt="3.png"></p><p>因为ln(*)函数为凹函数，故可以将上式“和的对数”变为“对数的和”，这样就很容易求导了。</p><p><img src="https://i.loli.net/2018/10/18/5bc843c3490ad.png" alt="4.png"></p><p>接着求解Qi和θ：首先固定θ（初始值），通过求解Qi使得J（θ，Q）在θ处与L（θ）相等，即求出L（θ）的下界；然后再固定Qi，调整θ，最大化下界J（θ，Q）。不断重复两个步骤直到稳定。通过jensen不等式的性质，Qi的计算公式实际上就是后验概率：</p><p><img src="https://i.loli.net/2018/10/18/5bc843c21276c.png" alt="5.png"></p><p>通过数学公式的推导，简单来理解这一过程：固定θ计算Q的过程就是在建立L（θ）的下界，即通过jenson不等式得到的下界（E步）；固定Q计算θ则是使得下界极大化（M步），从而不断推高边缘似然L（θ）。从而循序渐进地计算出L（θ）取得极大值时隐变量Z的估计值。</p><p>EM算法也可以看作一种“坐标下降法”，首先固定一个值，对另外一个值求极值，不断重复直到收敛。这时候也许大家就有疑问，问什么不直接这两个家伙求偏导用梯度下降呢？这时候就是坐标下降的优势，有些特殊的函数，例如曲线函数z=y^2+x^2+x^2y+xy+…，无法直接求导，这时如果先固定其中的一个变量，再对另一个变量求极值，则变得可行。</p><p><img src="https://i.loli.net/2018/10/18/5bc843c34e7ff.png" alt="6.png"></p><h2 id="8-3-EM算法流程"><a href="#8-3-EM算法流程" class="headerlink" title="8.3 EM算法流程"></a><strong>8.3 EM算法流程</strong></h2><p>看完数学推导，算法的流程也就十分简单了，这里有两个版本，版本一来自西瓜书，周天使的介绍十分简洁；版本二来自于大牛的博客。结合着数学推导，自认为版本二更具有逻辑性，两者唯一的区别就在于版本二多出了红框的部分，这里我也没得到答案，欢迎骚扰讨论~</p><p><strong>版本一：</strong></p><p><img src="https://i.loli.net/2018/10/18/5bc843c0e19db.png" alt="7.png"></p><p><strong>版本二：</strong></p><p><img src="https://i.loli.net/2018/10/18/5bc843c34775b.png" alt="8.png"></p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇主要介绍了贝叶斯分类器，从贝叶斯公式到贝叶斯决策论，再到通过极大似然法估计类条件概率，贝叶斯分类器的训练就是参数估计的过程。朴素贝叶斯则是“属性条件独立性假设”下的特例，它避免了假设属性联合分布过于经验性和训练集不足引起参数估计较大偏差两个大问题，最后介绍的拉普拉斯修正将概率值进行平滑处理。本篇将介绍另一个当选为数据挖掘十大算法之一的&lt;strong&gt;EM算法&lt;/strong&gt;。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(8)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/</id>
    <published>2020-07-27T00:20:38.000Z</published>
    <updated>2020-07-27T11:05:50.627Z</updated>
    
    <content type="html"><![CDATA[<p>上篇主要介绍和讨论了支持向量机。从最初的分类函数，通过最大化分类间隔，max(1/||w||)，min(1/2||w||^2)，凸二次规划，朗格朗日函数，对偶问题，一直到最后的SMO算法求解，都为寻找一个最优解。接着引入核函数将低维空间映射到高维特征空间，解决了非线性可分的情形。最后介绍了软间隔支持向量机，解决了outlier挤歪超平面的问题。本篇将讨论一个经典的统计学习算法—<strong>贝叶斯分类器</strong>。<br><a id="more"></a></p><p>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:25px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="7、贝叶斯分类器"><a href="#7、贝叶斯分类器" class="headerlink" title="7、贝叶斯分类器"></a><strong>7、贝叶斯分类器</strong></h1><p>贝叶斯分类器是一种概率框架下的统计学习分类器，对分类任务而言，假设在相关概率都已知的情况下，贝叶斯分类器考虑如何基于这些概率为样本判定最优的类标。在开始介绍贝叶斯决策论之前，我们首先来回顾下概率论委员会常委—贝叶斯公式。</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd7a2575.png" alt="1.png"></p><h2 id="7-1-贝叶斯决策论"><a href="#7-1-贝叶斯决策论" class="headerlink" title="7.1 贝叶斯决策论"></a><strong>7.1 贝叶斯决策论</strong></h2><p>若将上述定义中样本空间的划分Bi看做为类标，A看做为一个新的样本，则很容易将条件概率理解为样本A是类别Bi的概率。在机器学习训练模型的过程中，往往我们都试图去优化一个风险函数，因此在概率框架下我们也可以为贝叶斯定义“<strong>条件风险</strong>”（conditional risk）。</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd15db94.png" alt="2.png"></p><p>我们的任务就是寻找一个判定准则最小化所有样本的条件风险总和，因此就有了<strong>贝叶斯判定准则</strong>（Bayes decision rule）:为最小化总体风险，只需在每个样本上选择那个使得条件风险最小的类标。</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd308600.png" alt="3.png"></p><p>若损失函数λ取0-1损失，则有：</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd37c502.png" alt="4.png"></p><p>即对于每个样本x，选择其后验概率P（c | x）最大所对应的类标，能使得总体风险函数最小，从而将原问题转化为估计后验概率P（c | x）。一般这里有两种策略来对后验概率进行估计：</p><pre><code>* 判别式模型：直接对 P（c | x）进行建模求解。例我们前面所介绍的决策树、神经网络、SVM都是属于判别式模型。* 生成式模型：通过先对联合分布P（x,c）建模，从而进一步求解 P（c | x）。</code></pre><p>贝叶斯分类器就属于生成式模型，基于贝叶斯公式对后验概率P（c | x） 进行一项神奇的变换，巴拉拉能量…. P（c | x）变身：</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd501ad3.png" alt="5.png"></p><p>对于给定的样本x，P（x）与类标无关，P（c）称为类先验概率，p（x | c ）称为类条件概率。这时估计后验概率P（c | x）就变成为估计类先验概率和类条件概率的问题。对于先验概率和后验概率，在看这章之前也是模糊了我好久，这里普及一下它们的基本概念。</p><pre><code>* 先验概率： 根据以往经验和分析得到的概率。* 后验概率：后验概率是基于新的信息，修正原来的先验概率后所获得的更接近实际情况的概率估计。</code></pre><p>实际上先验概率就是在没有任何结果出来的情况下估计的概率，而后验概率则是在有一定依据后的重新估计，直观意义上后验概率就是条件概率。下面直接上Wiki上的一个例子，简单粗暴快速完事…</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd799610.png" alt="6.png"></p><p>回归正题，对于类先验概率P（c），p（c）就是样本空间中各类样本所占的比例，根据大数定理（当样本足够多时，频率趋于稳定等于其概率），这样当训练样本充足时，p(c)可以使用各类出现的频率来代替。因此只剩下类条件概率p（x | c ），它表达的意思是在类别c中出现x的概率，它涉及到属性的联合概率问题，若只有一个离散属性还好，当属性多时采用频率估计起来就十分困难，因此这里一般采用极大似然法进行估计。</p><h2 id="7-2-极大似然法"><a href="#7-2-极大似然法" class="headerlink" title="7.2 极大似然法"></a><strong>7.2 极大似然法</strong></h2><p>极大似然估计（Maximum Likelihood Estimation，简称MLE），是一种根据数据采样来估计概率分布的经典方法。常用的策略是先假定总体具有某种确定的概率分布，再基于训练样本对概率分布的参数进行估计。运用到类条件概率p（x | c ）中，假设p（x | c ）服从一个参数为θ的分布，问题就变为根据已知的训练样本来估计θ。极大似然法的核心思想就是：估计出的参数使得已知样本出现的概率最大，即使得训练数据的似然最大。</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd70fb73.png" alt="7.png"></p><p>所以，贝叶斯分类器的训练过程就是参数估计。总结最大似然法估计参数的过程，一般分为以下四个步骤：</p><pre><code>* 1.写出似然函数；* 2.对似然函数取对数，并整理；* 3.求导数，令偏导数为0，得到似然方程组；* 4.解似然方程组，得到所有参数即为所求。</code></pre><p>例如：假设样本属性都是连续值，p（x | c ）服从一个多维高斯分布，则通过MLE计算出的参数刚好分别为：</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd705729.png" alt="8.png"></p><p>上述结果看起来十分合乎实际，但是采用最大似然法估计参数的效果很大程度上依赖于作出的假设是否合理，是否符合潜在的真实数据分布。这就需要大量的经验知识，搞统计越来越值钱也是这个道理，大牛们掐指一算比我们搬砖几天更有效果。</p><h2 id="7-3-朴素贝叶斯分类器"><a href="#7-3-朴素贝叶斯分类器" class="headerlink" title="7.3 朴素贝叶斯分类器"></a><strong>7.3 朴素贝叶斯分类器</strong></h2><p>不难看出：原始的贝叶斯分类器最大的问题在于联合概率密度函数的估计，首先需要根据经验来假设联合概率分布，其次当属性很多时，训练样本往往覆盖不够，参数的估计会出现很大的偏差。为了避免这个问题，朴素贝叶斯分类器（naive Bayes classifier）采用了“属性条件独立性假设”，即样本数据的所有属性之间相互独立。这样类条件概率p（x | c ）可以改写为：</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd55e102.png" alt="9.png"></p><p>这样，为每个样本估计类条件概率变成为每个样本的每个属性估计类条件概率。</p><p><img src="https://i.loli.net/2018/10/18/5bc83fd6678cd.png" alt="10.png"></p><p>相比原始贝叶斯分类器，朴素贝叶斯分类器基于单个的属性计算类条件概率更加容易操作，需要注意的是：若某个属性值在训练集中和某个类别没有一起出现过，这样会抹掉其它的属性信息，因为该样本的类条件概率被计算为0。因此在估计概率值时，常常用进行平滑（smoothing）处理，拉普拉斯修正（Laplacian correction）就是其中的一种经典方法，具体计算方法如下：</p><p><img src="https://i.loli.net/2018/10/18/5bc83fe54aaed.png" alt="11.png"></p><p>当训练集越大时，拉普拉斯修正引入的影响越来越小。对于贝叶斯分类器，模型的训练就是参数估计，因此可以事先将所有的概率储存好，当有新样本需要判定时，直接查表计算即可。</p><p>针对朴素贝叶斯，人们觉得它too sample，sometimes too naive！因此又提出了半朴素的贝叶斯分类器，具体有SPODE、TAN、贝叶斯网络等来刻画属性之间的依赖关系，此处不进行深入，等哪天和贝叶斯邂逅了再回来讨论。在此鼎鼎大名的贝叶斯介绍完毕，下一篇将介绍这一章剩下的内容—EM算法，朴素贝叶斯和EM算法同为数据挖掘的十大经典算法，想着还是单独介绍吧~</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇主要介绍和讨论了支持向量机。从最初的分类函数，通过最大化分类间隔，max(1/||w||)，min(1/2||w||^2)，凸二次规划，朗格朗日函数，对偶问题，一直到最后的SMO算法求解，都为寻找一个最优解。接着引入核函数将低维空间映射到高维特征空间，解决了非线性可分的情形。最后介绍了软间隔支持向量机，解决了outlier挤歪超平面的问题。本篇将讨论一个经典的统计学习算法—&lt;strong&gt;贝叶斯分类器&lt;/strong&gt;。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(7)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/</id>
    <published>2020-07-26T23:20:38.000Z</published>
    <updated>2020-07-27T11:05:45.960Z</updated>
    
    <content type="html"><![CDATA[<p>上篇主要介绍了神经网络。首先从生物学神经元出发，引出了它的数学抽象模型—MP神经元以及由两层神经元组成的感知机模型，并基于梯度下降的方法描述了感知机模型的权值调整规则。由于简单的感知机不能处理线性不可分的情形，因此接着引入了含隐层的前馈型神经网络，BP神经网络则是其中最为成功的一种学习方法，它使用误差逆传播的方法来逐层调节连接权。最后简单介绍了局部/全局最小以及目前十分火热的深度学习的概念。本篇围绕的核心则是曾经一度取代过神经网络的另一种监督学习算法—<strong>支持向量机</strong>（Support Vector Machine），简称<strong>SVM</strong>。<br><a id="more"></a></p><p>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:25px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="6、支持向量机"><a href="#6、支持向量机" class="headerlink" title="6、支持向量机"></a><strong>6、支持向量机</strong></h1><p>支持向量机是一种经典的二分类模型，基本模型定义为特征空间中最大间隔的线性分类器，其学习的优化目标便是间隔最大化，因此支持向量机本身可以转化为一个凸二次规划求解的问题。</p><h2 id="6-1-函数间隔与几何间隔"><a href="#6-1-函数间隔与几何间隔" class="headerlink" title="6.1 函数间隔与几何间隔"></a><strong>6.1 函数间隔与几何间隔</strong></h2><p>对于二分类学习，假设现在的数据是线性可分的，这时分类学习最基本的想法就是找到一个合适的超平面，该超平面能够将不同类别的样本分开，类似二维平面使用ax+by+c=0来表示，超平面实际上表示的就是高维的平面，如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f6a2ec8a.png" alt="1.png"></p><p>对数据点进行划分时，易知：当超平面距离与它最近的数据点的间隔越大，分类的鲁棒性越好，即当新的数据点加入时，超平面对这些点的适应性最强，出错的可能性最小。因此需要让所选择的超平面能够最大化这个间隔Gap（如下图所示）， 常用的间隔定义有两种，一种称之为函数间隔，一种为几何间隔，下面将分别介绍这两种间隔，并对SVM为什么会选用几何间隔做了一些阐述。</p><p><img src="https://i.loli.net/2018/10/17/5bc72f6a06d5a.png" alt="2.png"></p><h3 id="6-1-1-函数间隔"><a href="#6-1-1-函数间隔" class="headerlink" title="6.1.1 函数间隔"></a><strong>6.1.1 函数间隔</strong></h3><p>在超平面w’x+b=0确定的情况下，|w’x<em>+b|能够代表点x</em>距离超平面的远近，易知：当w’x<em>+b&gt;0时，表示x</em>在超平面的一侧（正类，类标为1），而当w’x<em>+b&lt;0时，则表示x</em>在超平面的另外一侧（负类，类别为-1），因此（w’x<em>+b）y</em> 的正负性恰能表示数据点x<em>是否被分类正确。于是便引出了<em>*函数间隔</em></em>的定义（functional margin）:</p><p><img src="https://i.loli.net/2018/10/17/5bc72f690a14b.png" alt="3.png"></p><p>而超平面（w,b）关于所有样本点（Xi，Yi）的函数间隔最小值则为超平面在训练数据集T上的函数间隔：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f690ac26.png" alt="4.png"></p><p>可以看出：这样定义的函数间隔在处理SVM上会有问题，当超平面的两个参数w和b同比例改变时，函数间隔也会跟着改变，但是实际上超平面还是原来的超平面，并没有变化。例如：w1x1+w2x2+w3x3+b=0其实等价于2w1x1+2w2x2+2w3x3+2b=0，但计算的函数间隔却翻了一倍。从而引出了能真正度量点到超平面距离的概念—几何间隔（geometrical margin）。</p><h3 id="6-1-2-几何间隔"><a href="#6-1-2-几何间隔" class="headerlink" title="6.1.2 几何间隔"></a><strong>6.1.2 几何间隔</strong></h3><p><strong>几何间隔</strong>代表的则是数据点到超平面的真实距离，对于超平面w’x+b=0，w代表的是该超平面的法向量，设x<em>为超平面外一点x在法向量w方向上的投影点，x与超平面的距离为r，则有x</em>=x-r(w/||w||)，又x<em>在超平面上，即w’x</em>+b=0，代入即可得：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f697d499.png" alt="5.png"></p><p>为了得到r的绝对值，令r呈上其对应的类别y，即可得到几何间隔的定义：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f696fd10.png" alt="6.png"></p><p>从上述函数间隔与几何间隔的定义可以看出：实质上函数间隔就是|w’x+b|，而几何间隔就是点到超平面的距离。</p><h2 id="6-2-最大间隔与支持向量"><a href="#6-2-最大间隔与支持向量" class="headerlink" title="6.2 最大间隔与支持向量"></a><strong>6.2 最大间隔与支持向量</strong></h2><p>通过前面的分析可知：函数间隔不适合用来最大化间隔，因此这里我们要找的最大间隔指的是几何间隔，于是最大间隔分类器的目标函数定义为：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f69af163.png" alt="7.png"></p><p>一般地，我们令r^为1（这样做的目的是为了方便推导和目标函数的优化），从而上述目标函数转化为：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f697bb1d.png" alt="8.png"></p><p>对于y(w’x+b)=1的数据点，即下图中位于w’x+b=1或w’x+b=-1上的数据点，我们称之为<strong>支持向量</strong>（support vector），易知：对于所有的支持向量，它们恰好满足y<em>(w’x</em>+b)=1，而所有不是支持向量的点，有y<em>(w’x</em>+b)&gt;1。</p><p><img src="https://i.loli.net/2018/10/17/5bc72f6a838c4.png" alt="9.png"></p><h2 id="6-3-从原始优化问题到对偶问题"><a href="#6-3-从原始优化问题到对偶问题" class="headerlink" title="6.3 从原始优化问题到对偶问题"></a><strong>6.3 从原始优化问题到对偶问题</strong></h2><p>对于上述得到的目标函数，求1/||w||的最大值相当于求||w||^2的最小值，因此很容易将原来的目标函数转化为：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f6978cbb.png" alt="10.png"></p><p>即变为了一个带约束的凸二次规划问题，按书上所说可以使用现成的优化计算包（QP优化包）求解，但由于SVM的特殊性，一般我们将原问题变换为它的<strong>对偶问题</strong>，接着再对其对偶问题进行求解。为什么通过对偶问题进行求解，有下面两个原因：</p><pre><code>* 一是因为使用对偶问题更容易求解；* 二是因为通过对偶问题求解出现了向量内积的形式，从而能更加自然地引出核函数。</code></pre><p>对偶问题，顾名思义，可以理解成优化等价的问题，更一般地，是将一个原始目标函数的最小化转化为它的对偶函数最大化的问题。对于当前的优化问题，首先我们写出它的朗格朗日函数：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f9332be7.png" alt="11.png"></p><p>上式很容易验证：当其中有一个约束条件不满足时，L的最大值为 ∞（只需令其对应的α为 ∞即可）；当所有约束条件都满足时，L的最大值为1/2||w||^2（此时令所有的α为0），因此实际上原问题等价于：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f93321c5.png" alt="12.png"></p><p>由于这个的求解问题不好做，因此一般我们将最小和最大的位置交换一下（需满足KKT条件） ，变成原问题的对偶问题：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f9330967.png" alt="13.png"></p><p>这样就将原问题的求最小变成了对偶问题求最大（用对偶这个词还是很形象），接下来便可以先求L对w和b的极小，再求L对α的极大。</p><p>（1）首先求L对w和b的极小，分别求L关于w和b的偏导，可以得出：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f9333e66.png" alt="14.png"></p><p>将上述结果代入L得到：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f935ae21.png" alt="15.png"></p><p>（2）接着L关于α极大求解α（通过SMO算法求解，此处不做深入）。</p><p><img src="https://i.loli.net/2018/10/17/5bc72f9338a9d.png" alt="16.png"></p><p>（3）最后便可以根据求解出的α，计算出w和b，从而得到分类超平面函数。</p><p><img src="https://i.loli.net/2018/10/17/5bc72f93419ca.png" alt="17.png"></p><p>在对新的点进行预测时，实际上就是将数据点x*代入分类函数f(x)=w’x+b中，若f(x)&gt;0，则为正类，f(x)&lt;0，则为负类，根据前面推导得出的w与b，分类函数如下所示，此时便出现了上面所提到的内积形式。</p><p><img src="https://i.loli.net/2018/10/17/5bc72f9353166.png" alt="18.png"></p><p>这里实际上只需计算新样本与支持向量的内积，因为对于非支持向量的数据点，其对应的拉格朗日乘子一定为0，根据最优化理论（K-T条件），对于不等式约束y(w’x+b)-1≥0，满足：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f933c947.png" alt="19.png">        </p><h2 id="6-4-核函数"><a href="#6-4-核函数" class="headerlink" title="6.4 核函数"></a><strong>6.4 核函数</strong></h2><p>由于上述的超平面只能解决线性可分的问题，对于线性不可分的问题，例如：异或问题，我们需要使用核函数将其进行推广。一般地，解决线性不可分问题时，常常采用<strong>映射</strong>的方式，将低维原始空间映射到高维特征空间，使得数据集在高维空间中变得线性可分，从而再使用线性学习器分类。如果原始空间为有限维，即属性数有限，那么总是存在一个高维特征空间使得样本线性可分。若∅代表一个映射，则在特征空间中的划分函数变为：</p><p><img src="https://i.loli.net/2018/10/17/5bc72f934303e.png" alt="20.png"></p><p>按照同样的方法，先写出新目标函数的拉格朗日函数，接着写出其对偶问题，求L关于w和b的极大，最后运用SOM求解α。可以得出：</p><p>（1）原对偶问题变为：</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc68b3b.png" alt="21.png"></p><p>（2）原分类函数变为：<br>​    <img src="https://i.loli.net/2018/10/17/5bc730cc1b673.png" alt="22.png"></p><p>求解的过程中，只涉及到了高维特征空间中的内积运算，由于特征空间的维数可能会非常大，例如：若原始空间为二维，映射后的特征空间为5维，若原始空间为三维，映射后的特征空间将是19维，之后甚至可能出现无穷维，根本无法进行内积运算了，此时便引出了<strong>核函数</strong>（Kernel）的概念。</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc49adc.png" alt="23.png"></p><p>因此，核函数可以直接计算隐式映射到高维特征空间后的向量内积，而不需要显式地写出映射后的结果，它虽然完成了将特征从低维到高维的转换，但最终却是在低维空间中完成向量内积计算，与高维特征空间中的计算等效<strong>（低维计算，高维表现）</strong>，从而避免了直接在高维空间无法计算的问题。引入核函数后，原来的对偶问题与分类函数则变为：</p><p>（1）对偶问题：</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc173b2.png" alt="24.png"></p><p>（2）分类函数：</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc05959.png" alt="25.png"></p><p>因此，在线性不可分问题中，核函数的选择成了支持向量机的最大变数，若选择了不合适的核函数，则意味着将样本映射到了一个不合适的特征空间，则极可能导致性能不佳。同时，核函数需要满足以下这个必要条件：</p><p><img src="https://i.loli.net/2018/10/17/5bc730ccc468c.png" alt="26.png"></p><p>由于核函数的构造十分困难，通常我们都是从一些常用的核函数中选择，下面列出了几种常用的核函数：</p><p><img src="https://i.loli.net/2018/10/17/5bc730ccc541a.png" alt="27.png"></p><h2 id="6-5-软间隔支持向量机"><a href="#6-5-软间隔支持向量机" class="headerlink" title="6.5 软间隔支持向量机"></a><strong>6.5 软间隔支持向量机</strong></h2><p>前面的讨论中，我们主要解决了两个问题：当数据线性可分时，直接使用最大间隔的超平面划分；当数据线性不可分时，则通过核函数将数据映射到高维特征空间，使之线性可分。然而在现实问题中，对于某些情形还是很难处理，例如数据中有<strong>噪声</strong>的情形，噪声数据（<strong>outlier</strong>）本身就偏离了正常位置，但是在前面的SVM模型中，我们要求所有的样本数据都必须满足约束，如果不要这些噪声数据还好，当加入这些outlier后导致划分超平面被挤歪了，如下图所示，对支持向量机的泛化性能造成很大的影响。</p><p><img src="https://i.loli.net/2018/10/17/5bc730ccce68e.png" alt="28.png"></p><p>为了解决这一问题，我们需要允许某一些数据点不满足约束，即可以在一定程度上偏移超平面，同时使得不满足约束的数据点尽可能少，这便引出了<strong>“软间隔”支持向量机</strong>的概念</p><pre><code>* 允许某些数据点不满足约束y(w&#39;x+b)≥1；* 同时又使得不满足约束的样本尽可能少。</code></pre><p>这样优化目标变为：</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc6c9fe.png" alt="29.png"></p><p>如同阶跃函数，0/1损失函数虽然表示效果最好，但是数学性质不佳。因此常用其它函数作为“替代损失函数”。</p><p><img src="https://i.loli.net/2018/10/17/5bc730cc5e5a9.png" alt="30.png"></p><p>支持向量机中的损失函数为<strong>hinge损失</strong>，引入<strong>“松弛变量”</strong>，目标函数与约束条件可以写为：</p><p><img src="https://i.loli.net/2018/10/17/5bc7317aa3411.png" alt="31.png"></p><p>其中C为一个参数，控制着目标函数与新引入正则项之间的权重，这样显然每个样本数据都有一个对应的松弛变量，用以表示该样本不满足约束的程度，将新的目标函数转化为拉格朗日函数得到：</p><p><img src="https://i.loli.net/2018/10/17/5bc7317a4c96e.png" alt="32.png"></p><p>按照与之前相同的方法，先让L求关于w，b以及松弛变量的极小，再使用SMO求出α，有：</p><p><img src="https://i.loli.net/2018/10/17/5bc7317a6dff2.png" alt="33.png"></p><p>将w代入L化简，便得到其对偶问题：</p><p><img src="https://i.loli.net/2018/10/17/5bc7317ab6646.png" alt="34.png"></p><p>将“软间隔”下产生的对偶问题与原对偶问题对比可以发现：新的对偶问题只是约束条件中的α多出了一个上限C，其它的完全相同，因此在引入核函数处理线性不可分问题时，便能使用与“硬间隔”支持向量机完全相同的方法。</p><p>——在此SVM就介绍完毕。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇主要介绍了神经网络。首先从生物学神经元出发，引出了它的数学抽象模型—MP神经元以及由两层神经元组成的感知机模型，并基于梯度下降的方法描述了感知机模型的权值调整规则。由于简单的感知机不能处理线性不可分的情形，因此接着引入了含隐层的前馈型神经网络，BP神经网络则是其中最为成功的一种学习方法，它使用误差逆传播的方法来逐层调节连接权。最后简单介绍了局部/全局最小以及目前十分火热的深度学习的概念。本篇围绕的核心则是曾经一度取代过神经网络的另一种监督学习算法—&lt;strong&gt;支持向量机&lt;/strong&gt;（Support Vector Machine），简称&lt;strong&gt;SVM&lt;/strong&gt;。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(6)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/</id>
    <published>2020-07-26T22:20:38.000Z</published>
    <updated>2020-07-27T11:02:23.402Z</updated>
    
    <content type="html"><![CDATA[<p>上篇主要讨论了决策树算法。首先从决策树的基本概念出发，引出决策树基于树形结构进行决策，进一步介绍了构造决策树的递归流程以及其递归终止条件，在递归的过程中，划分属性的选择起到了关键作用，因此紧接着讨论了三种评估属性划分效果的经典算法，介绍了剪枝策略来解决原生决策树容易产生的过拟合问题，最后简述了属性连续值/缺失值的处理方法。本篇将讨论现阶段十分热门的另一个经典监督学习算法—神经网络（neural network）。<br><a id="more"></a></p><p>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:25px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="5、神经网络"><a href="#5、神经网络" class="headerlink" title="5、神经网络"></a><strong>5、神经网络</strong></h1><p>在机器学习中，神经网络一般指的是“神经网络学习”，是机器学习与神经网络两个学科的交叉部分。所谓神经网络，目前用得最广泛的一个定义是“神经网络是由具有适应性的简单单元组成的广泛并行互连的网络，它的组织能够模拟生物神经系统对真实世界物体所做出的交互反应”。</p><h2 id="5-1-神经元模型"><a href="#5-1-神经元模型" class="headerlink" title="5.1 神经元模型"></a><strong>5.1 神经元模型</strong></h2><p>神经网络中最基本的单元是神经元模型（neuron）。在生物神经网络的原始机制中，每个神经元通常都有多个树突（dendrite），一个轴突（axon）和一个细胞体（cell body），树突短而多分支，轴突长而只有一个；在功能上，树突用于传入其它神经元传递的神经冲动，而轴突用于将神经冲动传出到其它神经元，当树突或细胞体传入的神经冲动使得神经元兴奋时，该神经元就会通过轴突向其它神经元传递兴奋。神经元的生物学结构如下图所示，不得不说高中的生化知识大学忘得可是真干净…</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb6cc11.png" alt="1.png"></p><p>一直沿用至今的“M-P神经元模型”正是对这一结构进行了抽象，也称“阈值逻辑单元“，其中树突对应于输入部分，每个神经元收到n个其他神经元传递过来的输入信号，这些信号通过带权重的连接传递给细胞体，这些权重又称为连接权（connection weight）。细胞体分为两部分，前一部分计算总输入值（即输入信号的加权和，或者说累积电平），后一部分先计算总输入值与该神经元阈值的差值，然后通过激活函数（activation function）的处理，产生输出从轴突传送给其它神经元。M-P神经元模型如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb7be44.png" alt="2.png"></p><p>与线性分类十分相似，神经元模型最理想的激活函数也是阶跃函数，即将神经元输入值与阈值的差值映射为输出值1或0，若差值大于零输出1，对应兴奋；若差值小于零则输出0，对应抑制。但阶跃函数不连续，不光滑，故在M-P神经元模型中，也采用Sigmoid函数来近似， Sigmoid函数将较大范围内变化的输入值挤压到 (0,1) 输出值范围内，所以也称为挤压函数（squashing function）。</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb40dc5.png" alt="3.png"></p><p>将多个神经元按一定的层次结构连接起来，就得到了神经网络。它是一种包含多个参数的模型，比方说10个神经元两两连接，则有100个参数需要学习（每个神经元有9个连接权以及1个阈值），若将每个神经元都看作一个函数，则整个神经网络就是由这些函数相互嵌套而成。</p><h2 id="5-2-感知机与多层网络"><a href="#5-2-感知机与多层网络" class="headerlink" title="5.2 感知机与多层网络"></a><strong>5.2 感知机与多层网络</strong></h2><p>感知机（Perceptron）是由两层神经元组成的一个简单模型，但只有输出层是M-P神经元，即只有输出层神经元进行激活函数处理，也称为功能神经元（functional neuron）；输入层只是接受外界信号（样本属性）并传递给输出层（输入层的神经元个数等于样本的属性数目），而没有激活函数。这样一来，感知机与之前线性模型中的对数几率回归的思想基本是一样的，都是通过对属性加权与另一个常数求和，再使用sigmoid函数将这个输出值压缩到0-1之间，从而解决分类问题。不同的是感知机的输出层应该可以有多个神经元，从而可以实现多分类问题，同时两个模型所用的参数估计方法十分不同。</p><p>给定训练集，则感知机的n+1个参数（n个权重+1个阈值）都可以通过学习得到。阈值Θ可以看作一个输入值固定为-1的哑结点的权重ωn+1，即假设有一个固定输入xn+1=-1的输入层神经元，其对应的权重为ωn+1，这样就把权重和阈值统一为权重的学习了。简单感知机的结构如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb3fdf0.png" alt="4.png"></p><p>感知机权重的学习规则如下：对于训练样本（x，y），当该样本进入感知机学习后，会产生一个输出值，若该输出值与样本的真实标记不一致，则感知机会对权重进行调整，若激活函数为阶跃函数，则调整的方法为（基于梯度下降法）：</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb3ba63.png" alt="5.png"></p><p>其中 η∈（0，1）称为学习率，可以看出感知机是通过逐个样本输入来更新权重，首先设定好初始权重（一般为随机），逐个地输入样本数据，若输出值与真实标记相同则继续输入下一个样本，若不一致则更新权重，然后再重新逐个检验，直到每个样本数据的输出值都与真实标记相同。容易看出：感知机模型总是能将训练数据的每一个样本都预测正确，和决策树模型总是能将所有训练数据都分开一样，感知机模型很容易产生过拟合问题。</p><p>由于感知机模型只有一层功能神经元，因此其功能十分有限，只能处理线性可分的问题，对于这类问题，感知机的学习过程一定会收敛（converge），因此总是可以求出适当的权值。但是对于像书上提到的异或问题，只通过一层功能神经元往往不能解决，因此要解决非线性可分问题，需要考虑使用多层功能神经元，即神经网络。多层神经网络的拓扑结构如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb58ec6.png" alt="6.png"></p><p>在神经网络中，输入层与输出层之间的层称为隐含层或隐层（hidden layer），隐层和输出层的神经元都是具有激活函数的功能神经元。只需包含一个隐层便可以称为多层神经网络，常用的神经网络称为“多层前馈神经网络”（multi-layer feedforward neural network），该结构满足以下几个特点：</p><pre><code>* 每层神经元与下一层神经元之间完全互连* 神经元之间不存在同层连接* 神经元之间不存在跨层连接</code></pre><p><img src="https://i.loli.net/2018/10/17/5bc72cbb47ff8.png" alt="7.png"></p><p>根据上面的特点可以得知：这里的“前馈”指的是网络拓扑结构中不存在环或回路，而不是指该网络只能向前传播而不能向后传播（下节中的BP神经网络正是基于前馈神经网络而增加了反馈调节机制）。神经网络的学习过程就是根据训练数据来调整神经元之间的“连接权”以及每个神经元的阈值，换句话说：神经网络所学习到的东西都蕴含在网络的连接权与阈值中。</p><h2 id="5-3-BP神经网络算法"><a href="#5-3-BP神经网络算法" class="headerlink" title="5.3 BP神经网络算法"></a><strong>5.3 BP神经网络算法</strong></h2><p>由上面可以得知：神经网络的学习主要蕴含在权重和阈值中，多层网络使用上面简单感知机的权重调整规则显然不够用了，BP神经网络算法即误差逆传播算法（error BackPropagation）正是为学习多层前馈神经网络而设计，BP神经网络算法是迄今为止最成功的的神经网络学习算法。</p><p>一般而言，只需包含一个足够多神经元的隐层，就能以任意精度逼近任意复杂度的连续函数[Hornik et al.,1989]，故下面以训练单隐层的前馈神经网络为例，介绍BP神经网络的算法思想。</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb92ff5.png" alt="8.png"></p><p>上图为一个单隐层前馈神经网络的拓扑结构，BP神经网络算法也使用梯度下降法（gradient descent），以单个样本的均方误差的负梯度方向对权重进行调节。可以看出：BP算法首先将误差反向传播给隐层神经元，调节隐层到输出层的连接权重与输出层神经元的阈值；接着根据隐含层神经元的均方误差，来调节输入层到隐含层的连接权值与隐含层神经元的阈值。BP算法基本的推导过程与感知机的推导过程原理是相同的，下面给出调整隐含层到输出层的权重调整规则的推导过程：</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb86229.png" alt="9.png"></p><p>学习率η∈（0，1）控制着沿反梯度方向下降的步长，若步长太大则下降太快容易产生震荡，若步长太小则收敛速度太慢，一般地常把η设置为0.1，有时更新权重时会将输出层与隐含层设置为不同的学习率。BP算法的基本流程如下所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc72cbb59e99.png" alt="10.png"></p><p>BP算法的更新规则是基于每个样本的预测值与真实类标的均方误差来进行权值调节，即BP算法每次更新只针对于单个样例。需要注意的是：BP算法的最终目标是要最小化整个训练集D上的累积误差，即：</p><p><img src="https://i.loli.net/2018/10/17/5bc72ce222a96.png" alt="11.png"></p><p>如果基于累积误差最小化的更新规则，则得到了累积误差逆传播算法（accumulated error backpropagation），即每次读取全部的数据集一遍，进行一轮学习，从而基于当前的累积误差进行权值调整，因此参数更新的频率相比标准BP算法低了很多，但在很多任务中，尤其是在数据量很大的时候，往往标准BP算法会获得较好的结果。另外对于如何设置隐层神经元个数的问题，至今仍然没有好的解决方案，常使用“试错法”进行调整。</p><p>前面提到，BP神经网络强大的学习能力常常容易造成过拟合问题，有以下两种策略来缓解BP网络的过拟合问题：</p><ul><li>早停：将数据分为训练集与测试集，训练集用于学习，测试集用于评估性能，若在训练过程中，训练集的累积误差降低，而测试集的累积误差升高，则停止训练。</li><li>引入正则化（regularization）：基本思想是在累积误差函数中增加一个用于描述网络复杂度的部分，例如所有权值与阈值的平方和，其中λ∈（0,1）用于对累积经验误差与网络复杂度这两项进行折中，常通过交叉验证法来估计。</li></ul><p><img src="https://i.loli.net/2018/10/17/5bc72ce227ff1.png" alt="12.png"></p><h2 id="5-4-全局最小与局部最小"><a href="#5-4-全局最小与局部最小" class="headerlink" title="5.4 全局最小与局部最小"></a><strong>5.4 全局最小与局部最小</strong></h2><p>模型学习的过程实质上就是一个寻找最优参数的过程，例如BP算法试图通过最速下降来寻找使得累积经验误差最小的权值与阈值，在谈到最优时，一般会提到局部极小（local minimum）和全局最小（global minimum）。</p><pre><code>* 局部极小解：参数空间中的某个点，其邻域点的误差函数值均不小于该点的误差函数值。* 全局最小解：参数空间中的某个点，所有其他点的误差函数值均不小于该点的误差函数值。</code></pre><p><img src="https://i.loli.net/2018/10/17/5bc72ce2803dc.png" alt="13.png"></p><p>要成为局部极小点，只要满足该点在参数空间中的梯度为零。局部极小可以有多个，而全局最小只有一个。全局最小一定是局部极小，但局部最小却不一定是全局最小。显然在很多机器学习算法中，都试图找到目标函数的全局最小。梯度下降法的主要思想就是沿着负梯度方向去搜索最优解，负梯度方向是函数值下降最快的方向，若迭代到某处的梯度为0，则表示达到一个局部最小，参数更新停止。因此在现实任务中，通常使用以下策略尽可能地去接近全局最小。</p><pre><code>* 以多组不同参数值初始化多个神经网络，按标准方法训练，迭代停止后，取其中误差最小的解作为最终参数。* 使用“模拟退火”技术，这里不做具体介绍。* 使用随机梯度下降，即在计算梯度时加入了随机因素，使得在局部最小时，计算的梯度仍可能不为0，从而迭代可以继续进行。</code></pre><h2 id="5-5-深度学习"><a href="#5-5-深度学习" class="headerlink" title="5.5 深度学习"></a><strong>5.5 深度学习</strong></h2><p>理论上，参数越多，模型复杂度就越高，容量（capability）就越大，从而能完成更复杂的学习任务。深度学习（deep learning）正是一种极其复杂而强大的模型。</p><p>怎么增大模型复杂度呢？两个办法，一是增加隐层的数目，二是增加隐层神经元的数目。前者更有效一些，因为它不仅增加了功能神经元的数量，还增加了激活函数嵌套的层数。但是对于多隐层神经网络，经典算法如标准BP算法往往会在误差逆传播时发散（diverge），无法收敛达到稳定状态。</p><p>那要怎么有效地训练多隐层神经网络呢？一般来说有以下两种方法：</p><ul><li><p>无监督逐层训练（unsupervised layer-wise training）：每次训练一层隐节点，把上一层隐节点的输出当作输入来训练，本层隐结点训练好后，输出再作为下一层的输入来训练，这称为预训练（pre-training）。全部预训练完成后，再对整个网络进行微调（fine-tuning）训练。一个典型例子就是深度信念网络（deep belief network，简称DBN）。这种做法其实可以视为把大量的参数进行分组，先找出每组较好的设置，再基于这些局部最优的结果来训练全局最优。</p></li><li><p>权共享（weight sharing）：令同一层神经元使用完全相同的连接权，典型的例子是卷积神经网络（Convolutional Neural Network，简称CNN）。这样做可以大大减少需要训练的参数数目。</p></li></ul><p><img src="https://i.loli.net/2018/10/17/5bc72ce28d756.png" alt="14.png"></p><p>深度学习可以理解为一种特征学习（feature learning）或者表示学习（representation learning），无论是DBN还是CNN，都是通过多个隐层来把与输出目标联系不大的初始输入转化为与输出目标更加密切的表示，使原来只通过单层映射难以完成的任务变为可能。即通过多层处理，逐渐将初始的“低层”特征表示转化为“高层”特征表示，从而使得最后可以用简单的模型来完成复杂的学习任务。</p><p>传统任务中，样本的特征需要人类专家来设计，这称为特征工程（feature engineering）。特征好坏对泛化性能有至关重要的影响。而深度学习为全自动数据分析带来了可能，可以自动产生更好的特征。</p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇主要讨论了决策树算法。首先从决策树的基本概念出发，引出决策树基于树形结构进行决策，进一步介绍了构造决策树的递归流程以及其递归终止条件，在递归的过程中，划分属性的选择起到了关键作用，因此紧接着讨论了三种评估属性划分效果的经典算法，介绍了剪枝策略来解决原生决策树容易产生的过拟合问题，最后简述了属性连续值/缺失值的处理方法。本篇将讨论现阶段十分热门的另一个经典监督学习算法—神经网络（neural network）。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(5)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/</id>
    <published>2020-07-26T21:20:38.000Z</published>
    <updated>2020-07-27T11:02:16.974Z</updated>
    
    <content type="html"><![CDATA[<p>上篇主要介绍和讨论了线性模型。首先从最简单的最小二乘法开始，讨论输入属性有一个和多个的情形，接着通过广义线性模型延伸开来，将预测连续值的回归问题转化为分类问题，从而引入了对数几率回归，最后线性判别分析LDA将样本点进行投影，多分类问题实质上通过划分的方法转化为多个二分类问题进行求解。本篇将讨论另一种被广泛使用的分类算法—决策树（Decision Tree）。<br><a id="more"></a></p><p>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:25px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="4、决策树"><a href="#4、决策树" class="headerlink" title="4、决策树"></a><strong>4、决策树</strong></h1><h2 id="4-1-决策树基本概念"><a href="#4-1-决策树基本概念" class="headerlink" title="4.1 决策树基本概念"></a><strong>4.1 决策树基本概念</strong></h2><p>顾名思义，决策树是基于树结构来进行决策的，在网上看到一个例子十分有趣，放在这里正好合适。现想象一位捉急的母亲想要给自己的女娃介绍一个男朋友，于是有了下面的对话：</p><hr><pre><code>  女儿：多大年纪了？  母亲：26。  女儿：长的帅不帅？  母亲：挺帅的。  女儿：收入高不？  母亲：不算很高，中等情况。  女儿：是公务员不？  母亲：是，在税务局上班呢。  女儿：那好，我去见见。</code></pre><hr><p>这个女孩的挑剔过程就是一个典型的决策树，即相当于通过年龄、长相、收入和是否公务员将男童鞋分为两个类别：见和不见。假设这个女孩对男人的要求是：30岁以下、长相中等以上并且是高收入者或中等以上收入的公务员，那么使用下图就能很好地表示女孩的决策逻辑（即一颗决策树）。</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec84a77.png" alt="1.png"></p><p>在上图的决策树中，决策过程的每一次判定都是对某一属性的“测试”，决策最终结论则对应最终的判定结果。一般一颗决策树包含：一个根节点、若干个内部节点和若干个叶子节点，易知：</p><pre><code>* 每个非叶节点表示一个特征属性测试。* 每个分支代表这个特征属性在某个值域上的输出。* 每个叶子节点存放一个类别。* 每个节点包含的样本集合通过属性测试被划分到子节点中，根节点包含样本全集。</code></pre><h2 id="4-2-决策树的构造"><a href="#4-2-决策树的构造" class="headerlink" title="4.2 决策树的构造"></a><strong>4.2 决策树的构造</strong></h2><p>决策树的构造是一个递归的过程，有三种情形会导致递归返回：(1) 当前结点包含的样本全属于同一类别，这时直接将该节点标记为叶节点，并设为相应的类别；(2) 当前属性集为空，或是所有样本在所有属性上取值相同，无法划分，这时将该节点标记为叶节点，并将其类别设为该节点所含样本最多的类别；(3) 当前结点包含的样本集合为空，不能划分，这时也将该节点标记为叶节点，并将其类别设为父节点中所含样本最多的类别。算法的基本流程如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc728ecc27fe.png" alt="2.png"></p><p>可以看出：决策树学习的关键在于如何选择划分属性，不同的划分属性得出不同的分支结构，从而影响整颗决策树的性能。属性划分的目标是让各个划分出来的子节点尽可能地“纯”，即属于同一类别。因此下面便是介绍量化纯度的具体方法，决策树最常用的算法有三种：ID3，C4.5和CART。</p><h3 id="4-2-1-ID3算法"><a href="#4-2-1-ID3算法" class="headerlink" title="4.2.1 ID3算法"></a><strong>4.2.1 ID3算法</strong></h3><p>ID3算法使用信息增益为准则来选择划分属性，“信息熵”(information entropy)是度量样本结合纯度的常用指标，假定当前样本集合D中第k类样本所占比例为pk，则样本集合D的信息熵定义为：</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec515a5.png" alt="3.png"></p><p>假定通过属性划分样本集D，产生了V个分支节点，v表示其中第v个分支节点，易知：分支节点包含的样本数越多，表示该分支节点的影响力越大。故可以计算出划分后相比原始数据集D获得的“信息增益”（information gain）。</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec3e067.png" alt="4.png"></p><p>信息增益越大，表示使用该属性划分样本集D的效果越好，因此ID3算法在递归过程中，每次选择最大信息增益的属性作为当前的划分属性。</p><h3 id="4-2-2-C4-5算法"><a href="#4-2-2-C4-5算法" class="headerlink" title="4.2.2 C4.5算法"></a><strong>4.2.2 C4.5算法</strong></h3><p>ID3算法存在一个问题，就是偏向于取值数目较多的属性，例如：如果存在一个唯一标识，这样样本集D将会被划分为|D|个分支，每个分支只有一个样本，这样划分后的信息熵为零，十分纯净，但是对分类毫无用处。因此C4.5算法使用了“增益率”（gain ratio）来选择划分属性，来避免这个问题带来的困扰。首先使用ID3算法计算出信息增益高于平均水平的候选属性，接着C4.5计算这些候选属性的增益率，增益率定义为：</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec69647.png" alt="5.png"></p><h3 id="4-2-3-CART算法"><a href="#4-2-3-CART算法" class="headerlink" title="4.2.3 CART算法"></a><strong>4.2.3 CART算法</strong></h3><p>CART决策树使用“基尼指数”（Gini index）来选择划分属性，基尼指数反映的是从样本集D中随机抽取两个样本，其类别标记不一致的概率，因此Gini(D)越小越好，基尼指数定义如下：</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec5a2ff.png" alt="6.png"></p><p>进而，使用属性α划分后的基尼指数为：</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec62eaf.png" alt="7.png"></p><h2 id="4-3-剪枝处理"><a href="#4-3-剪枝处理" class="headerlink" title="4.3 剪枝处理"></a><strong>4.3 剪枝处理</strong></h2><p>从决策树的构造流程中我们可以直观地看出：不管怎么样的训练集，决策树总是能很好地将各个类别分离开来，这时就会遇到之前提到过的问题：过拟合（overfitting），即太依赖于训练样本。剪枝（pruning）则是决策树算法对付过拟合的主要手段，剪枝的策略有两种如下：</p><pre><code>* 预剪枝（prepruning）：在构造的过程中先评估，再考虑是否分支。* 后剪枝（post-pruning）：在构造好一颗完整的决策树后，自底向上，评估分支的必要性。</code></pre><p>评估指的是性能度量，即决策树的泛化性能。之前提到：可以使用测试集作为学习器泛化性能的近似，因此可以将数据集划分为训练集和测试集。预剪枝表示在构造数的过程中，对一个节点考虑是否分支时，首先计算决策树不分支时在测试集上的性能，再计算分支之后的性能，若分支对性能没有提升，则选择不分支（即剪枝）。后剪枝则表示在构造好一颗完整的决策树后，从最下面的节点开始，考虑该节点分支对模型的性能是否有提升，若无则剪枝，即将该节点标记为叶子节点，类别标记为其包含样本最多的类别。</p><p><img src="https://i.loli.net/2018/10/17/5bc728ec80d34.png" alt="8.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc728ec9e330.png" alt="9.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc728ec9d497.png" alt="10.png"></p><p>上图分别表示不剪枝处理的决策树、预剪枝决策树和后剪枝决策树。预剪枝处理使得决策树的很多分支被剪掉，因此大大降低了训练时间开销，同时降低了过拟合的风险，但另一方面由于剪枝同时剪掉了当前节点后续子节点的分支，因此预剪枝“贪心”的本质阻止了分支的展开，在一定程度上带来了欠拟合的风险。而后剪枝则通常保留了更多的分支，因此采用后剪枝策略的决策树性能往往优于预剪枝，但其自底向上遍历了所有节点，并计算性能，训练时间开销相比预剪枝大大提升。</p><h2 id="4-4-连续值与缺失值处理"><a href="#4-4-连续值与缺失值处理" class="headerlink" title="4.4 连续值与缺失值处理"></a><strong>4.4 连续值与缺失值处理</strong></h2><p>对于连续值的属性，若每个取值作为一个分支则显得不可行，因此需要进行离散化处理，常用的方法为二分法，基本思想为：给定样本集D与连续属性α，二分法试图找到一个划分点t将样本集D在属性α上分为≤t与＞t。</p><pre><code>* 首先将α的所有取值按升序排列，所有相邻属性的均值作为候选划分点（n-1个，n为α所有的取值数目）。* 计算每一个划分点划分集合D（即划分为两个分支）后的信息增益。* 选择最大信息增益的划分点作为最优划分点。</code></pre><p><img src="https://i.loli.net/2018/10/17/5bc72a0968fad.png" alt="11.png"></p><p>现实中常会遇到不完整的样本，即某些属性值缺失。有时若简单采取剔除，则会造成大量的信息浪费，因此在属性值缺失的情况下需要解决两个问题：（1）如何选择划分属性。（2）给定划分属性，若某样本在该属性上缺失值，如何划分到具体的分支上。假定为样本集中的每一个样本都赋予一个权重，根节点中的权重初始化为1，则定义：</p><p><img src="https://i.loli.net/2018/10/17/5bc72a098f3be.png" alt="12.png"></p><p>对于（1）：通过在样本集D中选取在属性α上没有缺失值的样本子集，计算在该样本子集上的信息增益，最终的信息增益等于该样本子集划分后信息增益乘以样本子集占样本集的比重。即：</p><p><img src="https://i.loli.net/2018/10/17/5bc72a096ccc3.png" alt="13.png"></p><p>对于（2）：若该样本子集在属性α上的值缺失，则将该样本以不同的权重（即每个分支所含样本比例）划入到所有分支节点中。该样本在分支节点中的权重变为：</p><p><img src="https://i.loli.net/2018/10/17/5bc72a093ed3c.png" alt="14.png"></p><p>​    </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;上篇主要介绍和讨论了线性模型。首先从最简单的最小二乘法开始，讨论输入属性有一个和多个的情形，接着通过广义线性模型延伸开来，将预测连续值的回归问题转化为分类问题，从而引入了对数几率回归，最后线性判别分析LDA将样本点进行投影，多分类问题实质上通过划分的方法转化为多个二分类问题进行求解。本篇将讨论另一种被广泛使用的分类算法—决策树（Decision Tree）。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
  <entry>
    <title>周志华《Machine Learning》学习笔记(4)</title>
    <link href="http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/"/>
    <id>http://yoursite.com/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/</id>
    <published>2020-07-26T20:20:38.000Z</published>
    <updated>2020-07-27T11:02:10.190Z</updated>
    
    <content type="html"><![CDATA[<p>笔记的前一部分主要是对机器学习预备知识的概括，包括机器学习的定义/术语、学习器性能的评估/度量以及比较，本篇之后将主要对具体的学习算法进行理解总结，本篇则主要是第3章的内容—线性模型。<br><a id="more"></a></p><p>参考<a href="https://github.com/Vay-keen/Machine-learning-learning-notes" target="_blank" rel="noopener">此项目</a></p><div style="text-align:center;font-size:25px">目录</div><ul><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B01--%E7%BB%AA%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(1)—绪论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B02--%E6%80%A7%E8%83%BD%E5%BA%A6%E9%87%8F/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(2)—性能度量</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B03--%E5%81%87%E8%AE%BE%E6%A3%80%E9%AA%8C&amp;%E6%96%B9%E5%B7%AE&amp;%E5%81%8F%E5%B7%AE/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(3)—假设检验&amp;方差&amp;偏差</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B04--%E7%BA%BF%E6%80%A7%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(4)—线性模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B05--%E5%86%B3%E7%AD%96%E6%A0%91/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(5)—决策树</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B06--%E7%A5%9E%E7%BB%8F%E7%BD%91%E7%BB%9C/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(6)—神经网络</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B07--%E6%94%AF%E6%8C%81%E5%90%91%E9%87%8F%E6%9C%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(7)—支持向量机</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B08--%E8%B4%9D%E5%8F%B6%E6%96%AF%E5%88%86%E7%B1%BB%E5%99%A8/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(8)—贝叶斯分类器</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B09--EM%E7%AE%97%E6%B3%95/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(9)—EM算法</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B010--%E9%9B%86%E6%88%90%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(10)—集成学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B011--%E8%81%9A%E7%B1%BB/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(11)—聚类</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B012--%E9%99%8D%E7%BB%B4%E4%B8%8E%E5%BA%A6%E9%87%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(12)—降维与度量学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B013--%E7%89%B9%E5%BE%81%E9%80%89%E6%8B%A9%E4%B8%8E%E7%A8%80%E7%96%8F%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(13)—特征选择与稀疏学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B014--%E8%AE%A1%E7%AE%97%E5%AD%A6%E4%B9%A0%E7%90%86%E8%AE%BA/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(14)—计算学习理论</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B015--%E5%8D%8A%E7%9B%91%E7%9D%A3%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(15)—半监督学习</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B016--%E6%A6%82%E7%8E%87%E5%9B%BE%E6%A8%A1%E5%9E%8B/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(16)—概率图模型</a></li><li><a href="https://githubzhangshuai.github.io/2020/07/27/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine%20Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B017--%E5%BC%BA%E5%8C%96%E5%AD%A6%E4%B9%A0/" target="_blank" rel="noopener">周志华《Machine Learning》学习笔记(17)—强化学习</a></li></ul><h1 id="3、线性模型"><a href="#3、线性模型" class="headerlink" title="3、线性模型"></a><strong>3、线性模型</strong></h1><p>谈及线性模型，其实我们很早就已经与它打过交道，还记得高中数学必修3课本中那个顽皮的“最小二乘法”吗？这就是线性模型的经典算法之一：根据给定的（x，y）点对，求出一条与这些点拟合效果最好的直线y=ax+b，之前我们利用下面的公式便可以计算出拟合直线的系数a,b（3.1中给出了具体的计算过程），从而对于一个新的x，可以预测它所对应的y值。前面我们提到：在机器学习的术语中，当预测值为连续值时，称为“回归问题”，离散值时为“分类问题”。本篇先从线性回归任务开始，接着讨论分类和多分类问题。</p><p><img src="https://i.loli.net/2018/10/17/5bc722b068e48.png" alt="1.png"></p><h2 id="3-1-线性回归"><a href="#3-1-线性回归" class="headerlink" title="3.1 线性回归"></a><strong>3.1 线性回归</strong></h2><p>线性回归问题就是试图学到一个线性模型尽可能准确地预测新样本的输出值，例如：通过历年的人口数据预测2017年人口数量。在这类问题中，往往我们会先得到一系列的有标记数据，例如：2000—&gt;13亿…2016—&gt;15亿，这时输入的属性只有一个，即年份；也有输入多属性的情形，假设我们预测一个人的收入，这时输入的属性值就不止一个了，例如：（学历，年龄，性别，颜值，身高，体重）—&gt;15k。</p><p>有时这些输入的属性值并不能直接被我们的学习模型所用，需要进行相应的处理，对于连续值的属性，一般都可以被学习器所用，有时会根据具体的情形作相应的预处理，例如：归一化等；对于离散值的属性，可作下面的处理：</p><ul><li><p>若属性值之间存在“序关系”，则可以将其转化为连续值，例如：身高属性分为“高”“中等”“矮”，可转化为数值：{1， 0.5， 0}。</p></li><li><p>若属性值之间不存在“序关系”，则通常将其转化为向量的形式，例如：性别属性分为“男”“女”，可转化为二维向量：{（1，0），（0，1）}。</p></li></ul><p>（1）当输入属性只有一个的时候，就是最简单的情形，也就是我们高中时最熟悉的“最小二乘法”（Euclidean distance），首先计算出每个样本预测值与真实值之间的误差并求和，通过最小化均方误差MSE，使用求偏导等于零的方法计算出拟合直线y=wx+b的两个参数w和b，计算过程如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0ccec4.png" alt="2.png"></p><p>（2）当输入属性有多个的时候，例如对于一个样本有d个属性{（x1,x2…xd）,y}，则y=wx+b需要写成：</p><p><img src="https://i.loli.net/2018/10/17/5bc72567b8bcd.png" alt="0.png"></p><p>通常对于多元问题，常常使用矩阵的形式来表示数据。在本问题中，将具有m个样本的数据集表示成矩阵X，将系数w与b合并成一个列向量，这样每个样本的预测值以及所有样本的均方误差最小化就可以写成下面的形式：</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0ad8f7.png" alt="3.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc722b0af652.png" alt="4.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc722b090543.png" alt="5.png"></p><p>同样地，我们使用最小二乘法对w和b进行估计，令均方误差的求导等于0，需要注意的是，当一个矩阵的行列式不等于0时，我们才可能对其求逆，因此对于下式，我们需要考虑矩阵（X的转置*X）的行列式是否为0，若不为0，则可以求出其解，若为0，则需要使用其它的方法进行计算，书中提到了引入正则化，此处不进行深入。</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0cde33.png" alt="6.png"></p><p>另一方面，有时像上面这种原始的线性回归可能并不能满足需求，例如：y值并不是线性变化，而是在指数尺度上变化。这时我们可以采用线性模型来逼近y的衍生物，例如lny，这时衍生的线性模型如下所示，实际上就是相当于将指数曲线投影在一条直线上，如下图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc722b103cbf.png" alt="7.png"></p><p>更一般地，考虑所有y的衍生物的情形，就得到了“广义的线性模型”（generalized linear model），其中，g（*）称为联系函数（link function）。</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0a2841.png" alt="8.png"></p><h2 id="3-2-线性几率回归"><a href="#3-2-线性几率回归" class="headerlink" title="3.2 线性几率回归"></a><strong>3.2 线性几率回归</strong></h2><p>回归就是通过输入的属性值得到一个预测值，利用上述广义线性模型的特征，是否可以通过一个联系函数，将预测值转化为离散值从而进行分类呢？线性几率回归正是研究这样的问题。对数几率引入了一个对数几率函数（logistic function）,将预测值投影到0-1之间，从而将线性回归问题转化为二分类问题。</p><p><img src="https://i.loli.net/2018/10/17/5bc722b0c7748.png" alt="9.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc722b0a655d.png" alt="10.png"></p><p>若将y看做样本为正例的概率，（1-y）看做样本为反例的概率，则上式实际上使用线性回归模型的预测结果器逼近真实标记的对数几率。因此这个模型称为“对数几率回归”（logistic regression），也有一些书籍称之为“逻辑回归”。下面使用最大似然估计的方法来计算出w和b两个参数的取值，下面只列出求解的思路，不列出具体的计算过程。</p><p><img src="https://i.loli.net/2018/10/17/5bc723b824f0c.png" alt="11.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc723b817961.png" alt="12.png"></p><h2 id="3-3-线性判别分析"><a href="#3-3-线性判别分析" class="headerlink" title="3.3 线性判别分析"></a><strong>3.3 线性判别分析</strong></h2><p>线性判别分析（Linear Discriminant Analysis，简称LDA）,其基本思想是：将训练样本投影到一条直线上，使得同类的样例尽可能近，不同类的样例尽可能远。如图所示：</p><p><img src="https://i.loli.net/2018/10/17/5bc723b863ebb.png" alt="13.png"><img src="https://i.loli.net/2018/10/17/5bc723b85bfa9.png" alt="14.png"></p><p>想让同类样本点的投影点尽可能接近，不同类样本点投影之间尽可能远，即：让各类的协方差之和尽可能小，不用类之间中心的距离尽可能大。基于这样的考虑，LDA定义了两个散度矩阵。</p><ul><li>类内散度矩阵（within-class scatter matrix）</li></ul><p><img src="https://i.loli.net/2018/10/17/5bc723b8156e1.png" alt="15.png"></p><ul><li>类间散度矩阵(between-class scaltter matrix)</li></ul><p><img src="https://i.loli.net/2018/10/17/5bc723b7e9db3.png" alt="16.png"></p><p>因此得到了LDA的最大化目标：“广义瑞利商”（generalized Rayleigh quotient）。</p><p><img src="https://i.loli.net/2018/10/17/5bc723b7e8a61.png" alt="17.png"></p><p>从而分类问题转化为最优化求解w的问题，当求解出w后，对新的样本进行分类时，只需将该样本点投影到这条直线上，根据与各个类别的中心值进行比较，从而判定出新样本与哪个类别距离最近。求解w的方法如下所示，使用的方法为λ乘子。</p><p><img src="https://i.loli.net/2018/10/17/5bc723b83d5e0.png" alt="18.png"></p><p>若将w看做一个投影矩阵，类似PCA的思想，则LDA可将样本投影到N-1维空间（N为类簇数），投影的过程使用了类别信息（标记信息），因此LDA也常被视为一种经典的监督降维技术。<br>​             </p><h2 id="3-4-多分类学习"><a href="#3-4-多分类学习" class="headerlink" title="3.4 多分类学习"></a><strong>3.4 多分类学习</strong></h2><p>现实中我们经常遇到不只两个类别的分类问题，即多分类问题，在这种情形下，我们常常运用“拆分”的策略，通过多个二分类学习器来解决多分类问题，即将多分类问题拆解为多个二分类问题，训练出多个二分类学习器，最后将多个分类结果进行集成得出结论。最为经典的拆分策略有三种：“一对一”（OvO）、“一对其余”（OvR）和“多对多”（MvM），核心思想与示意图如下所示。</p><ul><li><p>OvO：给定数据集D，假定其中有N个真实类别，将这N个类别进行两两配对（一个正类/一个反类），从而产生N（N-1）/2个二分类学习器，在测试阶段，将新样本放入所有的二分类学习器中测试，得出N（N-1）个结果，最终通过投票产生最终的分类结果。</p></li><li><p>OvM：给定数据集D，假定其中有N个真实类别，每次取出一个类作为正类，剩余的所有类别作为一个新的反类，从而产生N个二分类学习器，在测试阶段，得出N个结果，若仅有一个学习器预测为正类，则对应的类标作为最终分类结果。</p></li><li><p>MvM：给定数据集D，假定其中有N个真实类别，每次取若干个类作为正类，若干个类作为反类（通过ECOC码给出，编码），若进行了M次划分，则生成了M个二分类学习器，在测试阶段（解码），得出M个结果组成一个新的码，最终通过计算海明/欧式距离选择距离最小的类别作为最终分类结果。</p></li></ul><p><img src="https://i.loli.net/2018/10/17/5bc723b862bfb.png" alt="19.png"></p><p><img src="https://i.loli.net/2018/10/17/5bc723b8300d5.png" alt="20.png"></p><h2 id="3-5-类别不平衡问题"><a href="#3-5-类别不平衡问题" class="headerlink" title="3.5 类别不平衡问题"></a><strong>3.5 类别不平衡问题</strong></h2><p>类别不平衡（class-imbanlance）就是指分类问题中不同类别的训练样本相差悬殊的情况，例如正例有900个，而反例只有100个，这个时候我们就需要进行相应的处理来平衡这个问题。常见的做法有三种：</p><ol><li>在训练样本较多的类别中进行“欠采样”（undersampling）,比如从正例中采出100个，常见的算法有：EasyEnsemble。</li><li>在训练样本较少的类别中进行“过采样”（oversampling）,例如通过对反例中的数据进行插值，来产生额外的反例，常见的算法有SMOTE。</li><li>直接基于原数据集进行学习，对预测值进行“再缩放”处理。其中再缩放也是代价敏感学习的基础。<img src="https://i.loli.net/2018/10/17/5bc726fe87ae2.png" alt="21.png"></li></ol><p>​<br>​      </p>]]></content>
    
    <summary type="html">
    
      &lt;p&gt;笔记的前一部分主要是对机器学习预备知识的概括，包括机器学习的定义/术语、学习器性能的评估/度量以及比较，本篇之后将主要对具体的学习算法进行理解总结，本篇则主要是第3章的内容—线性模型。&lt;br&gt;&lt;/p&gt;
    
    </summary>
    
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/categories/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
    
      <category term="机器学习" scheme="http://yoursite.com/tags/%E6%9C%BA%E5%99%A8%E5%AD%A6%E4%B9%A0/"/>
    
      <category term="周志华《Machine Learning》学习笔记" scheme="http://yoursite.com/tags/%E5%91%A8%E5%BF%97%E5%8D%8E%E3%80%8AMachine-Learning%E3%80%8B%E5%AD%A6%E4%B9%A0%E7%AC%94%E8%AE%B0/"/>
    
  </entry>
  
</feed>
